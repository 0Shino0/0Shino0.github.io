{"meta":{"title":"yyshino的小破屋","subtitle":"welcome to yyshino's blog","description":"向着远方不断前进","author":"yyshino","url":"https://blog.yyshino.top","root":"/"},"pages":[{"title":"","date":"2022-08-14T14:24:58.972Z","updated":"2022-08-14T14:24:58.972Z","comments":true,"path":"about/index.html","permalink":"https://blog.yyshino.top/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"所有分类","date":"2022-08-14T14:25:45.226Z","updated":"2022-08-14T14:25:45.226Z","comments":true,"path":"categories/index.html","permalink":"https://blog.yyshino.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-14T14:33:27.748Z","updated":"2022-08-14T14:33:27.748Z","comments":true,"path":"404.html","permalink":"https://blog.yyshino.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"contact","date":"2022-05-13T03:52:01.000Z","updated":"2022-05-13T03:53:16.927Z","comments":true,"path":"contact/index.html","permalink":"https://blog.yyshino.top/contact/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-08-14T14:28:09.412Z","updated":"2022-08-14T14:28:09.412Z","comments":true,"path":"friends/index.html","permalink":"https://blog.yyshino.top/friends/index.html","excerpt":"","text":""},{"title":"recommend","date":"2022-09-20T14:36:58.000Z","updated":"2022-09-20T14:36:58.821Z","comments":true,"path":"recommend/index.html","permalink":"https://blog.yyshino.top/recommend/index.html","excerpt":"","text":""},{"title":"bangumis","date":"2022-05-15T06:07:34.000Z","updated":"2022-05-15T06:07:34.727Z","comments":true,"path":"bangumis/index.html","permalink":"https://blog.yyshino.top/bangumis/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-14T14:27:07.841Z","updated":"2022-08-14T14:27:07.841Z","comments":true,"path":"mylist/index.html","permalink":"https://blog.yyshino.top/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-08-14T14:26:32.580Z","updated":"2022-08-14T14:26:32.580Z","comments":true,"path":"tags/index.html","permalink":"https://blog.yyshino.top/tags/index.html","excerpt":"","text":""},{"title":"","date":"2022-10-08T08:51:45.690Z","updated":"2022-10-08T08:51:45.690Z","comments":true,"path":"showgame/index.html","permalink":"https://blog.yyshino.top/showgame/index.html","excerpt":"","text":""}],"posts":[{"title":"一个月入门计算机基础知识","slug":"计算机科学","date":"2022-08-27T02:41:33.000Z","updated":"2022-09-16T10:33:24.562Z","comments":true,"path":"posts/288.html","link":"","permalink":"https://blog.yyshino.top/posts/288.html","excerpt":"","text":":muscle:高级语言程序设计:muscle:数据结构:point_down:计算机组成原理:point_down:简介解释概念 计算机系统是由计算机硬件与计算机软件构成的。 计算机硬件是计算机的实体部分。 计算机软件是由看不见摸不着的，由人们事先编制的具有各类特殊功能的程序构成，通常分为系统软件、应用软件。 高级语言：不必了解、掌握实际机器的机型，内部具体组成及其指令系统，只要掌握这类语言的语法就可以直接用来编程。 汇编语言：用符号ADD、SUB、MVL、DIV、等分别表示加减乘除不必使用二进制代码来编写程序。 机器语言：用0、1代码来表示的语言，可以直接在机器上执行。 差别与联系：机器语言可以直接在机器上执行，汇编语言必须用汇编语言程序翻译成机器语言程序才可以运行。高级语言则需要先转变为汇编语言再转变为机器语言才能执行。 冯诺依曼计算机 特点 由运算器、存储器、控制器、输入设备、输出设备五大部分构成。 指令和地址以同等地位存放于存储器内，并可按地址寻访。 指令和地址均用二进制表示。 指令由操作码和地址码组成，操作码表示操作的性质，地址码用来表示操作数在存储器中的位置。 主机：CPU与主存构成。 CPU：由运算器和控制器构成。 主存：包括存储体M，各种逻辑部件及控制电路等。 存储单元：由若干个存储原件构成，可存储一串二进制代码。 存储元件：可存储以为二进制代码。 机器字长：CPU一次能处理数据的位数。 指令字长：机器指令中二进制代码的总位数。 CPU：中央处理器。 PC：程序计数器。 IR：指令寄存器。 CU:控制单元。 ALU：算术逻辑单 ACC：累加器。 MAR：存储器地址寄存器。 MDR：存储器数据寄存器。 I&#x2F;O:分为I&#x2F;O设备和I&#x2F;O接口两个部分。 MIPS：百万条指令每秒。 CPI：执行一条指令所需的时钟周期。 FLOPS：浮点运算次数每秒。 总线带宽：总线的数据传输速率及单位时间内，总线上传输数据的位数通常用每秒传输信息的字节数来衡量。 总线复用：一条信号线上分时传送两种信号。 总线的主设备（或主模块）：对总线有控制权。 总线的从设备（或从模块）：只能响应主设备，对总线没有控制权。 总线的传输周期：将完成一次总线操作的时间称为总线的传输周期。 主存：可以和CPU直接交换信息的存储器（DRAM+ROM）。 辅存：主存的后援存储器用来存放当前暂时不用的程序和数据，不能与CPU直接交换信息。 Cache：高速缓存，CPU可以将要取的信息送至此处。 RAM：随机存储器是一种可读&#x2F;写存储器，掉电后数据丢失。 SRAM：静态RAM，触发器来存储信息，既读又写，位价高。 DRAM：动态RAM，利用电容的原理来存储信息，但由于电容的原理需要再生电路。 ROM：只读存储器，只能对其存储的内容读出，而不能对其重新写入的存储器。 PROM：可编程只读存储器，可对存储器进行一次编程。 EPROM：可擦除可编程只读存储器可用紫外线照射擦除内容，再进行编程。 EEPROM：电可擦除可编程只读存储器。 CDROM:光盘。 Flash Memory:闪速存储器，功能与EEPROM相似，但速度快的多。 机器指令：每一条机器语言的语句。 指令系统：全部机器指令的集合。 RISC: 精简指令系统计算机。 CISC:复杂指令系统计算机。 现代计算机硬件框图 ALU(运算器)和CU(控制器)构成CPU 主存和辅存 构成 存储器 CPU 与 存储器 组成 主机 输入输出设备组成 IO设备 以上所有为计算机 硬件 系统复杂性的管理方法 层次化：将被设计的系统划分为多个模块或子模块 模块化: 有明确的定义的功能和接口 规则性: 模块更容易被重用 计算机取数 过程 取指令 PC –&gt; MAR –&gt; M –&gt; MDR –&gt;IR , (PC) + 1 –&gt; PC (PC自增) 分析指令 OP(IR) –&gt; CU 执行指令 Ad(IR) –&gt; MAR –&gt; M –&gt; MDR –&gt; ACC 程序的运行过程 将程序通过输入设备送至计算机 程序首地址 一&gt; PC 启动程序运行 计算机取数过程 取指令 PC –&gt; MAR –&gt; M –&gt; MDR –&gt;IR , (PC) + 1 –&gt; PC (PC自增) 分析指令 OP(IR) –&gt; CU 执行指令 Ad(IR) –&gt; MAR –&gt; M –&gt; MDR –&gt; ACC … 打印结果 停机 计算机硬件的主要技术指标 计算机硬件的主要技术指标是 机器字长 CPU一次能处理数据的位数与CPU中的寄存器位数有关 存储容量: 存放二进制信息的总位数 主存容量 1K &#x3D; 2 存储单元个数 * 存储字长 MAR MDR 容量 10 8 1K * 8位 ( $ 1K &#x3D; 2^{10} $ ) 16 32 64K * 32位 字节数 如 $ 2^{13}b &#x3D; 1KB $ ( $ 1B &#x3D; 2^{3}b $ ) $ 2^{21}b &#x3D; 256KB $ 辅存容量 字节数 80GB ( $ 1GB &#x3D; 2^{30}B $ ) 运算速度 主频 核数 每个核支持的线程数 吉普森法 $ T_m &#x3D; \\sum_{i&#x3D;1}^n f_it_i $ CPI MIPS FLOPS 总线总线是连接各个部件的信息传输线 是各个部件共享的传输介质 总线是连接多个部件的信息传输线，在任一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收信息。 总线的分类 片内总线：芯片内部的总线 系统总线：计算机各个部件之间的信息传输线 数据总线：双向 与机器字长、存储字长有关 地址总线：单向 与存储地址、I&#x2F;O地址有关 控制总线：有出有入 ( 中断请求、总线请求 ) 通信总线：用于计算机系统之间或计算机系统与其他系统 (如控制仪表、移动通信等)之间的通信 传输方式 串行通信总线 并行通信总线 总线特性及性能指标总线特性 机械特性: 尺寸、形状、管脚数及排列顺序 电气特性: 传输方向和有效的电平范围 功能特性: 每根传输线的功能 地址 数据 控制 时间特性 性能指标 总线宽度：数据线的根数 标准传输率：每秒传输的最大字节数( MBps ) 时钟同步&#x2F;异步：同步、不同步 总线复用：地址线 与 数据线 复用 信号线数：地址线、数据线何控制线的总和 总线控制方式： 突发、自动、仲裁、逻辑、计数 其他指标：负载能力 总线标准按照总线标准生产的各个部件，各模块之间可以集成在一起 ISA EISA VESA(VL-BUS) PCI AGP RS-232 USB 总线结构 单总线结构 系统总线 所有 双总线结构 主存总线 CPU与主存之间传输信息 I&#x2F;O总线 I&#x2F;O接口 外部设备 通道： 具有特殊功能的处理器，由通道对I&#x2F;O统一管理 主存总线与I&#x2F;O总线通过通道连接，实现IO设备与主存储器、IO设备与CPU直接的通讯、 三总线结构 主存总线 CPU与主存之间传输信息 I&#x2F;O总线 I&#x2F;O设备与主存之间直接交换信息 DMA总线 外部设备直接存储器访问 三总线结构中，任一时刻只能使用一种总线 三总线结构又一形式 局部总线 系统总线 扩展总线 常用的总线结构有几种？不同的总线结构对计算机的性能有什么影响？举例说明。（单/多） 常见的总线结构分为两种分别是单总线结构和多总线结构。 单总线结构是将CPU、主存，I/O设备（通过I/O接口）都挂在这一总线上、允许I/O设备之间、I/O设备与CPU之间或I/o设备与主存之间直接交换信息。 单总线结构结构简单、易于扩充，但所有的传送都通过这一总线，不允许两个以上的部件在同一时刻向总线传输信息，会影响系统的工作效率，易形成计算机的瓶颈，故常用于功能简单的实验仪器型机器的设计。 多总线结构：双总线结构将速度较低的I/O设备从单总线上分离出来，形成主存总线与I/O总线分开的结构，而多总线结构就是在其基础上增加总线，形成多总线结构，多总线结构，可以实现多种总线之间的数据传递，可明显提升系统的工作效率，例如，现代微机的结构就是多总线结构 总线控制总线判优控制基本概念 主设备（模块） 对总线有控制权 从设备（模块） 响应从主设备发来的总线命令 集中式 链式查询方式 只需要很少的几根线就能按一定优先次序实现总线控制，而且很容易扩充设备，但对电路故障很敏感且优先级别低的设备可能很难获得请求 计数器定时查询 这种查询方式对电路故障不如链式查询敏感，但增加了控制线设备地址数，控制页较复杂 独立请求方式 独立请求方式响应速度快，优先次序控制灵活，但控制线数量多，总线控制更复杂。 为什么要设置总线判优控制? 因为总线上连接着多个部件，需要一种机制来决定什么时候有哪个部件发送信息、如何给信息传送定时，如何防止信息丢失、如何规定接收部件的一系列问题，因此，为了解决这些多个部件的使用权问题，出现了总线判优机制。 哪种方式响应时间最快，哪种方式对电路故障最敏感? 独立请求方式响应速度快，链式查询对电路故障敏感。 分布式 总线通信控制目的: 解决通信双方协调配合问题 总线传输周期 申请分配阶段：主模块申请，总线仲裁决定 寻址阶段：主模块向从模块给出地址和命令 传数阶段：主模块和从模块交换数据 结束阶段：主模块撤销有关西段 总线通信的四种方式 同步通信：由统一时标控制数据传送 异步通信：采用应答方式，没有公共时钟标准 不互锁 半互锁 全互锁 半同步通信：同步、异步结合 上述三种通信的共同点（一个总线传输周期（以输入数据为例）） 主模块发地址、命令 占用总线 从模块准备数据 不占用总线 总线空闲 从模块向组模块发数据 占用总线 分离式通信：充分挖掘系统 总线每个瞬间 的潜力 特点 各模块有权申请占用总线 采用同步方式通信,不等对方回答 各模块准备数据时,不占用总线 总线被占用时,无空闲 试比较同步通信和异步通信。 同步通信优点，规划明确，统一模块之间的配合简单一致。 缺点主、从设备时间配合属于强制性同步，必须在限定时间内完成规定的要求，必须按最慢部件来设计公共时钟，严重影响总线的工作效率。 异步通信客服了同步通信的缺点，允许各模块的速度不一致性，没有公共的时钟标准，不要求所有部件严格统一操作时间，即当主模块发出请求，一直等待从模块反馈回来响应。 为什么说半同步通信同时保留了同步通信和异步通信的特点？ 同步通信既保留了同步通信的基本特点，如所有的地址命令，数据信号的发出时间都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别，同时又像异步通信那样允许不同速度的模块和谐的工作 主存储器简介 分类 存储介质分类 半导体存储器：TTL、MOS 磁表面存储器：磁头、载磁体 磁芯存储器：硬磁材料、环状元件 光盘存储器：激光、磁光材料 按存取方式分类 存取时间与物理地址无关（随机访问） 随机存储器：在程序的执行过程中可读可写 只读存储器：在程序的执行过程中只读 存取时间与物理地址无关（串行访问） 顺序存取存储器——磁带 直接存取存储器——磁盘 按在计算机中的作用分类 主存储器 RAM 静态RAM（SRAM） 保存0和1的原理是什么? 基本单元电路的构成是什么? 对单元电路如何读出和写入? 典型芯片的结构是很么样子的? 静态RAM芯片的如何进行读出和写入操作? 动态RAM（DRAM） ROM（只读存储器） MROM（掩膜ROM） PROM（一次性编程） EPROM（多次性编程）——紫外线 EEPROM（多次性编程）——电可擦写 Flash Memory（闪速型存储器）——U盘 高速缓冲存储器（Cache） 辅助存储器 4.8试比较静态 RAM 和动态 RAM 。 静态RAM是由触发器构成的存储器，位价高。 动态RAM是电容构成的存储器，价位低，但需要配置刷新电路。 SRAM在相同的存储容量的条件下，需要更大的体积集成度低，DRAM集成度高。 4.9什么叫刷新？为什么要刷新？说明刷新有几种方法。 电容上的电荷一般只能维持1～2ms 因此，即使电源不掉，电信息也会自动消失，为此，必须在2ms内对其所有存储单元恢复一次原状态，这个过程称为再生或刷新。 刷新的方法有三种： 集中刷新：是在规定的一个刷新周期内，对存储单元集中一段时间内逐行刷新，停止读/写。（有死区） 分散刷新：（抽空刷新） 异步刷新：前两种的结合。 存储器的层次结构 缓存-主存（速度问题——硬件解决） 主存-辅存（容量问题——软硬件相结合） 存储器三个主要特性的关系 主存和CPU的联系 主存中存储单元地址的分配 主存的技术指标 存储容量：主存 存放二进制代码的总位数 存储速度： 存取时间：存储器的访问时间 | 读出时间 写入时间 存取周期：连续两次独立的存储器操作（读或写）所需的 最小间隔时间 | 读周期 写周期 存储器的带宽：位&#x2F;秒 4.2计算机中哪些部件可用于存储信息，按其速度、容量和价格／位排序说明。 计算机中可用寄存器，缓存，主存，磁盘，磁带来存储信息。 寄存器 缓存 越下容量越大 主存 越上速度越快 磁盘 越上位价越贵 磁带 4.3存储器的层次结构主要体现在什么地方，为什么要分这些层次，计算机如何管理这些层次？ 存储器的层次结构主要体现在缓存-主存，主存-辅存，这两存储层次上， 缓存-主存，层次主要解决CPU和主存速度不匹配的问题，主存和缓存之间的数据调动是由硬件自动完成的，对程序员是透明的。 主存-辅存层次主要解决系统的容量问题，辅存速度比主存低而且不能与CPU直接交换信息，但容量比储存大CPU要用这些数据时就将辅存中的数据复刻到主存中，由CPU调用直接访问。 现代计算机系统几乎都有这两存储层次，构成了缓存，主存，辅存三级存储系统，并逐渐形成了虚拟存储系统。 4.5什么是存储器的带宽？着存储器的数据总线宽度为32 位，存取周期为200 ns ，则存储器的带宽是 存储带宽是单位时间内存储器存取的信息量。 1/200ns*32=160M位/S 4.10半导体存储器芯片的译码駆动方式有几种？ 译码驱动有两种方法，线选法与重合法。 重合法比线选法，更好使得字线根数减少，可以用较少的字线来选择更多的数据，刻电路面积减小。 半导体存储芯片简介 基本结构 片选线：确定存储地址 读&#x2F;写控制线：确定读写 译码驱动方式：给出了存储单元的地址后，怎么去找到指定的存储单元 线选法 重合法 4.10半导体存储器芯片的译码駆动方式有几种？ 译码驱动有两种方法，线选法与重合法。 重合法比线选法，更好使得字线根数减少，可以用较少的字线来选择更多的数据，刻电路面积减小。 存储器与CPU的连接 存储器容量的扩展 位扩展（增加存储字长） 两个芯片的片选使用相同的信号连接 字扩展（增加存储字的数量） 字、位同时扩展 存储器校验编码的最小距离：任意两组合法代码之间 二进制位数 的 最小差异编码的纠错、检错能力与编码的最小距离有关 L-1 &#x3D; D + C (D&gt; &#x3D; C) L—— 编码的最小距离 D—— 检测错误的位数 C—— 纠正错误的位数 奇偶校验汉明码校验汉明码的组成 汉明码的组成需增添？位检测位 $$ 2^k &gt;&#x3D; n + k + 1 $$ 检测位的位置 $$ 2^i (i&#x3D; 0,1,2,3,…) $$ 检测位的取值 检测位的取值与该位所在的检测“小组”承担的奇偶校验任务有关 汉明码的检错 汉明码的奇配原则：按照偶配原则计算的Ci后，取反的奇配原则下的检测位取值。 高速缓冲存储器 （Cache）简介 问题的提出 避免CPU“空等”现象 CPU和主存（DRAM）的速度差异 程序访问的局部性原理 Cache工作原理Cache的命中率命中：主存块调入缓存（主存块与缓存块建立了对应关系） 不命中：主存块未调入缓存（主存块与缓存块未建立对应关系） 命中率：CPU欲访问的信息在Cache中的比率（命中率与Cahche的容量与块长有关） Cache-主存系统的效率效率e与命中率有关 $$ e &#x3D; \\frac{访问Cache的时间}{平均访问时间}*100% $$ Cache的基本结构 Cache读写操作 读 写 Cache和主存的一致性 写直法（Write-through） 写操作时数据既写入Cache又写入主存写操作时间就是访问主存的时间, Cache块退出时,不需要对主存执行写操作,更新策略比较容易实现 写回法 （Write-back） 写操作时只把数据写入Cache而不写入主存当Cache数据被替换出去时才写回主存**,写操作时间就是访问Cache的时间**, Cache块退出时,被替换的块需写回主存,增加Cache的复杂性 Cache改进 增加Cache的级数 片载（片内）Cache 片外Cache 统一缓存和分立缓存 指令Cache 数据Cache 与指令执行的控制方式有关 是否流水 Cache-主存的地址映射 直接映射 某一主存块只能固定映射到某一缓存块 特点：不灵活、Cache利用率低、速度快 全相联映射 某一主存块能映射到任一缓存块 特点：成本高、Cache利用率高、速度慢 组相连映射 直接映射和全相联映射的折中。 某一主存块只能映射到某一缓存组中的任意缓存块 特点：Cache利用率比较高、速度比较快 替换算法 解决问题：Cache满时选择正确的块，从Cache中退出 先进先出（FIFO）算法 近期最少使用（LRU）算法 4.25 什么是程序访问的局部性？存储系统哪一阶段采用了程序访问的局限性原理？ 通过大量典型程序分析发现，CPU从主存取指令获取数据，在一定时间内只是对主存局部地址区域的访问，这是由于指令和数据在主存内都是连续存放的，并且有些指令和数据往往会被多次调用，集指令和数据在储存的地址分部不是随机的，而是相对簇聚的，使得CPU在执行程序时访存具有相对的局部性，这就称为程序访问的局部性原理。 Cache-主存层次与主存辅存层次采用了局部性原理。 4.26计算机中设置 Cache 的作用是什么？能不能把 Cache 的容量扩大，最后取代主存，为什么？ Cache的出现，大大提高了CPU访问主存的速度，中央处理器可以不直接访问主存，直接与Cache交换信息，极大地解决了CPU与主存之间速度矛盾的问题。 不可以将Cache的容量扩大，进而取代主存，一般而言，cache容量越大即CPU命中率越高，当然容量也没有必要太大，太大会增加成本，当容量达到一定值时，命中率已不再因容量增加而显著增加。 4.27 Cache 制作在 CPU 芯片内有什么好处？将指令Cache和数据Cache分开又有什么好处？ Cache制作在CPU内部提高了外部总线利用率，因为Cache在CPU内部可直接访问，不必占用外部总线，进而增强了系统的整体效率，也提高了CPU存储速度。 将指令Cache与数据Cache分开有以下好处 可支持超前控制和流水线控制，有利于这类控制方式下指令预取操作的完成。 指令Cache可用ROM实现，提高指令存取可靠性。 数据Cache对不同类型数据支持更为灵活。 辅助存储器概述 特点：不直接与CPU交换信息 I&#x2F;O系统（输入输出系统）概述 早期 分散连接 CPU和I&#x2F;O设备 串行 工作 程序查询方式 接口模块和DMA阶段 总线连接 CPU和I&#x2F;O设备 并行 工作 中断方式 DMA方式 具有通道结构的阶段 具有I&#x2F;O处理机的阶段 组成 I&#x2F;O软件 I&#x2F;O指令 CPU指令的一部分 操作码 命令码 设备码 通道指令 通道自身的指令 I&#x2F;O硬件 设备 I&#x2F;O接口 设备 设备控制器 通道 I&#x2F;O设备与主机的联系方式 I&#x2F;O设备编址方式 统一编址 用取数、存数 不统一编址 有专门的I&#x2F;O指令 设备选址 用设备选择电路识别是否被选中 传送方式 串行 并行 联系方式 计算方法指令系统计算机网络入门常用的网络配置命令 Ping、 IPConfig、 Tracert、 Nslookup、 Netstat、 ARP、 Route、 Nbtstat Cisco Packet Tracer操作系统算法摘要:chicken:计算机组成原理（哈工大刘宏伟）135讲（全）高清https://www.bilibili.com/video/BV1t4411e7LH?p=48&spm_id_from&#x3D;333.1007.top_right_bar_window_history.content.click&amp;vd_source&#x3D;fb3505db9b87542728213f28843a6d74","categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://blog.yyshino.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.yyshino.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"Vue后台通用管理系统总结","slug":"Vue后台通用管理系统总结","date":"2022-07-24T01:22:06.000Z","updated":"2022-10-09T03:35:46.006Z","comments":true,"path":"posts/1327.html","link":"","permalink":"https://blog.yyshino.top/posts/1327.html","excerpt":"","text":"company-admin项目地址 https://github.com/0Shino0/company-admin 技术栈 Vue3 + Element Plus + Sass 实现前台 Koa2 + MongoDB 实现后台 Vite项目构建 前台环境变量配置.env.dev config 配置不同环境的 api (方便调节 和 测试) dev baseApi mockApi test baseApi mockApi prod baseApi mockApi 对外暴露 config &#x3D;&gt; 二次封装axios 二次封装axios 创建axios实例对象 请求拦截器 获取请求头headers 获取token (如果请求头中存在token) 响应拦截器 比对状态码 code 判断token是否超时 返回 成功&#x2F; 错误提示 核心函数 一般默认发送 get请求 (将请求方法 转化为大写) 判断 使用 mockApi 还是 baseApi 对不同的 请求方法进行遍历 二次封装 storage/** * Storage二次封装 * @author YyShino */ import config from './../config' export default { // 存储 setItem(key, val) { let storage = this.getStorage(); storage[key] = val; window.localStorage.setItem(config.namespace, JSON.stringify(storage)); }, // 获取 getItem(key) { return this.getStorage()[key] }, getStorage() { // JSON.parse() 方法用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换 (操作)。 return JSON.parse(window.localStorage.getItem(config.namespace) || \"{}\"); }, // 删除 一个 clearItem(key) { // 读取 let storage = this.getStorage(); // 删除 delete storage[key]; // 写入并 覆盖 window.localStorage.setItem(config.namespace, JSON.stringify(storage)); }, // 删除 全部 clearAll() { window.localStorage.clear() } } 公共组件封装 BreadCrumb.vue (头部区域) Home.vue (主要内容) TreeMenu.vue (左侧菜单栏) Vue-Router 和 VuexVue-Router 注册路由 (routes) &#x2F; Welcome 动态添加路由 Login 404 动态添加路由 (addRoute) 系统管理 User Menu Role Dept 审批管理 Leave Approve 动态路由实现 // router 主文件 async function loadAsyncRoutes() { // console.log(loadAsyncRoutes()); let userInfo = storage.getItem(\"userInfo\") || {}; if (userInfo.token) { try { const { menuList } = await API.getPermissionList(); // utils 为封装工具类 let routes = utils.generateRoute(menuList); routes.map((route) => { let url = `./../views/${route.component}.vue`; route.component = () => import(url); router.addRoute(\"home\", route); }) } catch (error) { } } } await loadAsyncRoutes() // utils 封装工具类 generateRoute // 动态路由拼接 generateRoute(menuList) { let routes = [] const deepList = (list) => { while (list.length) { let item = list.pop() if (item.action) { routes.push({ name: item.component, path: item.path, meta: { title: item.menuName }, component: item.component }) } if (item.children &amp;&amp; !item.action) { deepList(item.children) } } } deepList(menuList) return routes; } 路由守卫 (beforeEach) router.beforeEach((to, from, next) => { // console.log(router.hasRoute(to.name)); if (router.hasRoute(to.name)) { document.title = to.meta.title; next() } else { next('/404') } }) Vuex state 利用storage存储用户信息、菜单信息、菜单行为信息(创建、查看、编辑、删除等等)、右上角消息提示数量 mutations 对应 state 的 mutations 操作 全局/** * mainjs中 */ // 定义全局指令 app.directive('has', { beforeMount: (el, binding) => { // console.log(el, binding); // 获取按钮权限 let actionList = storage.getItem('actionList') let value = binding.value; // includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。 // 盘点列表中是否有对应按钮权限标识 let hasPermission = actionList.includes(value) if (!hasPermission) { // 隐藏按钮 el.style = \"display:none\" setTimeout(() => { // 删除按钮 el.parentNode.removeChild(el) }, 0) } } }) // 全局挂载 请求组件 app.config.globalProperties.$request = request; app.config.globalProperties.$api = api; app.config.globalProperties.$storage = storage; 根据接口 获取数据 渲染数据后台连接数据库/** * 配置文件 */ module.exports = { URL: 'mongodb://127.0.0.1:27017/company-manager' } /** * 数据库连接 */ const mongoose = require('mongoose'); const config = require('./index'); const log4js = require('./../utils/log4j') mongoose.connect(config.URL,{ useNewUrlParser: true, useUnifiedTopology: true }) const db = mongoose.connection; db.on('error',() => { log4js.error('***数据库连接失败***') }) db.on('open',() => { log4js.info('***数据库连接成功***') }) 日志输出封装log4js 工具类封装 CODE 状态码设置 分页 pager 成功 &#x2F; 失败 的debug jwt 解密 token 递归拼接 菜单列表 树 处理时间格式 yyyy-mm-dd hh:mm:ss MongoDB数据库设计 app.js logger 校验token 注册路由 error","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"}],"tags":[{"name":"Vue3实战","slug":"Vue3实战","permalink":"https://blog.yyshino.top/tags/Vue3%E5%AE%9E%E6%88%98/"}]},{"title":"web踩坑","slug":"webHitPit","date":"2022-05-28T03:24:45.000Z","updated":"2022-09-16T10:34:21.558Z","comments":true,"path":"posts/18408.html","link":"","permalink":"https://blog.yyshino.top/posts/18408.html","excerpt":"","text":"时间 + 问题Webpack1. loader 版本过高问题类似提示，可能存在 loader 版本过高问题，下载低版本loader 即可解决。 2.Git1.git push问题2022年4月21日08:52:49 错误 fatal: remote error: You can't push to git://github.com/你的git用户名/Demo.git Use https://github.com/你的git用户名/Demo.git 解决办法一：最后按照百度来的解决方法解决了该问题控制台输入以下两条命令后再次尝试git push操作 git remote rm origin git remote add origin git@github.com:git用户名/仓库名.git 如果出现以下问题 fatal: The current branch main has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin main 则执行下方命令 git push --set-upstream origin main 出现下方提示证明上游分支设置成功 Branch 'main' set up to track remote branch 'main' from 'origin'. 进行该操作后可以正常git push,git pull操作了 解决办法二： 8-30新增解决方法 进入项目文件夹目录下，找到.git文件夹（如果不显示请打开查看隐藏目录选项） 效果如图 找到config文件，打开后如下图： 如果url为http开头，如：https://github.com/用户名/仓库名，例：https://github.com/kobeyk/SpringBoot-ShpTools.git 则修改为git@github.com:用户名/仓库名,注意，githup.com与用户名中间为英文符号: ————————————————版权声明：本文为CSDN博主「七加一i」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_43961619/article/details/116595085 2.Git快速搜索作用 快速搜索源码中文件的路径 使用方法 在github中找到你要查询的库 选择In this respository 回车 3.React1.React路由2022年3月6日19:01:00 今天做练习react路由出现错误，index.tsx:19 Uncaught Error: A is only ever to be used as the child of element, nev…由于路由版本升级，Route需要在Routes组件内，并且component替换成element，括号中变为标签&lt;Routes&lt;&#x2F;Routes记录一下原文链接：https://blog.csdn.net/m0_50981596/article/details/122811781 &#x3D;&#x3D;以上是路由6版本，由于改动过大，建议先使用5版本&#x3D;&#x3D; 2.解决多级路径刷新页面样式丢失的问题 1.public/index.html 中 引入样式时不写 ./ 写 / （常用） 2.public/index.html 中 引入样式时不写 ./ 写 %PUBLIC_URL% （常用） 3.使用HashRouter Antd-React UI库1.antd自定义主题报错2022年3月26日16:45:13 ERROR in ./src/styles/wieldy.less (./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[9].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[9].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[9].use[3]!./node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[9].use[4]!./src/styles/wieldy.less) Module build failed (from ./node_modules/postcss-loader/dist/cjs.js): ValidationError: Invalid options object. PostCSS Loader has been initialized using an options object that does not match the API schema. - options has an unknown property 'plugins'. These properties are valid: object { postcssOptions?, execute?, sourceMap?, implementation? } at validate (C:\\Workspace\\harv-Harvest-frontend\\node_modules\\schema-utils\\dist\\validate.js:105:11) at Object.getOptions (C:\\Workspace\\harv-Harvest-frontend\\node_modules\\webpack\\lib\\NormalModule.js:580:19) at Object.loader (C:\\Workspace\\harv-Harvest-frontend\\node_modules\\postcss-loader\\dist\\index.js:40:24) 解决方案 也有这个问题。 似乎因为 less-loader 6 customize-cra “addLessLoader” 被破坏了。 这个PR修复了它，但从未合并。同一个人创建了这个包： customize-cra-less-loader 解决这个问题： 安装custom-cra-less-loader包 “config-overrides.js”应该是这样的： const { override } = require(\"customize-cra\"); const addLessLoader = require(\"customize-cra-less-loader\"); module.exports = override( addLessLoader({ lessLoaderOptions: { lessOptions: { javascriptEnabled: true, modifyVars: { '@primary-color': '#038fde', } } } }) ); 转自https://stackoverflow.com/questions/71035578/postcss-loader-has-been-initialized-using-an-options-object-that-does-not-match 2.antd自定义主题修改失效2022年3月26日16:45:13 less-loader版本低，版本参考 \"less\": \"3.12.2\", \"less-loader\": \"^10.2.0\", 3.Vue1.Vue Router 4版本 不适应3版本2022年4月19日11:13:48 报错 Uncaught TypeError: Object(...) is not a function at eval (webpack-internal:///./node_modules/vue-router/dist/vue-router.esm-bundler.js:2145:97) at Module../node_modules/vue-router/dist/vue-router.esm-bundler.js (chunk-vendors.js:1609:1) at __webpack_require__ (app.js:849:30) at fn (app.js:151:20) at eval (webpack-internal:///./src/router/index.js:3:68) at Module../src/router/index.js (app.js:1129:1) at __webpack_require__ (app.js:849:30) at fn (app.js:151:20) at eval (webpack-internal:///./src/main.js:12:65) at Module../src/main.js (app.js:1117:1) 解决 # 依次执行 yarn remove vue-router yarn add vue-router@3 --save # 即可解决 2.Vuecli@3中适用的less 以及less-loader \"less\": \"^3.13.0\", \"less-loader\": \"^7.1.0\", 版本过高报错 cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/less-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp;:1 Uncaught Error: Module build failed (from ./node_modules/less-loader/dist/cjs.js): TypeError: this.getOptions is not a function at Object.lessLoader (D:\\vscode\\vscode cache02\\19-project\\Vue\\shop-client\\node_modules\\less-loader\\dist\\index.js:19:24) at eval (webpack-internal:///./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/less-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp;:1:7) at Object../node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/less-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp; (http://localhost:8081/js/app.js:1116:1) at __webpack_require__ (http://localhost:8081/js/app.js:849:30) at fn (http://localhost:8081/js/app.js:151:20) at eval (webpack-internal:///./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/less-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp;:4:15) at Object../node_modules/vue-style-loader/index.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/less-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp; (http://localhost:8081/js/app.js:1138:1) at __webpack_require__ (http://localhost:8081/js/app.js:849:30) at fn (http://localhost:8081/js/app.js:151:20) at eval (webpack-internal:///./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp;:2:504) at Module../src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp; (http://localhost:8081/js/app.js:1232:1) 3.解决路由重复跳转的错误2022年4月21日14:36:44 报错信息 Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation to current location: \"/search\". 解决方案 在 route.js 文件下添加如下代码 import Router from 'vue-router' // 缓存原本的push方法 const originalPush = Router.prototype.push // 指定新的push方法 Router.prototype.push = function push(location, onResolve, onReject) { // 如果指定了成功或失败的回调 if (onResolve || onReject) // 直接调用原本的push方法 // originalPush(this, location, onResolve, onReject) //this不是router而是undefined return originalPush.call(this, location, onResolve, onReject) // 没有指定成功或失败的回调，必须用catch处理 return originalPush.call(this, location).catch((err) => { // 如果是重复盗汗产生的错误，不再向外传递错误 if (Router.isNavigationFailure(err)) { // resolve err return err // 产生的成功的promise ， 成功promise的value是err } // 如果是其他原因盗汗的错误，将错误向下传递 // rethrow error return Promise.reject(err) }) } Vue 3.1.0版本后 https://github.com/vuejs/vue-router/releases?after=v3.3.1&amp;page=3 https://github.com/vuejs/vue-router/issues/2881 4.npm install –save vue&#x2F;types&#x2F;umd2022-5-9 18:12:46 报错信息 运行后 解决某个文件中引入了 import { xxx } from 'vue/types/umd' 删除即可 5.vuex模块化 modules报错 TypeError: Cannot read property 'cartList' of undefined 解决在 // 在modules中注册 modules:{ home, cart } Vue 运行报错vue项目运行报错：Module build failed (from ./node_modules/babel-loader/lib/index.js): 解决 npm install @babel/core @babel/preset-env Vue3 router报错 Cannot use 'in' operator to search for 'path' in undefined 解决 // 在路由文件里用错了createWebHashHistory()方法，将它用成了变量，只需要将它写成方法即可解决问题。 history:createWebHashHistory => history:createWebHashHistory() Vue3 setup 获取全局对象2022年7月11日00:20:49 import { getCurrentInstance} from \"vue\"; export default { name: \"approve\", setup(){ // Vue3中我们打印 getCurrentInstance 详细见下图 console.log(getCurrentInstance()); // 获取全局对象 const { $api, $message, $store } = getCurrentInstance().appContext.config.globalProperties; } } 总结 app.config.globalProperties.变量名 组件 setup 获取变量 getCurrentInstance().appContext.config.globalProperties.变量名 top await参考博客 https://bobbyhadz.com/blog/javascript-unexpected-reserved-word-await#:~:text=The%20%22unexpected%20reserved%20word%20await,directly%20enclosing%20function%20as%20async%20. https://blog.csdn.net/xgangzai/article/details/114314178 Nodenode服务器 启动 端口占用报错 Error: listen EACCES: permission denied 0.0.0.0:80 at Server.setupListenHandle [as _listen2] (net.js:1314:21) at listenInCluster (net.js:1379:12) at Server.listen (net.js:1465:7) at Application.listen (F:\\Program\\web\\web-app\\elm\\server\\node_modules\\koa\\lib\\application.js:82:19) at Object.&lt;anonymous> (F:\\Program\\web\\web-app\\elm\\server\\index.js:32:5) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10) at Module.load (internal/modules/cjs/loader.js:950:32) at Function.Module._load (internal/modules/cjs/loader.js:790:12) at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12) 6:12) Emitted 'error' event on Server instance at: at emitErrorNT (net.js:1358:8) at processTicksAndRejections (internal/process/task_queues.js:82:21) { code: 'EACCES', errno: -4092, syscall: 'listen', address: '0.0.0.0', port: 80 } 解决 更改端口 app.listen(); // 端口号 Koa1 Koa2报错 AssertionError: app.use() requires a generator function 解决 // 版本不兼容问题 koa-router7.x 不支持koa1 koa-router4.x 不能使用koa2 下载低版本的koa-router 或者更新 koa1 => koa2 搭建接口时报错 \"error\":\"Converting circular structure to JSON\\n --> starting at object with constructor 'NativeTopology'\\n | property 's' -> object with constructor 'Object'\\n | property 'sessionPool' -> object with constructor 'ServerSessionPool'\\n --- property 'topology' closes the circle\" 解决 未添加 async 或者 await DataBaseMongodb 服务启动失败报错 服务异常退出 错误代码1067 解决 删除journal文件 清除mongod.lock和storage.bson 重新启动服务 上面的无法实现 ,可以尝试下面的 删除服务 sc delete mongodb 删除journal文件 清除mongod.lock和storage.bson MongoDB服务删除并重新安装， 再尝试就发现已经可以正常启动了。 最佳解决方案 利用安装包进行修复 打开对应版本的安装包 选中Repair进行修复 解决问题 目前未发现它有什么弊端，数据保留完整。 小程序uniapp未配置 appidVM22 WAService.js:9 TypeError: Cannot read property 'forceUpdate' of undefined 解决 解决 Cannot read property 'forceUpdate' of undefined 的错误 这个错误的原因非常简单，是因为我们没有为项目配置 appID 的原因，所以只需要完成 APPID 配置即可。 语法错误: Unexpected token, expected “,” (1:543)10:47:43.127 Module build failed (from ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js): 10:47:43.129 语法错误: Unexpected token, expected \",\" (1:543) 10:47:43.130 at pages\\index\\index.vue:1 错误原因 :class=&quot;active:navIndex === 0&quot; 解决 :class=&quot;&#123;active:navIndex === 0&#125;&quot; JAVAadmin 后台管理项目 | 本地运行 git clone githubaddress 数据库运行 .sql 文件 idea 以maven 导入项目 前端项目 yarn | npm install 运行 前端 yarn serve | npm run start 后端","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.yyshino.top/categories/%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://blog.yyshino.top/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"https://blog.yyshino.top/tags/vue/"},{"name":"react","slug":"react","permalink":"https://blog.yyshino.top/tags/react/"}]},{"title":"webpack","slug":"webpack","date":"2022-05-15T04:21:18.000Z","updated":"2022-08-26T09:44:07.212Z","comments":true,"path":"posts/15317.html","link":"","permalink":"https://blog.yyshino.top/posts/15317.html","excerpt":"","text":"webpack简介 webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。————webpack文档 简单的配置文件 /* 1. 该文件是webpack的配置文件，所有的webpack的任务、用到的loader、plugins都要配置在这里 2. 该文件要符合CJS模块化规范 */ // 引入Node中一个内置的path模块，专门用于解决路劲问题 const {resolve} = require('path'); // 引入html-webpack-plugin ，用于加工html文件 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 引入 // const Webpack = require('webpack'); // const WebpackDevServer = require('webpack-dev-server'); //css 相关loader配置 const baseCssLoader = ['style-loader','css-loader'] // 使用CJS的模块化规范，暴露一个对象，该对象就是webpack的详细配置对象（规则） module.exports = { mode: 'development', //工作模式 entry: './src/js/app.js', //入口 output: { //出口（输出） path: resolve(__dirname, 'build'), //输出文件的路径 filename: 'js/app.js', //输出文件名字 }, // module.rules中配置的一个一个的loader module: { rules: [ // 配置解析css { test:/\\.css$/, use:[...baseCssLoader] }, // 配置解析less { test:/\\.less$/, use:[ ...baseCssLoader,// creates style nodes from JS strings and translates CSS into CommonJS 'less-loader' // compiles Less to CSS ] }, // 配置解析样式中的图片 { test: /\\.(png|jpg|gif|bmp)$/, use: [{ loader:'url-loader', options:{ outputPath:'imgs', //配置图片加工后，，存放的位置 // publicPath:'/build/imgs' //配置图片引入时前缀的路径 name:'[hash:5].[ext]', //配置生成图片的名字+后缀 limit:8 * 1024 //图片大小，小于8kb时，将图片转为base64编码 } } ], }, // 配置解析html中的图片 { test:/\\.(html)$/, use:['html-loader'] }, // 配置解析字体文件 { exclude: /\\.(html|less|css|js|json|png|jpg|bmp|gif)$/, use: [{ loader:'file-loader', options:{ outputPath:'media', //配置图片加工后，，存放的位置 // publicPath:'/build/imgs' //配置图片引入时前缀的路径 name:'[hash:5].[ext]', //配置生成图片的名字+后缀 } } ], }, ], }, // plugins中专门用于配置插件，插件必须经过实例化这一环节 plugins:[ new HtmlWebpackPlugin({ template:'./src/index.html' //模板的位置 }) ], // 配置devServer devServer:{ // static:'./build', port:5500, //开启服务器的端口号 open:true, //自动打开浏览器 hot:true //模块热更新(热膜替换) } };","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://blog.yyshino.top/tags/webpack/"}]},{"title":"AJAX_AXIOS","slug":"AJAX-AXIOS","date":"2022-05-14T12:00:35.000Z","updated":"2022-08-26T09:38:14.471Z","comments":true,"path":"posts/20614.html","link":"","permalink":"https://blog.yyshino.top/posts/20614.html","excerpt":"","text":"Ajax简介 Asynchronous JavaScript + XML（异步JavaScript和XML）, 其本身不是一种新技术，而是一个在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML 或 XHTML, CSS, JavaScript, DOM, XML, XSLT, 以及最重要的 XMLHttpRequest。当使用结合了这些技术的AJAX模型以后， 网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。这使得程序能够更快地回应用户的操作。尽管X在Ajax中代表XML, 但由于JSON的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。JSON和XML都被用于在Ajax模型中打包信息。————MDN文档 实现界面无刷新获取数据 利用Ajax发送请求get请求 // 发送 ajax请求 //1.创建Xhr实例对象 const xhr = new XMLHttpRequest(); // 绑定监听 xhr.onreadystatechange = () => { // 函数体 if (xhr.readyState == 4) { if (xhr.status >= 200 &amp;&amp; xhr.status &lt;= 300) { console.log(xhr.response); content.innerHTML = `&lt;h3>${xhr.response}&lt;/h3>` } } } // 2.指定发送请求的: method、url、参数 /* 1.形如：key=value&amp;key=value 就是query参数是surlencoded编码 2.形如：/xx/xxx/老刘/18 就是params参数 */ // xhr.open('GET', 'http:///127.0.0.1:8080/test_get?name=老刘&amp;age=18'); // 携带query参数 xhr.open('GET', 'http:///127.0.0.1:8080/test_get2/老刘/18'); //携带 // 3.发送请求 xhr.send(); post请求 // 发送 ajax请求 //1.创建Xhr实例对象 const xhr = new XMLHttpRequest(); // 绑定监听 xhr.onreadystatechange = () => { // 函数体 if (xhr.readyState == 4) { if (xhr.status >= 200 &amp;&amp; xhr.status &lt;= 300) { console.log(xhr.response); content.innerHTML = `&lt;h3>${xhr.response}&lt;/h3>` } } } // 2.指定发送请求的: method、url、参数 /* 1.形如：key=value&amp;key=value 就是query参数是surlencoded编码 2.形如：/xx/xxx/老刘/18 就是params参数 */ // xhr.open('GET', 'http:///127.0.0.1:8080/test_get?name=老刘&amp;age=18'); //携带query参数 xhr.open('POST', 'http:///127.0.0.1:8080/test_post'); //携带 //追加响应头用于标识携带参数的编码形式---urlencoded // xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded') //追加响应头用于标识携带参数的编码形式---json xhr.setRequestHeader('Content-type','application/json') // 3.发送请求 const person = {name:'老刘',age:18} // xhr.send('name=老刘&amp;age=18'); //携带urlencoded编码形式的请求体参数 //send中的参数 为请求体参数 //send中 参数的 编码格式为 urlencoded xhr.send(JSON.stringify(person)) //携带json编码形式的请求参数 Axios简介 Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。特性 从浏览器创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF————Axios官网 三种参数 params 参数是路径的一部分，并且这个参数只能在url路径当中出现 query 查询参数 这个参数可以出现在url当中也可以 出现在配置项当中配置url当中是 ? 后面的 key &#x3D; value &amp;key &#x3D;value在配置项当中 配置项的名称叫做params body 请求体参数 通常用在post和put当中，只能在配置对象当中配置; data这个配置项就是你的body请求体参数,这个数据必须是一个对象 注意： 携带query参数时，编写的配置项叫做params 携带params参数时，就需要自己手动拼在url中利用Axios发送请求 get请求const axios = require('axios'); // 向给定ID的用户发起请求 axios.get('/user?ID=12345') .then(function (response) { // 处理成功情况 console.log(response); }) .catch(function (error) { // 处理错误情况 console.log(error); }) .then(function () { // 总是会执行 }); // 上述请求也可以按以下方式完成（可选） axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }) .then(function () { // 总是会执行 }); // 支持async/await用法 async function getUser() { try { const response = await axios.get('/user?ID=12345'); console.log(response); } catch (error) { console.error(error); } } post请求axios.post('/user', { firstName: 'Fred', lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 发起多个并发请求 function getUserAccount() { return axios.get('/user/12345'); } function getUserPermissions() { return axios.get('/user/12345/permissions'); } Promise.all([getUserAccount(), getUserPermissions()]) .then(function (results) { const acct = results[0]; const perm = results[1]; }); 拦截器请求拦截器 axios.interceptors.request.use(): 添加请求拦截器 1.是什么？ 在真正发请求前执行的一个回调函数 2.作用： 对所有的请求做统一的处理：追加请求头、追加参数、界面loading提示等等 响应拦截器 axios.interceptors.response.use(): 添加响应拦截器 1.是什么？ 得到响应之后执行的一组回调函数 2.作用： ​- 若请求成功，对成功的数据进行处理 ​- 若请求失败，对失败进行统一的操作 async和await简介 async awiat 是使用同步代码实现异步效果 返回值 async 函数返回的是promise async 函数返回值不看 return 必然返回promise async 函数返回的promise是成功还是失败 看return return的结果代表promise是成功还是失败 1、如果return是一个非promise的值 代表async函数返回的promise是成功 - 成功的结果是return的结果 2、如果返回的是成功的promise 代表async函数返回的promise函数返- mise也是成功的（他们不是一个promise） 成功的结果是return的promise的成功结果 3、如果返回的是失败的promise 代表async函数返回的promise是失败的 失败的原因是return的promise失败的原因 4、如果throw出错误，代表async函数返回的promise是失败的 失败的原因是抛出的错误的原因 解决跨域1、配置代理服务器 devServer:{ //只用与开发环境 proxy:{ 'api':{ //支队请求路由以/api开头的其你去进行代理转发 target:'http://gmall-h5-api.atguigu.cn', //转发的目标url changeOrigin:true, //支持跨域 // pathRewrite:{'^/api':''} // 后台接口都有/api } } } 2、jsonp解决跨域跨域1、是什么​ 浏览器上的同源策略 特点：​ 1、跨域只存在于浏览器​ 2、不在浏览器发请求是不会存在跨域问题的​ 3、http请求分为两大类： 普通http请求和ajax请求（跨域是出现在ajax请求） 1、普通请求和ajax请求区别​ 普通请求 一般只有get（a标签和地址栏输入回车）和 post(form表单) 页面会刷新 不会跨域​ ajax请求 一般 get post delete put 一般都是异步发送的 页面不刷新 局部更新 2、在什么地方会出现跨域 浏览器给服务器发ajax请求会跨域 因为跨域（同源策略）只存在于浏览器 服务器给服务器发ajax请求不会 3、什么条件会跨域 同源（协议 ip 端口一致）不跨域 不同源就跨域（三个中间有一个不一样就跨域） http://localhost:8080/ ——- 》 github 4、解决跨域：前端可以解决、后端解决。一般后端解决比前端解决容易 // 1.创建script节点 const scriptNode = document.createElement('script') // 2.给节点指定src属性（请求地址） scriptNode.src = 'http://localhost:8080/test_jsonp?callback=peiqi'; // 3.将节点放入界面 document.body.appendChild(scriptNode) window.peiqi = (a) =>{ console.log(a); } //5.移除已经使用过的script节点 document.body.removeChild(scriptNode) //总结：Jsonp解决跨域，本质上是避开了 xhr 不受同源策略的限制 利用 //script 标签发起请求，拿到数据 3、cors解决跨域（后端） node.js //在后端服务器 添加特殊响应头 response.setHeader('Access-Control-Allow-Origin','*') response.setHeader('Access-Control-Expose-Origin','*') response.setHeader('Access-Control-Allow-Methods','*') //引入cors包 use(cors()) //可以直接为所有请求添加特殊响应头","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ajax/axios","slug":"ajax-axios","permalink":"https://blog.yyshino.top/tags/ajax-axios/"}]},{"title":"Javascript","slug":"Javascript","date":"2022-05-13T01:10:55.000Z","updated":"2022-08-14T14:36:47.180Z","comments":true,"path":"posts/9809.html","link":"","permalink":"https://blog.yyshino.top/posts/9809.html","excerpt":"","text":"JavaScript遍历相关 - for 最基本的循环 用来专门遍历数组的 可以使用break和continue - for in 专门用来遍历对象的属性的，这个属性能遍历到还是遍历不到要看这个属性是不是 ​ // for in 效率最低，因为除了遍历自身以外还要遍历原型 - for of - ​ // 专门遍历可迭代的数据 ... (能用可迭代，就用三点) - ​ // 数组有迭代器 - ​ // 对象没有 - forEach 是一个数组的方法，效率极高 但是不可以使用break和continue 数组方法everyparseInt() 描述 parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数， radix 是2-36之间的整数，表示被解析字符串的基数。 语法参数 parseInt(string, radix); 参数 string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。 radix 可选 从 2 到 36，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！文章后面的描述解释了当参数 radix 不传时该函数的具体行为。 返回值 从给定的字符串中解析出的一个整数。 或者 NaN，当 radix 小于 2 或大于 36 ，或 第一个非空格字符不能转换为数字。 parseInt('123', 5) // 将'123'看作5进制数，返回十进制数38 => 1*5^2 + 2*5^1 + 3*5^0 = 38 includes() 描述 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`。 语法以及参数 arr.includes(valueToFind[, fromIndex]) valueToFind 需要查找的元素值。 备注：使用 includes()比较字符串和字符时是区分大小写的。 fromIndex 可选 从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。 返回值 返回一个布尔值 Boolean 。 ]如果在数组中（或 fromIndex 指定的范围中）找到了 valueToFind，则返回 true，否则返回 false。 0 的值将全部视为相等，与符号无关（即 -0 与 0 和 +0 相等）， 但 false 不被认为与 0 相等。 备注： 技术上来讲，includes() 使用 零值相等 算法来确定是否找到给定的元素。 示例 [1, 2, 3].includes(2); // true [1, 2, 3].includes(4); // false [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true [1, 2, NaN].includes(NaN); // true 注意 fromIndex 大于等于数组长度 如果 fromIndex 大于等于数组的长度，则将直接返回 false，且不搜索该数组。 计算出的索引小于 0 如果 fromIndex 为负值，计算出的索引将作为开始搜索searchElement的位置。如果计算出的索引小于 0，则整个数组都会被搜索。 作为通用方法的 includes() includes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。下面的例子展示了 在函数的 arguments 对象上调用的 includes() 方法。 find() 描述 find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 语法以及参数 arr.find(callback[, thisArg]) 参数 callback 在数组每一项上执行的函数，接收 3 个参数： element 当前遍历到的元素。 index可选 当前遍历到的索引。 array可选 数组本身。 thisArg可选 执行回调时用作this 的对象。 返回值 数组中第一个满足所提供测试函数的元素的值，否则返回 undefined。 MDN sort() 描述 sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的 语法及参数 arr.sort([compareFunction]) 参数 compareFunction 可选 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 firstEl 第一个用于比较的元素。 secondEl 第二个用于比较的元素。 返回值 排序后的数组。请注意，数组已原地排序，并且不进行复制。 注意 也会影响原数组，默认会按照Unicode编码进行排序 带有compareFunction 参数时, 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 、、、通俗理解 比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，即 a - b 小于零，则返回一个小于零的值，数组将按照升序排列。 若 a 等于 b，则返回 0。 若 a 大于 b, 即 a - b 大于零，则返回一个大于零的值，数组将按照降序排列。 MDN 简单使用 filter() 描述 filter() 方法创建一个新的数组，新数组中的元素是通过==检查指定数组中符合条件==的所有元素。 语法以及参数 array.filter(function(currentValue,index,arr), thisValue) function(currentValue, index,arr) 必须。函数，数组中的每个元素都会执行这个函数 函数参数: currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 thisValue 可选。对象作为该执行回调时使用，传递给函数，用作 \"this\" 的值。 如果省略了 thisValue ，\"this\" 的值为 \"undefined\" 返回值 一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。 总结 //用作过滤器 array.filter((currentValue,index,arr) => { return (过滤条件) }, thisValue) 注意： filter() 不会对空数组进行检测。 注意： filter() 不会改变原始数组。 reduce 语法: - arr.reduce((preValue, current, index, arr)=>f),initialValue) // 箭头函数 reduce((previousValue, currentValue) => { /* ... */ } ) reduce((previousValue, currentValue, currentIndex) => { /* ... */ } ) reduce((previousValue, currentValue, currentIndex, array) => { /* ... */ } ) reduce((previousValue, currentValue, currentIndex, array) => { /* ... */ }, initialValue) // 回调函数 reduce(callbackFn) reduce(callbackFn, initialValue) // 内联回调函数 reduce(function(previousValue, currentValue) { /* ... */ }) reduce(function(previousValue, currentValue, currentIndex) { /* ... */ }) reduce(function(previousValue, currentValue, currentIndex, array) { /* ... */ }) reduce(function(previousValue, currentValue, currentIndex, array) { /* ... */ }, initialValue) arr:当前操作的数组 ==**preValue**:**第一次**执行回调时为给定的**初始值initialValue**,**以后是上一次执行回调时的返回值**。== ​ ==备注:若**没有传入initialValue**,则第一次的preValue值是数组中**第一个元素的值**。== **current 表示当前正在处理的元素;** index 表示当前正在处理的数组元素的索引,若传入了initialValue值,则为0,否则为1; array 当前操作的数组(就是arr) **initialValue 表示初始值。一般做数学时设置为0,若为筛选最值可以不传。 用于数据分析 let arr = [1,2,3,4,5,6,7,8,9,10,9] // 数组求和 /* const x = arr.reduce((preValue,current)=>{ console.log(preValue,current); return preValue+current }) console.log(x); */ // 数组中偶数的和----(条件求和) // const x = arr.reduce((preValue,current)=>preValue+(current % 2 === 0 ? current:0),0) // console.log(x); //数组中偶数有几个---(条件统计) // const x = arr.reduce((preValue,current)=>preValue+(current%2===0 ? 1:0),0) // console.log(x); // 数组中所有偶数的积 // const x = arr.reduce((preValue,current)=>preValue*(current%2===0 ? current:1),1) // console.log(x); // 数组中最小值----(筛选最值) /* const x = arr.reduce((preValue,current)=> { console.log(preValue,current); return Math.max(preValue,current) },1) console.log(x); map 描述 map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。 语法 var new_array = arr.map(function callback(currentValue[, index[, array]]) { //为new_array返回元素 }[, thisArg]) 参数 `callback` 生成新数组元素的函数，使用三个参数： `currentValue` `callback` 数组中正在处理的当前元素。 `index`可选 `callback` 数组中正在处理的当前元素的索引。 `array`可选 `map` 方法调用的数组。 `thisArg`可选 执行 `callback` 函数时值被用作`this`。 返回值 一个由原数组每个元素执行回调函数的结果组成的新数组。 例 简单用法 const array1 = [1, 4, 9, 16]; // pass a function to map const map1 = array1.map(x => x * 2); console.log(map1); // expected output: Array [2, 8, 18, 32] 注意： map() 不会对空数组进行检测。 map() 不会改变原始数组。 官方文档 push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度 可以将要添加的元素作为方法的参数传递， 这样这些元素将会自动添加到数组的末尾 该方法会将数组新的长度作为返回值返回 pop() 该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 向前边插入元素以后，其他的元素索引会依次调整 shift() 可以删除数组的第一个元素，并将被删除的元素作为返回值返回 slice()可以用来从数组提取指定元素 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回 参数：1.截取开始的位置的索引, 包含 开始索引2.截取结束的位置的索引, 不包含 结束索引 第二个参数可以省略不写,此时会截取从开始索引往后的所有元素 索引可以传递一个负值，如果传递一个负值，则从后往前计算-1 倒数第一个-2 倒数第二个 splice() 描述（增删改一体化） 可以用于删除数组中的指定元素 - 参数： 第一个，表示开始位置的索引 第二个，表示删除的数量 第三个 及以后。。 可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边 注意 使用splice()会影响到原数组，会将指定元素从原数组中删除，被删除的元素作为返回值返回 ​ concat() 可以连接两个或多个数组，并将新的数组返回 该方法不会对原数组产生影响 join()该方法可以将数组转换为一个字符串 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回 在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符 如果不指定连接符，则默认使用,作为连接符 reverse() 该方法用来反转数组（前边的去后边，后边的去前边） - 该方法会直接修改原数组 字符串方法indexOf() 描述 indexOf()方法返回调用它的 String 对象中**第一次出现的指定值的索引**，从 **fromIndex** 处进行搜索。如果未找到该值，则返回 -1。 语法 str.indexOf(searchValue [, fromIndex]) 参数 searchValue 要被查找的字符串值。如果没有提供确切地提供字符串，searchValue 会被强制设置为 \"undefined\"， 然后在当前字符串中查找这个值。举个例子：'undefined'.indexOf() 将会返回0，因为 undefined 在位置0处被找到，但是 'undefine'.indexOf() 将会返回 -1 ，因为字符串 'undefined' 未被找到。 fromIndex 可选 数字表示开始查找的位置。可以是任意整数，默认值为 0。如果 fromIndex 的值小于 0，或者大于 str.length ，那么查找分别从 0 和str.length 开始。（译者注： fromIndex 的值小于 0，等同于为空情况； fromIndex 的值大于或等于 str.length ，那么结果会直接返回 -1 。）举个例子，'hello world'.indexOf('o', -5) 返回 4 ，因为它是从位置0处开始查找，然后 o 在位置4处被找到。另一方面，'hello world'.indexOf('o', 11) （或 fromIndex 填入任何大于11的值）将会返回 -1 ，因为开始查找的位置11处，已经是这个字符串的结尾了。 返回值 查找的字符串 searchValue 的第一次出现的索引，如果没有找到，则返回 -1。 若被查找的字符串 searchValue 是一个空字符串，将会产生“奇怪”的结果。如果 fromIndex 值为空，或者 fromIndex 值小于被查找的字符串的长度，返回值和以下的 fromIndex 值一样： 'hello world'.indexOf('') // 返回 0 'hello world'.indexOf('', 0) // 返回 0 'hello world'.indexOf('', 3) // 返回 3 'hello world'.indexOf('', 8) // 返回 8 另外，如果 fromIndex 值大于等于字符串的长度，将会直接返回字符串的长度（str.length）： 'hello world'.indexOf('', 11) // 返回 11 'hello world'.indexOf('', 13) // 返回 11 'hello world'.indexOf('', 22) // 返回 11 从前面一个例子可以看出，被查找的值是空值时，Javascript将直接返回指定的索引值。从后面一个例子可以看出，被查找的值是空值时，Javascript将直接返回字符串的长度。 注意 字符串中的字符被从左向右索引。第一个字符的索引（index）是 0，变量名为 stringName 的字符串的最后一个字符的索引是 stringName.length - 1 indexOf 方法是区分大小写的 注意 0 并不会被当成 true ，-1 不会被当成 false 。所以当检测某个字符串是否存在于另一个字符串中时，可使用下面的方法： 'Blue Whale'.indexOf('Blue') !== -1 // true 'Blue Whale'.indexOf('Bloe') !== -1 // false ~('Blue Whale'.indexOf('Bloe')) // 0, 这是一种错误用法 MDN文档 trim 描述 `trim()`方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR等）。 `trim()` 方法返回一个从两头去掉空白字符的字符串，并不影响原字符串本身。 语法 str.trim() 返回值 一个代表调用字符串两端去掉空白的新字符串。 兼容久环境、 if (!String.prototype.trim) { String.prototype.trim = function () { return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''); }; } DOM操作//常用DOM操作 getElementById() //返回带有指定ID 的元素。 getElementsByTagName() //返回包含带有指定标签名称的所有元素的节 // 点列表(集合/节点数组)。 getElementsByClassName() //返回包含带有指定类名的所有元素的节 // 点列表。 getElementsByName('a') //通过name属性获取一组元素节点对象 document.querySelector('#a') //通过CSS选择器来获取一个元素节点对象 document.querySelectorAll('span') //通过CSS选择器来获取一组元素节点对象 appendChild() //把新的子节点添加到指定节点。 removeChild() //删除子节点。 replaceChild() //替换子节点。 insertBefore() //在指定的子节点前面插入新的子节点。 createAttribute() //创建属性节点。 createElement() //创建元素节点。 createTextNode() //创建文本节点。 getAttribute() //返回指定的属性值。 setAttribute() //把指定属性设置或修改为指定的值。 当前节点.paretNode //表示当前节点的父节点 当前节点.previousSibling //表示当前节点的前一个兄弟节点 当前节点.nextSibling //表示当前节点的后一个兄弟节点 父节点.firstchild //可以获取第一个子节点(包括空白文本节点) 父节点.firstElementchild //可以获取第一个子元素(不包括空白文本节点) 父节点.childNodes //表示当前节点的所有子节点 BOM操作 浏览器对象模型 BOM可以使我们通过JS来操作浏览器 在BOM中为我们提供了一组对象，用来完成对浏览器的操作 BOM对象 Window 代表的是整个浏览器的窗口，同时window也是网页中的全局对象 Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 Location- 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面 History 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页而且该操作只在当次访问时有效 Screen 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 Screen获取元素的大小和位置PC client系列 页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; offset系列 网页可见区域宽： document.body.offsetWidth (包括边线的宽); 网页可见区域高： document.body.offsetHeight (包括边线的宽); scroll系列 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 移动端 网页正文部分上： window.screenTop; 网页正文部分左： window.screenLeft; 屏幕分辨率的高： window.screen.height; 屏幕分辨率的宽： window.screen.width; 屏幕可用工作区高度： window.screen.availHeight; React打基础js &#x3D;&gt; jsx map - 参数 - `callback` - 生成新数组元素的函数，使用三个参数： - `currentValue` - `callback` 数组中正在处理的当前元素。 - `index`可选 - `callback` 数组中正在处理的当前元素的索引。 - `array`可选 - `map` 方法调用的数组。 - `thisArg`可选 - 执行 `callback` 函数时值被用作`this`。 Vue打基础js &#x3D;&gt; vue object.keys(obj) //返回的是参数对象的属性组成的数组，可以用数组的方法forEach去遍历对象 //例如 Object.keys(obj).forEach(item => console.log(item,obj[item])) // Object.defineProperty // 这个方法在为对象添加或者修改 属性为响应式属性 /* 语法 Object.defineProperty(obj, prop, descriptor) 参数 obj 要定义属性的对象。 prop 要定义或修改的属性的名称或 Symbol 。 descriptor 要定义或修改的属性描述符。 返回值 被传递给函数的对象。 */","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.yyshino.top/tags/js/"}]}],"categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://blog.yyshino.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"},{"name":"踩坑","slug":"踩坑","permalink":"https://blog.yyshino.top/categories/%E8%B8%A9%E5%9D%91/"},{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.yyshino.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"Vue3实战","slug":"Vue3实战","permalink":"https://blog.yyshino.top/tags/Vue3%E5%AE%9E%E6%88%98/"},{"name":"webpack","slug":"webpack","permalink":"https://blog.yyshino.top/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"https://blog.yyshino.top/tags/vue/"},{"name":"react","slug":"react","permalink":"https://blog.yyshino.top/tags/react/"},{"name":"ajax/axios","slug":"ajax-axios","permalink":"https://blog.yyshino.top/tags/ajax-axios/"},{"name":"js","slug":"js","permalink":"https://blog.yyshino.top/tags/js/"}]}