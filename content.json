{"meta":{"title":"yyshino的小破屋","subtitle":"welcome to yyshino's blog","description":"向着远方不断前进","author":"yyshino","url":"https://blog.yyshino.top","root":"/"},"pages":[{"title":"","date":"2022-08-14T14:33:27.748Z","updated":"2022-08-14T14:33:27.748Z","comments":true,"path":"404.html","permalink":"https://blog.yyshino.top/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"所有分类","date":"2022-08-14T14:25:45.226Z","updated":"2022-08-14T14:25:45.226Z","comments":true,"path":"categories/index.html","permalink":"https://blog.yyshino.top/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-14T14:24:58.972Z","updated":"2022-08-14T14:24:58.972Z","comments":true,"path":"about/index.html","permalink":"https://blog.yyshino.top/about/index.html","excerpt":"","text":"下面写关于自己的内容"},{"title":"bangumis","date":"2022-05-15T06:07:34.000Z","updated":"2022-05-15T06:07:34.727Z","comments":true,"path":"bangumis/index.html","permalink":"https://blog.yyshino.top/bangumis/index.html","excerpt":"","text":""},{"title":"recommend","date":"2022-09-20T14:36:58.000Z","updated":"2022-09-20T14:36:58.821Z","comments":true,"path":"recommend/index.html","permalink":"https://blog.yyshino.top/recommend/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-08-14T14:28:09.412Z","updated":"2022-08-14T14:28:09.412Z","comments":true,"path":"friends/index.html","permalink":"https://blog.yyshino.top/friends/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-14T14:27:07.841Z","updated":"2022-08-14T14:27:07.841Z","comments":true,"path":"mylist/index.html","permalink":"https://blog.yyshino.top/mylist/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-08-14T14:26:32.580Z","updated":"2022-08-14T14:26:32.580Z","comments":true,"path":"tags/index.html","permalink":"https://blog.yyshino.top/tags/index.html","excerpt":"","text":""},{"title":"contact","date":"2022-05-13T03:52:01.000Z","updated":"2022-05-13T03:53:16.927Z","comments":true,"path":"contact/index.html","permalink":"https://blog.yyshino.top/contact/index.html","excerpt":"","text":""},{"title":"","date":"2022-10-08T08:51:45.690Z","updated":"2022-10-08T08:51:45.690Z","comments":true,"path":"showgame/index.html","permalink":"https://blog.yyshino.top/showgame/index.html","excerpt":"","text":""}],"posts":[{"title":"EJS模板引擎","slug":"模板引擎","date":"2022-09-21T06:43:29.000Z","updated":"2022-09-26T11:20:02.139Z","comments":true,"path":"posts/58109.html","link":"","permalink":"https://blog.yyshino.top/posts/58109.html","excerpt":"","text":"EJS简介高效的嵌入式 JavaScript 模板引擎。 “E” 代表什么？可以表示 “可嵌入（Embedded）”，也可以是“高效（Effective）”、“优雅（Elegant）”或者是“简单（Easy）”。EJS 是一套简单的模板语言，帮你利用普通的 JavaScript 代码生成 HTML 页面。EJS 没有如何组织内容的教条；也没有再造一套迭代和控制流语法；有的只是普通的 JavaScript 代码而已。","categories":[{"name":"模板引擎","slug":"模板引擎","permalink":"https://blog.yyshino.top/categories/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"}],"tags":[{"name":"ejs","slug":"ejs","permalink":"https://blog.yyshino.top/tags/ejs/"}]},{"title":"Hexo个性化配置","slug":"Hexo个性化配置","date":"2022-09-17T10:52:49.000Z","updated":"2022-09-17T10:57:44.099Z","comments":true,"path":"posts/46302.html","link":"","permalink":"https://blog.yyshino.top/posts/46302.html","excerpt":"","text":"为volantis主题添加瀑布流相册参考https://goopher.tk/posts/7.html","categories":[],"tags":[]},{"title":"图床整理","slug":"图床整理","date":"2022-09-16T09:32:15.000Z","updated":"2022-09-16T10:33:31.060Z","comments":true,"path":"posts/7942.html","link":"","permalink":"https://blog.yyshino.top/posts/7942.html","excerpt":"","text":"域名shinoimg.yyshino.top 序列整理","categories":[{"name":"工具","slug":"工具","permalink":"https://blog.yyshino.top/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"图床","slug":"图床","permalink":"https://blog.yyshino.top/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"项目总结","slug":"项目总结","date":"2022-09-15T08:17:46.000Z","updated":"2022-09-16T09:33:58.155Z","comments":true,"path":"posts/21270.html","link":"","permalink":"https://blog.yyshino.top/posts/21270.html","excerpt":"","text":"echarts展示电商数据 （ e-admin.yyshino.top ）2022.8.20 - 2022.9.10 技术栈：Vue3+Element+Webpack+Koa2 通过echarts展示数据，柱状图、折线图、饼图、map图 | 自定义主题、一键切换主题。后台采用WebSocket主动向前台推送数据。可以实现不同浏览器之间的联动。 通用后台管理系统 ( c-admin.yyshino.top )2022.6.25– 2022.7.15 个人开发 技术栈：Vue3+Element Plus+Vite+Koa2+MongoDB 开发为通用型公司管理系统，可扩展性强 实现模块&#x3D;&gt;用户登录、系统首页、用户管理、菜单管 理角色管理、部门管理、休假申请、带我审批。 难点：动态菜单，动态路由利于维护，后端递归拼接 菜单利于前端渲染数据。 网易云音乐小程序 ( music-api.yyshino.top )2022.6.05– 2022.6..20 • 个人开发 • 技术栈：微信小程序 • 采用 NodeJs 的 Koa2 框架搭建服务器，接口为网易 云接口，页面为仿网易云 App，实现了主要的三个页 面，首页、登录页、视频页面，播放音乐交互、以及 音乐推送等功能。 • 项目难点：登录接口使用微信 API wx.getUserInfo 无 法获取获取用户数据，查阅文档后发现需要更换为 wx.getUserProfile 并且使用官方解决方案解决了问 题。 电商平台 PC （https://c-shop.yyshino.top/）2022.4-2022.5 个人开发项目 | 结合网络资源 • 技术栈 Vue 全家桶+Element-UI+Swiper 轮播图。 • 实现了前端部分和上线，后端接口为网路资源。 结合网络 资源开发实现了 axios 二次封装、vue-router 路由守卫 (由于接口只支持 http，我的域名是强制 https 的，会产生 https 访问 http 报错，这里给出 ip 地址)","categories":[{"name":"实战","slug":"实战","permalink":"https://blog.yyshino.top/categories/%E5%AE%9E%E6%88%98/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://blog.yyshino.top/tags/vue/"},{"name":"react","slug":"react","permalink":"https://blog.yyshino.top/tags/react/"}]},{"title":"大前端","slug":"大前端","date":"2022-09-15T07:29:38.000Z","updated":"2022-09-19T08:59:41.740Z","comments":true,"path":"posts/10308.html","link":"","permalink":"https://blog.yyshino.top/posts/10308.html","excerpt":"","text":"概述 需求分析工具原型类:Axure,Ps,墨刀,蓝湖 思维脑图: Xmind, MindNode ( Mac) , MindManager 流程图: Visio ( win ) &#x2F;OmniGraffle ( Mac ) &#x2F; processOnime","categories":[{"name":"大前端","slug":"大前端","permalink":"https://blog.yyshino.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"大前端","slug":"大前端","permalink":"https://blog.yyshino.top/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"}]},{"title":"优质整合","slug":"优质整合","date":"2022-09-13T08:06:24.000Z","updated":"2022-09-13T08:46:24.989Z","comments":true,"path":"posts/1873.html","link":"","permalink":"https://blog.yyshino.top/posts/1873.html","excerpt":"","text":"前端HTML5CSS3JavaScriptECMAScript (ES)Promiseawait&#x2F;asyncVueVuexVue RouterViteReactAngularWebpack小程序原生小程序UniappTaro后端C++JavaC#PHPNode图形学OpenGLShader (Unity3D)WebGLThree.jsecharts","categories":[{"name":"整合","slug":"整合","permalink":"https://blog.yyshino.top/categories/%E6%95%B4%E5%90%88/"}],"tags":[{"name":"整合","slug":"整合","permalink":"https://blog.yyshino.top/tags/%E6%95%B4%E5%90%88/"}]},{"title":"消极","slug":"消极","date":"2022-09-13T02:23:26.000Z","updated":"2022-09-13T08:06:35.563Z","comments":true,"path":"posts/35773.html","link":"","permalink":"https://blog.yyshino.top/posts/35773.html","excerpt":"","text":"释义 主观：主观是人的一种思考方式，与“客观”相反。所谓“主观”就是凭借自己的感情去看待事物，并作结论、决策和行为反应，而不能与其他不同看法的人仔细商讨，称为主观。 客观：客观，一个抽象名词，即在意识之外，不依赖精神而存在的，不依人的意志为转移的，实时存在的，和主观相对立。 中二越是长大,越是 ，却少有愤怒，剩下一具空壳 我到底是为了美好而活，还是被欺骗这世界真有美好。 人生满是遗憾，有的只是适应、习惯、麻木。 人的经历不同，对一件事的看法也不同。快乐的事人们可以感同身受（甚至嫉妒），但痛苦并不能（人们本能的对痛苦逃避、恐惧，只有真正直面痛苦的人才能明白）。人与人之间的悲欢并不相通。 性本善，性本恶，本身也是对一件事的看法，看到的不同，其结论也不同。主观来看，更偏向性本恶。客观来看，事物的两面性。 骚话专业人士变坏才有钱，普通人变坏必被抓 ————半佛 想象基于现实，但未必真正高于现实 —— 部分情况下只是我们了解的太少了。 他们谁赢跟谁，他们也确实跟谁谁赢。 辩论（吵架）意义——无意义——取悦第三方 一下适用爱情爱情 主观性、随机性、盲目性。资产和实力只是一小部分要素、锲合度才是情感中的关键，而冲动才是真正的导火索。 爱情是一场战争，需要野性、进攻性。 战争战争的胜利需要勇敢、侵略性，赌博以及反复试错和冲锋。越是光脚的应该去赌，需要放下一切 结婚看看现在的离婚率，有个毛线的真心，虚伪。很多人的结婚就是刚好合适，他们根本没有真心也没有爱情 渣男渣男群体其实是一种极为纯粹的利益驱动者，做一切事情都只为达成目标，甚至某种程度上他们的操作具有大量所谓成功人士的特质。 所谓成功人士目的明确、简单直接、高效执行、不择手段、道德感低擅长心理研究、习惯从利益角度思考问题、 以下适用结婚为前提的爱情","categories":[{"name":"我","slug":"我","permalink":"https://blog.yyshino.top/categories/%E6%88%91/"}],"tags":[{"name":"日常","slug":"日常","permalink":"https://blog.yyshino.top/tags/%E6%97%A5%E5%B8%B8/"}]},{"title":"TyporaMarkdown入门","slug":"TyporaMarkdown入门","date":"2022-09-13T01:29:47.000Z","updated":"2022-09-13T02:21:37.936Z","comments":true,"path":"posts/9266.html","link":"","permalink":"https://blog.yyshino.top/posts/9266.html","excerpt":"","text":"","categories":[{"name":"Markdown","slug":"Markdown","permalink":"https://blog.yyshino.top/categories/Markdown/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://blog.yyshino.top/tags/Markdown/"}]},{"title":"理论根基","slug":"理论根基","date":"2022-09-07T02:45:10.000Z","updated":"2022-09-09T08:17:50.031Z","comments":true,"path":"posts/3097.html","link":"","permalink":"https://blog.yyshino.top/posts/3097.html","excerpt":"","text":"前言打牢基础，应对变化，以不变应万变 TCP/IP 协议参考https://www.cnblogs.com/mghio/p/14665036.html","categories":[{"name":"根基","slug":"根基","permalink":"https://blog.yyshino.top/categories/%E6%A0%B9%E5%9F%BA/"}],"tags":[{"name":"根基","slug":"根基","permalink":"https://blog.yyshino.top/tags/%E6%A0%B9%E5%9F%BA/"}]},{"title":"Vue3","slug":"Vue3晋级","date":"2022-09-06T02:49:48.000Z","updated":"2022-09-16T10:33:56.792Z","comments":true,"path":"posts/5996.html","link":"","permalink":"https://blog.yyshino.top/posts/5996.html","excerpt":"","text":"API风格区别:https://cn.vuejs.org/guide/introduction.html#single-file-components 选项式组合式 setupObject.defineProperty &#x3D;&gt; Proxy 支持数组和对象的响应式操作 vue3 生命周期 setup()中的生命周期在之前加上 on 新增特性teleportSuspenseVue3 全局变化全局配置Vue.config &#x3D;&#x3D;&#x3D;&gt; app.config config.productionTip被删除 config.ignoredElements 改名为 config.isCustomElement config.keyCodes 被删除 全局注册类APIVue.component &#x3D;&#x3D;&#x3D;&gt; app.component Vue.directive &#x3D;&#x3D;&#x3D;&gt; app.directive 行为扩展类APIVue.mixin &#x3D;&#x3D;&#x3D;&gt; app.mixin Vue.use &#x3D;&#x3D;&#x3D;&gt; app.use","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://blog.yyshino.top/tags/Vue3/"}]},{"title":"部署","slug":"部署","date":"2022-09-04T08:21:19.000Z","updated":"2022-09-16T09:34:53.862Z","comments":true,"path":"posts/21810.html","link":"","permalink":"https://blog.yyshino.top/posts/21810.html","excerpt":"","text":"云服务器宝塔面板连接FinalShell XShell 域名主域名 二级域名 我的域名 yyshino.top e-api echarts展示电商数据后台接口 e-admin.yyshino.top echarts展示电商数据 c-shop.yyshino.top 电商平台前台 music-api.yyshino.top 网易云音乐API c-admin.yyshino.top 通用后台管理系统 manager-server.yyshino.top 通用后台管理系统接口 shinoimg.yyshino.top 七牛云图床 blog.yyshino.top 个人博客 Nginx 代理配置反向代理配置 接口 HTTPS","categories":[{"name":"部署","slug":"部署","permalink":"https://blog.yyshino.top/categories/%E9%83%A8%E7%BD%B2/"}],"tags":[{"name":"网页部署","slug":"网页部署","permalink":"https://blog.yyshino.top/tags/%E7%BD%91%E9%A1%B5%E9%83%A8%E7%BD%B2/"}]},{"title":"WebSocket","slug":"WebSocket","date":"2022-08-31T00:01:28.000Z","updated":"2022-08-31T08:12:24.596Z","comments":true,"path":"posts/26563.html","link":"","permalink":"https://blog.yyshino.top/posts/26563.html","excerpt":"","text":"后端node中使用 安装包 npm i ws -S 创建对象 const WebSocket = require(\"ws\") const wss = new WebSocket.Server({ port: 9998 }) 监听事件 发送数据 前端","categories":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://blog.yyshino.top/categories/WebSocket/"}],"tags":[{"name":"WebSocket","slug":"WebSocket","permalink":"https://blog.yyshino.top/tags/WebSocket/"}]},{"title":"git复习","slug":"git复习","date":"2022-08-28T08:58:53.000Z","updated":"2022-08-28T09:01:11.151Z","comments":true,"path":"posts/10243.html","link":"","permalink":"https://blog.yyshino.top/posts/10243.html","excerpt":"","text":"Git 常用命令小结 git init 仓库初始化 git add -A 将工作区修改添加至『暂存区』 git commit 提交 存档 git branch 查看分支 git branch name 创建 git branch -d name 删除分支 git merge name 分支合并 git checkout name 切换分支 git checkout -b name 创建并切换 git remote 远程仓库别名管理 add 新增别名 remove 移除别名 rename 重命名别名 git push 将本地仓库的『分支』推送到远端仓库 git push -u origin master git push dev master git push dev master:main git pull 拉取指定仓库的指定分支 git pull origin master git clone 克隆仓库 git status 查看仓库状态 忽略文件 冲突解决 注意 移动或删除本地仓库不会影响远程存储库. 含有node_module的文件夹移动时—过慢—压缩后移动 .git不能够嵌套","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"git命令","slug":"git命令","permalink":"https://blog.yyshino.top/tags/git%E5%91%BD%E4%BB%A4/"}]},{"title":"一个月入门计算机基础知识","slug":"计算机科学","date":"2022-08-27T02:41:33.000Z","updated":"2022-09-16T10:33:24.562Z","comments":true,"path":"posts/288.html","link":"","permalink":"https://blog.yyshino.top/posts/288.html","excerpt":"","text":":muscle:高级语言程序设计:muscle:数据结构:point_down:计算机组成原理:point_down:简介解释概念 计算机系统是由计算机硬件与计算机软件构成的。 计算机硬件是计算机的实体部分。 计算机软件是由看不见摸不着的，由人们事先编制的具有各类特殊功能的程序构成，通常分为系统软件、应用软件。 高级语言：不必了解、掌握实际机器的机型，内部具体组成及其指令系统，只要掌握这类语言的语法就可以直接用来编程。 汇编语言：用符号ADD、SUB、MVL、DIV、等分别表示加减乘除不必使用二进制代码来编写程序。 机器语言：用0、1代码来表示的语言，可以直接在机器上执行。 差别与联系：机器语言可以直接在机器上执行，汇编语言必须用汇编语言程序翻译成机器语言程序才可以运行。高级语言则需要先转变为汇编语言再转变为机器语言才能执行。 冯诺依曼计算机 特点 由运算器、存储器、控制器、输入设备、输出设备五大部分构成。 指令和地址以同等地位存放于存储器内，并可按地址寻访。 指令和地址均用二进制表示。 指令由操作码和地址码组成，操作码表示操作的性质，地址码用来表示操作数在存储器中的位置。 主机：CPU与主存构成。 CPU：由运算器和控制器构成。 主存：包括存储体M，各种逻辑部件及控制电路等。 存储单元：由若干个存储原件构成，可存储一串二进制代码。 存储元件：可存储以为二进制代码。 机器字长：CPU一次能处理数据的位数。 指令字长：机器指令中二进制代码的总位数。 CPU：中央处理器。 PC：程序计数器。 IR：指令寄存器。 CU:控制单元。 ALU：算术逻辑单 ACC：累加器。 MAR：存储器地址寄存器。 MDR：存储器数据寄存器。 I&#x2F;O:分为I&#x2F;O设备和I&#x2F;O接口两个部分。 MIPS：百万条指令每秒。 CPI：执行一条指令所需的时钟周期。 FLOPS：浮点运算次数每秒。 总线带宽：总线的数据传输速率及单位时间内，总线上传输数据的位数通常用每秒传输信息的字节数来衡量。 总线复用：一条信号线上分时传送两种信号。 总线的主设备（或主模块）：对总线有控制权。 总线的从设备（或从模块）：只能响应主设备，对总线没有控制权。 总线的传输周期：将完成一次总线操作的时间称为总线的传输周期。 主存：可以和CPU直接交换信息的存储器（DRAM+ROM）。 辅存：主存的后援存储器用来存放当前暂时不用的程序和数据，不能与CPU直接交换信息。 Cache：高速缓存，CPU可以将要取的信息送至此处。 RAM：随机存储器是一种可读&#x2F;写存储器，掉电后数据丢失。 SRAM：静态RAM，触发器来存储信息，既读又写，位价高。 DRAM：动态RAM，利用电容的原理来存储信息，但由于电容的原理需要再生电路。 ROM：只读存储器，只能对其存储的内容读出，而不能对其重新写入的存储器。 PROM：可编程只读存储器，可对存储器进行一次编程。 EPROM：可擦除可编程只读存储器可用紫外线照射擦除内容，再进行编程。 EEPROM：电可擦除可编程只读存储器。 CDROM:光盘。 Flash Memory:闪速存储器，功能与EEPROM相似，但速度快的多。 机器指令：每一条机器语言的语句。 指令系统：全部机器指令的集合。 RISC: 精简指令系统计算机。 CISC:复杂指令系统计算机。 现代计算机硬件框图 ALU(运算器)和CU(控制器)构成CPU 主存和辅存 构成 存储器 CPU 与 存储器 组成 主机 输入输出设备组成 IO设备 以上所有为计算机 硬件 系统复杂性的管理方法 层次化：将被设计的系统划分为多个模块或子模块 模块化: 有明确的定义的功能和接口 规则性: 模块更容易被重用 计算机取数 过程 取指令 PC –&gt; MAR –&gt; M –&gt; MDR –&gt;IR , (PC) + 1 –&gt; PC (PC自增) 分析指令 OP(IR) –&gt; CU 执行指令 Ad(IR) –&gt; MAR –&gt; M –&gt; MDR –&gt; ACC 程序的运行过程 将程序通过输入设备送至计算机 程序首地址 一&gt; PC 启动程序运行 计算机取数过程 取指令 PC –&gt; MAR –&gt; M –&gt; MDR –&gt;IR , (PC) + 1 –&gt; PC (PC自增) 分析指令 OP(IR) –&gt; CU 执行指令 Ad(IR) –&gt; MAR –&gt; M –&gt; MDR –&gt; ACC … 打印结果 停机 计算机硬件的主要技术指标 计算机硬件的主要技术指标是 机器字长 CPU一次能处理数据的位数与CPU中的寄存器位数有关 存储容量: 存放二进制信息的总位数 主存容量 1K &#x3D; 2 存储单元个数 * 存储字长 MAR MDR 容量 10 8 1K * 8位 ( $ 1K &#x3D; 2^{10} $ ) 16 32 64K * 32位 字节数 如 $ 2^{13}b &#x3D; 1KB $ ( $ 1B &#x3D; 2^{3}b $ ) $ 2^{21}b &#x3D; 256KB $ 辅存容量 字节数 80GB ( $ 1GB &#x3D; 2^{30}B $ ) 运算速度 主频 核数 每个核支持的线程数 吉普森法 $ T_m &#x3D; \\sum_{i&#x3D;1}^n f_it_i $ CPI MIPS FLOPS 总线总线是连接各个部件的信息传输线 是各个部件共享的传输介质 总线是连接多个部件的信息传输线，在任一时刻，只允许有一个部件向总线发送信息，而多个部件可以同时从总线上接收信息。 总线的分类 片内总线：芯片内部的总线 系统总线：计算机各个部件之间的信息传输线 数据总线：双向 与机器字长、存储字长有关 地址总线：单向 与存储地址、I&#x2F;O地址有关 控制总线：有出有入 ( 中断请求、总线请求 ) 通信总线：用于计算机系统之间或计算机系统与其他系统 (如控制仪表、移动通信等)之间的通信 传输方式 串行通信总线 并行通信总线 总线特性及性能指标总线特性 机械特性: 尺寸、形状、管脚数及排列顺序 电气特性: 传输方向和有效的电平范围 功能特性: 每根传输线的功能 地址 数据 控制 时间特性 性能指标 总线宽度：数据线的根数 标准传输率：每秒传输的最大字节数( MBps ) 时钟同步&#x2F;异步：同步、不同步 总线复用：地址线 与 数据线 复用 信号线数：地址线、数据线何控制线的总和 总线控制方式： 突发、自动、仲裁、逻辑、计数 其他指标：负载能力 总线标准按照总线标准生产的各个部件，各模块之间可以集成在一起 ISA EISA VESA(VL-BUS) PCI AGP RS-232 USB 总线结构 单总线结构 系统总线 所有 双总线结构 主存总线 CPU与主存之间传输信息 I&#x2F;O总线 I&#x2F;O接口 外部设备 通道： 具有特殊功能的处理器，由通道对I&#x2F;O统一管理 主存总线与I&#x2F;O总线通过通道连接，实现IO设备与主存储器、IO设备与CPU直接的通讯、 三总线结构 主存总线 CPU与主存之间传输信息 I&#x2F;O总线 I&#x2F;O设备与主存之间直接交换信息 DMA总线 外部设备直接存储器访问 三总线结构中，任一时刻只能使用一种总线 三总线结构又一形式 局部总线 系统总线 扩展总线 常用的总线结构有几种？不同的总线结构对计算机的性能有什么影响？举例说明。（单/多） 常见的总线结构分为两种分别是单总线结构和多总线结构。 单总线结构是将CPU、主存，I/O设备（通过I/O接口）都挂在这一总线上、允许I/O设备之间、I/O设备与CPU之间或I/o设备与主存之间直接交换信息。 单总线结构结构简单、易于扩充，但所有的传送都通过这一总线，不允许两个以上的部件在同一时刻向总线传输信息，会影响系统的工作效率，易形成计算机的瓶颈，故常用于功能简单的实验仪器型机器的设计。 多总线结构：双总线结构将速度较低的I/O设备从单总线上分离出来，形成主存总线与I/O总线分开的结构，而多总线结构就是在其基础上增加总线，形成多总线结构，多总线结构，可以实现多种总线之间的数据传递，可明显提升系统的工作效率，例如，现代微机的结构就是多总线结构 总线控制总线判优控制基本概念 主设备（模块） 对总线有控制权 从设备（模块） 响应从主设备发来的总线命令 集中式 链式查询方式 只需要很少的几根线就能按一定优先次序实现总线控制，而且很容易扩充设备，但对电路故障很敏感且优先级别低的设备可能很难获得请求 计数器定时查询 这种查询方式对电路故障不如链式查询敏感，但增加了控制线设备地址数，控制页较复杂 独立请求方式 独立请求方式响应速度快，优先次序控制灵活，但控制线数量多，总线控制更复杂。 为什么要设置总线判优控制? 因为总线上连接着多个部件，需要一种机制来决定什么时候有哪个部件发送信息、如何给信息传送定时，如何防止信息丢失、如何规定接收部件的一系列问题，因此，为了解决这些多个部件的使用权问题，出现了总线判优机制。 哪种方式响应时间最快，哪种方式对电路故障最敏感? 独立请求方式响应速度快，链式查询对电路故障敏感。 分布式 总线通信控制目的: 解决通信双方协调配合问题 总线传输周期 申请分配阶段：主模块申请，总线仲裁决定 寻址阶段：主模块向从模块给出地址和命令 传数阶段：主模块和从模块交换数据 结束阶段：主模块撤销有关西段 总线通信的四种方式 同步通信：由统一时标控制数据传送 异步通信：采用应答方式，没有公共时钟标准 不互锁 半互锁 全互锁 半同步通信：同步、异步结合 上述三种通信的共同点（一个总线传输周期（以输入数据为例）） 主模块发地址、命令 占用总线 从模块准备数据 不占用总线 总线空闲 从模块向组模块发数据 占用总线 分离式通信：充分挖掘系统 总线每个瞬间 的潜力 特点 各模块有权申请占用总线 采用同步方式通信,不等对方回答 各模块准备数据时,不占用总线 总线被占用时,无空闲 试比较同步通信和异步通信。 同步通信优点，规划明确，统一模块之间的配合简单一致。 缺点主、从设备时间配合属于强制性同步，必须在限定时间内完成规定的要求，必须按最慢部件来设计公共时钟，严重影响总线的工作效率。 异步通信客服了同步通信的缺点，允许各模块的速度不一致性，没有公共的时钟标准，不要求所有部件严格统一操作时间，即当主模块发出请求，一直等待从模块反馈回来响应。 为什么说半同步通信同时保留了同步通信和异步通信的特点？ 同步通信既保留了同步通信的基本特点，如所有的地址命令，数据信号的发出时间都严格参照系统时钟的某个前沿开始，而接收方都采用系统时钟后沿时刻来进行判断识别，同时又像异步通信那样允许不同速度的模块和谐的工作 主存储器简介 分类 存储介质分类 半导体存储器：TTL、MOS 磁表面存储器：磁头、载磁体 磁芯存储器：硬磁材料、环状元件 光盘存储器：激光、磁光材料 按存取方式分类 存取时间与物理地址无关（随机访问） 随机存储器：在程序的执行过程中可读可写 只读存储器：在程序的执行过程中只读 存取时间与物理地址无关（串行访问） 顺序存取存储器——磁带 直接存取存储器——磁盘 按在计算机中的作用分类 主存储器 RAM 静态RAM（SRAM） 保存0和1的原理是什么? 基本单元电路的构成是什么? 对单元电路如何读出和写入? 典型芯片的结构是很么样子的? 静态RAM芯片的如何进行读出和写入操作? 动态RAM（DRAM） ROM（只读存储器） MROM（掩膜ROM） PROM（一次性编程） EPROM（多次性编程）——紫外线 EEPROM（多次性编程）——电可擦写 Flash Memory（闪速型存储器）——U盘 高速缓冲存储器（Cache） 辅助存储器 4.8试比较静态 RAM 和动态 RAM 。 静态RAM是由触发器构成的存储器，位价高。 动态RAM是电容构成的存储器，价位低，但需要配置刷新电路。 SRAM在相同的存储容量的条件下，需要更大的体积集成度低，DRAM集成度高。 4.9什么叫刷新？为什么要刷新？说明刷新有几种方法。 电容上的电荷一般只能维持1～2ms 因此，即使电源不掉，电信息也会自动消失，为此，必须在2ms内对其所有存储单元恢复一次原状态，这个过程称为再生或刷新。 刷新的方法有三种： 集中刷新：是在规定的一个刷新周期内，对存储单元集中一段时间内逐行刷新，停止读/写。（有死区） 分散刷新：（抽空刷新） 异步刷新：前两种的结合。 存储器的层次结构 缓存-主存（速度问题——硬件解决） 主存-辅存（容量问题——软硬件相结合） 存储器三个主要特性的关系 主存和CPU的联系 主存中存储单元地址的分配 主存的技术指标 存储容量：主存 存放二进制代码的总位数 存储速度： 存取时间：存储器的访问时间 | 读出时间 写入时间 存取周期：连续两次独立的存储器操作（读或写）所需的 最小间隔时间 | 读周期 写周期 存储器的带宽：位&#x2F;秒 4.2计算机中哪些部件可用于存储信息，按其速度、容量和价格／位排序说明。 计算机中可用寄存器，缓存，主存，磁盘，磁带来存储信息。 寄存器 缓存 越下容量越大 主存 越上速度越快 磁盘 越上位价越贵 磁带 4.3存储器的层次结构主要体现在什么地方，为什么要分这些层次，计算机如何管理这些层次？ 存储器的层次结构主要体现在缓存-主存，主存-辅存，这两存储层次上， 缓存-主存，层次主要解决CPU和主存速度不匹配的问题，主存和缓存之间的数据调动是由硬件自动完成的，对程序员是透明的。 主存-辅存层次主要解决系统的容量问题，辅存速度比主存低而且不能与CPU直接交换信息，但容量比储存大CPU要用这些数据时就将辅存中的数据复刻到主存中，由CPU调用直接访问。 现代计算机系统几乎都有这两存储层次，构成了缓存，主存，辅存三级存储系统，并逐渐形成了虚拟存储系统。 4.5什么是存储器的带宽？着存储器的数据总线宽度为32 位，存取周期为200 ns ，则存储器的带宽是 存储带宽是单位时间内存储器存取的信息量。 1/200ns*32=160M位/S 4.10半导体存储器芯片的译码駆动方式有几种？ 译码驱动有两种方法，线选法与重合法。 重合法比线选法，更好使得字线根数减少，可以用较少的字线来选择更多的数据，刻电路面积减小。 半导体存储芯片简介 基本结构 片选线：确定存储地址 读&#x2F;写控制线：确定读写 译码驱动方式：给出了存储单元的地址后，怎么去找到指定的存储单元 线选法 重合法 4.10半导体存储器芯片的译码駆动方式有几种？ 译码驱动有两种方法，线选法与重合法。 重合法比线选法，更好使得字线根数减少，可以用较少的字线来选择更多的数据，刻电路面积减小。 存储器与CPU的连接 存储器容量的扩展 位扩展（增加存储字长） 两个芯片的片选使用相同的信号连接 字扩展（增加存储字的数量） 字、位同时扩展 存储器校验编码的最小距离：任意两组合法代码之间 二进制位数 的 最小差异编码的纠错、检错能力与编码的最小距离有关 L-1 &#x3D; D + C (D&gt; &#x3D; C) L—— 编码的最小距离 D—— 检测错误的位数 C—— 纠正错误的位数 奇偶校验汉明码校验汉明码的组成 汉明码的组成需增添？位检测位 $$ 2^k &gt;&#x3D; n + k + 1 $$ 检测位的位置 $$ 2^i (i&#x3D; 0,1,2,3,…) $$ 检测位的取值 检测位的取值与该位所在的检测“小组”承担的奇偶校验任务有关 汉明码的检错 汉明码的奇配原则：按照偶配原则计算的Ci后，取反的奇配原则下的检测位取值。 高速缓冲存储器 （Cache）简介 问题的提出 避免CPU“空等”现象 CPU和主存（DRAM）的速度差异 程序访问的局部性原理 Cache工作原理Cache的命中率命中：主存块调入缓存（主存块与缓存块建立了对应关系） 不命中：主存块未调入缓存（主存块与缓存块未建立对应关系） 命中率：CPU欲访问的信息在Cache中的比率（命中率与Cahche的容量与块长有关） Cache-主存系统的效率效率e与命中率有关 $$ e &#x3D; \\frac{访问Cache的时间}{平均访问时间}*100% $$ Cache的基本结构 Cache读写操作 读 写 Cache和主存的一致性 写直法（Write-through） 写操作时数据既写入Cache又写入主存写操作时间就是访问主存的时间, Cache块退出时,不需要对主存执行写操作,更新策略比较容易实现 写回法 （Write-back） 写操作时只把数据写入Cache而不写入主存当Cache数据被替换出去时才写回主存**,写操作时间就是访问Cache的时间**, Cache块退出时,被替换的块需写回主存,增加Cache的复杂性 Cache改进 增加Cache的级数 片载（片内）Cache 片外Cache 统一缓存和分立缓存 指令Cache 数据Cache 与指令执行的控制方式有关 是否流水 Cache-主存的地址映射 直接映射 某一主存块只能固定映射到某一缓存块 特点：不灵活、Cache利用率低、速度快 全相联映射 某一主存块能映射到任一缓存块 特点：成本高、Cache利用率高、速度慢 组相连映射 直接映射和全相联映射的折中。 某一主存块只能映射到某一缓存组中的任意缓存块 特点：Cache利用率比较高、速度比较快 替换算法 解决问题：Cache满时选择正确的块，从Cache中退出 先进先出（FIFO）算法 近期最少使用（LRU）算法 4.25 什么是程序访问的局部性？存储系统哪一阶段采用了程序访问的局限性原理？ 通过大量典型程序分析发现，CPU从主存取指令获取数据，在一定时间内只是对主存局部地址区域的访问，这是由于指令和数据在主存内都是连续存放的，并且有些指令和数据往往会被多次调用，集指令和数据在储存的地址分部不是随机的，而是相对簇聚的，使得CPU在执行程序时访存具有相对的局部性，这就称为程序访问的局部性原理。 Cache-主存层次与主存辅存层次采用了局部性原理。 4.26计算机中设置 Cache 的作用是什么？能不能把 Cache 的容量扩大，最后取代主存，为什么？ Cache的出现，大大提高了CPU访问主存的速度，中央处理器可以不直接访问主存，直接与Cache交换信息，极大地解决了CPU与主存之间速度矛盾的问题。 不可以将Cache的容量扩大，进而取代主存，一般而言，cache容量越大即CPU命中率越高，当然容量也没有必要太大，太大会增加成本，当容量达到一定值时，命中率已不再因容量增加而显著增加。 4.27 Cache 制作在 CPU 芯片内有什么好处？将指令Cache和数据Cache分开又有什么好处？ Cache制作在CPU内部提高了外部总线利用率，因为Cache在CPU内部可直接访问，不必占用外部总线，进而增强了系统的整体效率，也提高了CPU存储速度。 将指令Cache与数据Cache分开有以下好处 可支持超前控制和流水线控制，有利于这类控制方式下指令预取操作的完成。 指令Cache可用ROM实现，提高指令存取可靠性。 数据Cache对不同类型数据支持更为灵活。 辅助存储器概述 特点：不直接与CPU交换信息 I&#x2F;O系统（输入输出系统）概述 早期 分散连接 CPU和I&#x2F;O设备 串行 工作 程序查询方式 接口模块和DMA阶段 总线连接 CPU和I&#x2F;O设备 并行 工作 中断方式 DMA方式 具有通道结构的阶段 具有I&#x2F;O处理机的阶段 组成 I&#x2F;O软件 I&#x2F;O指令 CPU指令的一部分 操作码 命令码 设备码 通道指令 通道自身的指令 I&#x2F;O硬件 设备 I&#x2F;O接口 设备 设备控制器 通道 I&#x2F;O设备与主机的联系方式 I&#x2F;O设备编址方式 统一编址 用取数、存数 不统一编址 有专门的I&#x2F;O指令 设备选址 用设备选择电路识别是否被选中 传送方式 串行 并行 联系方式 计算方法指令系统计算机网络入门常用的网络配置命令 Ping、 IPConfig、 Tracert、 Nslookup、 Netstat、 ARP、 Route、 Nbtstat Cisco Packet Tracer操作系统算法摘要:chicken:计算机组成原理（哈工大刘宏伟）135讲（全）高清https://www.bilibili.com/video/BV1t4411e7LH?p=48&spm_id_from&#x3D;333.1007.top_right_bar_window_history.content.click&amp;vd_source&#x3D;fb3505db9b87542728213f28843a6d74","categories":[{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://blog.yyshino.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"}],"tags":[{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.yyshino.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"}]},{"title":"Koa","slug":"Koa","date":"2022-08-26T09:48:00.000Z","updated":"2022-09-20T15:04:34.303Z","comments":true,"path":"posts/3740.html","link":"","permalink":"https://blog.yyshino.top/posts/3740.html","excerpt":"","text":"Koa2简介Koa 是一个新的 web 框架，由 Express 幕后的原班人马打造， 致力于成为 web 应用和 API 开发领域中的一个更小、更富有表现力、更健壮的基石。 通过利用 async 函数，Koa 帮你丢弃回调函数，并有力地增强错误处理。 Koa 并没有捆绑任何中间件， 而是提供了一套优雅的方法，帮助您快速而愉快地编写服务端应用程序。 安装npm install -S koa 版本依赖nodejs&gt;v7.6.0 Koa脚手架 koa-generator快速生成koa服务的脚手架工具 安装 yarn global add koa-generator or npm install -g koa-generator 生成文件 koa2 + 项目名 安装依赖 npm install or yarn 启动服务 npm start or node .bin/www koa工作原理洋葱模型 执行顺序：顺序执行 回调的顺序：反向执行 先进后出 koa-generator创建的koa2框架目录koa中间件常用插件 路由 koa-router 跨域处理 @koa&#x2F;cors 压缩 koa-compress 静态资源 koa-static 协议处理 koa-json koa-body 安全 鉴权方式 koa-session kos-jwt 通信头 koa-helmet 日志 koa-logger 更多 koa-wiki 常用APIapp.use app.listene app.on 连接数据库pm2 部署Koa项目","categories":[{"name":"node后端","slug":"node后端","permalink":"https://blog.yyshino.top/categories/node%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"Koa/Koa2","slug":"Koa-Koa2","permalink":"https://blog.yyshino.top/tags/Koa-Koa2/"}]},{"title":"ECharts数据可视化","slug":"ECharts数据可视化","date":"2022-08-26T05:16:40.000Z","updated":"2022-08-29T06:25:44.305Z","comments":true,"path":"posts/56051.html","link":"","permalink":"https://blog.yyshino.top/posts/56051.html","excerpt":"","text":"echarts官方文档https://echarts.apache.org/zh/index.html 基础入门 创建dom容器 引入echarts文件 初始化echarts实例 配置echarts 自定义主题 在主题编辑器中编辑主题主题编辑器的地址为: https://www.echartsjs.com/theme-builder/ 下载主题, 是一个 js 文件在线编辑完主题之后, 可以点击下载主题按钮, 下载主题的js文件 引入主题 js 文件 在 init 方法中使用主题 调色盘 主题调色盘 全局调色盘 局部调色盘 渐变颜色的实现 线性渐变 径向渐变 样式 直接样式 高亮样式 自适应 监听窗口大小变化事件 在事件处理函数中调用 ECharts 实例对象的 resize 动画ECharts 已经内置好了加载数据的动画, 我们只需要在合适的时机显示或者隐藏即可 显示加载动画 mCharts.showLoading() // 一般, 我们会在获取图表数据之前 显示加载动画 隐藏加载动画 mCharts.hideLoading() // 一般, 我们会在获取图表数据之后 隐藏加载动画, 显示图表 增量动画所有数据的更新都通过 setOption 实现, 我们不用考虑数据到底产生了那些变化, ECharts 会找到两组数据之间的差异然后通过合适的动画去表现数据的变化。 动画的配置 开启动画animation: true 动画时长animationDuration: 5000 缓动动画animationEasing : &#39;bounceOut&#39; 其他动画曲线 交互API全局echarts 对象全局 echarts 对象是引入 echarts.js 文件之后就可以直接使用的 echarts.init 初始化ECharts实例对象 echarts.registerTheme 注册主题 echarts.registerMap 注册地图数据 echarts.connect 一个页面中可以有多个独立的图表 每一个图表对应一个 ECharts 实例对象 connect 可以实现多图关联，传入联动目标为 EChart 实例，支持数组 echartsInstance 对象eChartsInstance 对象是通过 echarts.init 方法调用之后得到的 echartsInstance.setOption 设置或修改图表实例的配置项以及数据 echartsInstance.resize 重新计算和绘制图表 echartsInstance.on echartsInstance.off 绑定或者解绑事件处理函数 鼠标事件 常见事件: ‘click’、’dblclick’、’mousedown’、’mousemove’、’mouseup’ 等 事件参数 arg: 和事件相关的数据信息 ECharts 事件 常见事件:legendselectchanged、’datazoom’、’pieselectchanged’、’mapselectchanged’等 事件参数 arg: 和事件相关的数据信息 echartsInstance.dispatchAction主动触发某些行为, 使用代码模拟用户的行为 echartsInstance.clear清空当前实例，会移除实例中所有的组件和图表清空之后可以再次 setOption echartsInstance.dispose销毁实例销毁后实例无法再被使用 一些解决方案Vue中使用echarts通用代码结构 export default { name: \"\", data() { return { charInstance: null, allData: null, // 从服务器中获取的所有数据 }; }, mounted() { this.initChart(); this.getData(); // 对屏幕大小进行监听 window.addEventListener(\"resize\", this.screenAdapter); this.screenAdapter(); }, destroyed() { // 组件销毁时，取消监听 window.removeEventListener(\"resize\", this.screenAdapter); }, methods: { initChart() { this.charInstance = this.$echarts.init(this.$refs.trend_ref); const initOption = { // 初始化相关 }; this.charInstance.setOption(initOption); }, async getData() { // await this.$http.get() // 对allData进行赋值 this.updateChart(); }, updateChart() { // 处理数据 const dataOption = { // 数据相关 }; this.charInstance.setOption(dataOption); }, screenAdapter() { const adapterOption = { // 适应性相关 }; this.charInstance.setOption(adapterOption); this.charInstance.resize(); }, }, };","categories":[{"name":"数据可视化","slug":"数据可视化","permalink":"https://blog.yyshino.top/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"}],"tags":[{"name":"echarts","slug":"echarts","permalink":"https://blog.yyshino.top/tags/echarts/"}]},{"title":"HTML","slug":"HTML","date":"2022-08-25T05:20:57.000Z","updated":"2022-08-28T09:01:11.147Z","comments":true,"path":"posts/54626.html","link":"","permalink":"https://blog.yyshino.top/posts/54626.html","excerpt":"","text":"","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"https://blog.yyshino.top/tags/HTML/"}]},{"title":"CSS","slug":"CSS","date":"2022-08-25T05:20:48.000Z","updated":"2022-09-16T10:33:36.182Z","comments":true,"path":"posts/6541.html","link":"","permalink":"https://blog.yyshino.top/posts/6541.html","excerpt":"","text":"CSS进阶flex弹性布局grid网格布局移动端适配布局逻辑像素与物理像素&amp;emsp;&amp;emsp;逻辑像素，也叫“设备独立像素”，对于前端来说就是css中的像素，举例：iphone6下的逻辑像素为375px。 &amp;emsp;&amp;emsp;物理像素，即设备屏幕实际拥有的像素点，一个设备生产出来，他们的像素就已经确定了，举例：iphone6下的物理像素为750px。 逻辑像素：CSS中的像素，绝对单位，保证不同设备下元素的尺寸是相同的。 物理像素：设备屏幕实际拥有的像素点，相对单位，不同设备下物理像素大小不同。 响应式布局媒体查询 媒体查询的编写位置以及顺序 添加到样式表的底部，对CSS进行优先级的覆盖 移动端 -&gt; PC端适配的原则: min-width从小到大 PC端适配的原则 -&gt; 移动端 : min-width从大到小 总结:min-width方式: 移动优先的原则，先编写移动端设备，然后响应式过渡到PC端 响应断点(阈值)设定 一种解决方案 工具插件设计稿 Photoshop PxCood","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"https://blog.yyshino.top/tags/CSS/"}]},{"title":"JavaWeb","slug":"JavaWeb","date":"2022-08-10T05:49:17.000Z","updated":"2022-09-16T10:33:50.825Z","comments":true,"path":"posts/60206.html","link":"","permalink":"https://blog.yyshino.top/posts/60206.html","excerpt":"","text":"从鱼皮哪获取的Java路线图","categories":[],"tags":[{"name":"java","slug":"java","permalink":"https://blog.yyshino.top/tags/java/"}]},{"title":"钓鱼佬入门","slug":"钓鱼佬入门","date":"2022-07-31T07:45:22.000Z","updated":"2022-09-16T10:32:10.887Z","comments":true,"path":"posts/50287.html","link":"","permalink":"https://blog.yyshino.top/posts/50287.html","excerpt":"","text":"知己知彼各鱼类习性鲤鱼 食物: 玉米 栖息地: 底层鱼类 习惯: 水底不平，大小石头旁, 有安全感的地方 草鱼 食物: 玉米 栖息地: 底层鱼类 习惯: 水底不平，大小石头旁, 有安全感的地方 鲫鱼 食物: 麦粒 栖息地: 底层鱼类 习惯: 黄刺骨 食物: 蚯蚓 栖息地: 习惯: 鱼饵 与 窝料鱼饵 窝料","categories":[],"tags":[{"name":"兴趣","slug":"兴趣","permalink":"https://blog.yyshino.top/tags/%E5%85%B4%E8%B6%A3/"}]},{"title":"TypeScript入门","slug":"TypeScript入门","date":"2022-07-30T00:43:12.000Z","updated":"2022-09-06T02:42:29.409Z","comments":true,"path":"posts/33883.html","link":"","permalink":"https://blog.yyshino.top/posts/33883.html","excerpt":"","text":"回顾js原型protorype和原型链_proto_TS安装TS class类方法重载 (methodoverload)函数重载构造器重载多态静态属性区别对象属性静态属性static 分类静态引用属性静态基本类型属性继承extendssuper的使用 super代表 父类的构造函数名 或 父类的类名 通过”super”关键字只能访问基类的公共方法和受保护方法。 获取 &#x2F; 重写 父类方法 访问修饰符 public: 公开 protected: 可以在本类和子类中访问，不能再类的外部使用 private: 只允许在本类中访问 注意 默认: public 父类方法的访问范围【访问修饰符】必须小于子类中方法重写的访问范围【访问修饰符】 父类方法不能是private 源码//TS类 双重性质 即是类型【new实例时TS类是类型】 当用TS类直接获取属性时就是对象 //JS函数 双重性质 即是类型【new实例时JS函数也是类型】 当用JS类直接获取属性时就是对象 断言as 类型断言中的不能相互重叠问题: 两个类之间断言的规则: 两个类中任意一个的属性和方法是另一个类的属性和方法完全相同或子集，则这两个类可以相互断言 否则这两个类就不能相互断言 任何数据类型都可以转换成any 或unknown类型 适用性 对象中的Symbol数据类型取值问题 加法计算,巧用as any。 TS类型守卫 类型判断: typeof typeof 检测变量的类型范围包括： “string” | “number” | “bigint” | “boolean” | “symbol” | “undefined” | “object” | “function” 等数据类型。 typeof的局限性 检测null: typeof null 的结果是 object 检测数组变量: typeof [] 的结果是 object 检测Set Map变量: 结果也是 object 替代方案 Object.protorype.toString.call() 依然无法解决的问题:无法获取一个自定义的类的实例变量或构造函数的对象变量的真正创建类型，答案是使用 instanceof 来解决。 属性或者方法或者函数判断: in 实例判断: instanceof 字面量相等判断: == === != !== interface接口泛型&lt;T&gt;约束泛型&lt;T extends &gt;让传入类型满足特定条件 泛型在类和接口中的使用其他类型别名 type为繁杂的类型创建一个简单的写法 字面量只能是原始数据类型 交叉类型 &amp;声明文件","categories":[{"name":"web进阶","slug":"web进阶","permalink":"https://blog.yyshino.top/categories/web%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://blog.yyshino.top/tags/TypeScript/"}]},{"title":"Vue后台通用管理系统总结","slug":"Vue后台通用管理系统总结","date":"2022-07-24T01:22:06.000Z","updated":"2022-10-09T03:35:46.006Z","comments":true,"path":"posts/1327.html","link":"","permalink":"https://blog.yyshino.top/posts/1327.html","excerpt":"","text":"company-admin项目地址 https://github.com/0Shino0/company-admin 技术栈 Vue3 + Element Plus + Sass 实现前台 Koa2 + MongoDB 实现后台 Vite项目构建 前台环境变量配置.env.dev config 配置不同环境的 api (方便调节 和 测试) dev baseApi mockApi test baseApi mockApi prod baseApi mockApi 对外暴露 config &#x3D;&gt; 二次封装axios 二次封装axios 创建axios实例对象 请求拦截器 获取请求头headers 获取token (如果请求头中存在token) 响应拦截器 比对状态码 code 判断token是否超时 返回 成功&#x2F; 错误提示 核心函数 一般默认发送 get请求 (将请求方法 转化为大写) 判断 使用 mockApi 还是 baseApi 对不同的 请求方法进行遍历 二次封装 storage/** * Storage二次封装 * @author YyShino */ import config from './../config' export default { // 存储 setItem(key, val) { let storage = this.getStorage(); storage[key] = val; window.localStorage.setItem(config.namespace, JSON.stringify(storage)); }, // 获取 getItem(key) { return this.getStorage()[key] }, getStorage() { // JSON.parse() 方法用来解析 JSON 字符串，构造由字符串描述的 JavaScript 值或对象。提供可选的 reviver 函数用以在返回之前对所得到的对象执行变换 (操作)。 return JSON.parse(window.localStorage.getItem(config.namespace) || \"{}\"); }, // 删除 一个 clearItem(key) { // 读取 let storage = this.getStorage(); // 删除 delete storage[key]; // 写入并 覆盖 window.localStorage.setItem(config.namespace, JSON.stringify(storage)); }, // 删除 全部 clearAll() { window.localStorage.clear() } } 公共组件封装 BreadCrumb.vue (头部区域) Home.vue (主要内容) TreeMenu.vue (左侧菜单栏) Vue-Router 和 VuexVue-Router 注册路由 (routes) &#x2F; Welcome 动态添加路由 Login 404 动态添加路由 (addRoute) 系统管理 User Menu Role Dept 审批管理 Leave Approve 动态路由实现 // router 主文件 async function loadAsyncRoutes() { // console.log(loadAsyncRoutes()); let userInfo = storage.getItem(\"userInfo\") || {}; if (userInfo.token) { try { const { menuList } = await API.getPermissionList(); // utils 为封装工具类 let routes = utils.generateRoute(menuList); routes.map((route) => { let url = `./../views/${route.component}.vue`; route.component = () => import(url); router.addRoute(\"home\", route); }) } catch (error) { } } } await loadAsyncRoutes() // utils 封装工具类 generateRoute // 动态路由拼接 generateRoute(menuList) { let routes = [] const deepList = (list) => { while (list.length) { let item = list.pop() if (item.action) { routes.push({ name: item.component, path: item.path, meta: { title: item.menuName }, component: item.component }) } if (item.children &amp;&amp; !item.action) { deepList(item.children) } } } deepList(menuList) return routes; } 路由守卫 (beforeEach) router.beforeEach((to, from, next) => { // console.log(router.hasRoute(to.name)); if (router.hasRoute(to.name)) { document.title = to.meta.title; next() } else { next('/404') } }) Vuex state 利用storage存储用户信息、菜单信息、菜单行为信息(创建、查看、编辑、删除等等)、右上角消息提示数量 mutations 对应 state 的 mutations 操作 全局/** * mainjs中 */ // 定义全局指令 app.directive('has', { beforeMount: (el, binding) => { // console.log(el, binding); // 获取按钮权限 let actionList = storage.getItem('actionList') let value = binding.value; // includes() 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 true，否则返回 false。 // 盘点列表中是否有对应按钮权限标识 let hasPermission = actionList.includes(value) if (!hasPermission) { // 隐藏按钮 el.style = \"display:none\" setTimeout(() => { // 删除按钮 el.parentNode.removeChild(el) }, 0) } } }) // 全局挂载 请求组件 app.config.globalProperties.$request = request; app.config.globalProperties.$api = api; app.config.globalProperties.$storage = storage; 根据接口 获取数据 渲染数据后台连接数据库/** * 配置文件 */ module.exports = { URL: 'mongodb://127.0.0.1:27017/company-manager' } /** * 数据库连接 */ const mongoose = require('mongoose'); const config = require('./index'); const log4js = require('./../utils/log4j') mongoose.connect(config.URL,{ useNewUrlParser: true, useUnifiedTopology: true }) const db = mongoose.connection; db.on('error',() => { log4js.error('***数据库连接失败***') }) db.on('open',() => { log4js.info('***数据库连接成功***') }) 日志输出封装log4js 工具类封装 CODE 状态码设置 分页 pager 成功 &#x2F; 失败 的debug jwt 解密 token 递归拼接 菜单列表 树 处理时间格式 yyyy-mm-dd hh:mm:ss MongoDB数据库设计 app.js logger 校验token 注册路由 error","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"}],"tags":[{"name":"Vue3实战","slug":"Vue3实战","permalink":"https://blog.yyshino.top/tags/Vue3%E5%AE%9E%E6%88%98/"}]},{"title":"微信小程序","slug":"微信小程序","date":"2022-06-26T02:07:32.000Z","updated":"2022-08-26T09:48:46.850Z","comments":true,"path":"posts/35506.html","link":"","permalink":"https://blog.yyshino.top/posts/35506.html","excerpt":"","text":"微信小程序文档 小程序代码构成 .json 后缀的 JSON 配置文件 .wxml 后缀的 WXML 模板文件 ————html .wxss 后缀的 WXSS 样式文件 ————css .js 后缀的 JS 脚本逻辑文件 ————js 小程序发布简介分包加载目前小程序分包大小有以下限制： 整个小程序所有分包大小不超过 20M 单个分包&#x2F;主包大小不能超过 2M 常规分包配置 目录配置 ├── app.js ├── app.json ├── app.wxss ├── packageA │ └── pages │ ├── cat │ └── dog ├── packageB │ └── pages │ ├── apple │ └── banana ├── pages │ ├── index │ └── logs └── utils app.json配置 &#123; &quot;pages&quot;:[ &quot;pages/index&quot;, &quot;pages/logs&quot; ], &quot;subpackages&quot;: [ &#123; &quot;root&quot;: &quot;packageA&quot;, &quot;pages&quot;: [ &quot;pages/cat&quot;, &quot;pages/dog&quot; ] &#125;, &#123; &quot;root&quot;: &quot;packageB&quot;, &quot;name&quot;: &quot;pack2&quot;, &quot;pages&quot;: [ &quot;pages/apple&quot;, &quot;pages/banana&quot; ] &#125; ] &#125; 详细见官网 https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html 独立分包 特点 独立分包可单独访问分包的内容,不需要下载主包 独立分包不能依赖主包或者其他包的内容。 适用情况 不受主包影响 (或与主包关联不大的页面 ) —— 例如一些临时的广告页面 | 活动页面 使用 在常规分包基础上 app.json 中添加 independent&quot;: true 表示独立分包 独立分包 无法引用主包中资源（例如图标字体） ， 因此独立分包中的 主包资源 需要在分包目录重新引入 分包预加载app.json 增加 preloadRule 配置来控制。 \"preloadRule\": { \"pages/index\": { \"network\": \"all\", \"packages\": [\"important\"] }, \"sub1/index\": { \"packages\": [\"hello\", \"sub3\"] }, \"sub3/index\": { \"packages\": [\"path/to\"] }, \"indep/index\": { \"packages\": [\"__APP__\"] } } 注意: preloadRule 与 pages 以及其他分包同级 详细了解 https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/preload.html 分包异步化新加入功能 详细了解 https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/async.html 小程序框架 Uni-App","categories":[{"name":"web进阶","slug":"web进阶","permalink":"https://blog.yyshino.top/categories/web%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://blog.yyshino.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"微信小程序入门uni-app","slug":"uni-app","date":"2022-06-15T13:29:51.000Z","updated":"2022-08-26T09:42:00.491Z","comments":true,"path":"posts/35477.html","link":"","permalink":"https://blog.yyshino.top/posts/35477.html","excerpt":"","text":"原生小程序框架下的小程序Vue框架 uni-app项目目录React框架 Taro","categories":[{"name":"web进阶","slug":"web进阶","permalink":"https://blog.yyshino.top/categories/web%E8%BF%9B%E9%98%B6/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"https://blog.yyshino.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"}]},{"title":"老师的建议","slug":"老师的建议","date":"2022-06-15T13:24:51.000Z","updated":"2022-09-15T02:30:26.503Z","comments":true,"path":"posts/11752.html","link":"","permalink":"https://blog.yyshino.top/posts/11752.html","excerpt":"","text":"大学学习的是知识，工作看的是能力。能力的基础是知识。 理论知识是根基，上层技术、框架如何变化都离不开底层。以不变应万变 后端需要掌握的技术分为三个层次来看—— 应用层、中间层、基础层 计算机基础主要是操作系统、数据库、数据结构和算法、计算机组成原理、计算机网络 、编译原理，这些知识几十年都没有变化，再过十年也不会变。 基础稳如泰山，对它们进行投资永不亏本。 中间层和应用层这两层随着时代的变迁在剧烈地重构。但是一个人积累的知识10年后还剩下多少， 要看一个人入行的时间处于技术发展的哪个阶段。技术的发展也不是颠覆性的，而是渐进性的，它不会一下子消失，只会边缘化。","categories":[],"tags":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.yyshino.top/tags/%E8%B8%A9%E5%9D%91/"}]},{"title":"初入Node全栈","slug":"初入Node全栈","date":"2022-06-15T13:15:59.000Z","updated":"2022-08-26T09:48:57.120Z","comments":true,"path":"posts/11307.html","link":"","permalink":"https://blog.yyshino.top/posts/11307.html","excerpt":"","text":"简介普通的前端能做的太少，仅仅对页面的布局与调用接口。做了一些简单的项目有所感悟，时常为了做项目而去找接口，没有接口就不想做项目，有种感觉失去接口后就寸步难行的感觉。因此我决定由JavaScript过渡到Node全栈，最后过渡到java全栈.一方面原因降低学习成本，有了JavaScript的基础入门node相对简单，上手快。另一方面，我想看看Node作为后端到底和Java相差多少。 Node框架expresskoa&#x2F;koa2","categories":[{"name":"node后端","slug":"node后端","permalink":"https://blog.yyshino.top/categories/node%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"nodejs","slug":"nodejs","permalink":"https://blog.yyshino.top/tags/nodejs/"}]},{"title":"实战——网易云PC","slug":"CloudMusic","date":"2022-06-07T07:42:42.000Z","updated":"2022-08-28T09:08:37.662Z","comments":true,"path":"posts/26719.html","link":"","permalink":"https://blog.yyshino.top/posts/26719.html","excerpt":"","text":"使用技术栈vue全家桶+Element+Swiper 开发第三天踩坑总结获取图片主题色的两种方法1.canvas绘制图片 获取rpga值2.使用Css 内置 filter 实现高斯模糊filter:blur()","categories":[],"tags":[{"name":"Vue实战","slug":"Vue实战","permalink":"https://blog.yyshino.top/tags/Vue%E5%AE%9E%E6%88%98/"}]},{"title":"web踩坑","slug":"webHitPit","date":"2022-05-28T03:24:45.000Z","updated":"2022-09-16T10:34:21.558Z","comments":true,"path":"posts/18408.html","link":"","permalink":"https://blog.yyshino.top/posts/18408.html","excerpt":"","text":"时间 + 问题Webpack1. loader 版本过高问题类似提示，可能存在 loader 版本过高问题，下载低版本loader 即可解决。 2.Git1.git push问题2022年4月21日08:52:49 错误 fatal: remote error: You can't push to git://github.com/你的git用户名/Demo.git Use https://github.com/你的git用户名/Demo.git 解决办法一：最后按照百度来的解决方法解决了该问题控制台输入以下两条命令后再次尝试git push操作 git remote rm origin git remote add origin git@github.com:git用户名/仓库名.git 如果出现以下问题 fatal: The current branch main has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin main 则执行下方命令 git push --set-upstream origin main 出现下方提示证明上游分支设置成功 Branch 'main' set up to track remote branch 'main' from 'origin'. 进行该操作后可以正常git push,git pull操作了 解决办法二： 8-30新增解决方法 进入项目文件夹目录下，找到.git文件夹（如果不显示请打开查看隐藏目录选项） 效果如图 找到config文件，打开后如下图： 如果url为http开头，如：https://github.com/用户名/仓库名，例：https://github.com/kobeyk/SpringBoot-ShpTools.git 则修改为git@github.com:用户名/仓库名,注意，githup.com与用户名中间为英文符号: ————————————————版权声明：本文为CSDN博主「七加一i」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。原文链接：https://blog.csdn.net/qq_43961619/article/details/116595085 2.Git快速搜索作用 快速搜索源码中文件的路径 使用方法 在github中找到你要查询的库 选择In this respository 回车 3.React1.React路由2022年3月6日19:01:00 今天做练习react路由出现错误，index.tsx:19 Uncaught Error: A is only ever to be used as the child of element, nev…由于路由版本升级，Route需要在Routes组件内，并且component替换成element，括号中变为标签&lt;Routes&lt;&#x2F;Routes记录一下原文链接：https://blog.csdn.net/m0_50981596/article/details/122811781 &#x3D;&#x3D;以上是路由6版本，由于改动过大，建议先使用5版本&#x3D;&#x3D; 2.解决多级路径刷新页面样式丢失的问题 1.public/index.html 中 引入样式时不写 ./ 写 / （常用） 2.public/index.html 中 引入样式时不写 ./ 写 %PUBLIC_URL% （常用） 3.使用HashRouter Antd-React UI库1.antd自定义主题报错2022年3月26日16:45:13 ERROR in ./src/styles/wieldy.less (./node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[9].use[1]!./node_modules/postcss-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[9].use[2]!./node_modules/resolve-url-loader/index.js??ruleSet[1].rules[1].oneOf[9].use[3]!./node_modules/less-loader/dist/cjs.js??ruleSet[1].rules[1].oneOf[9].use[4]!./src/styles/wieldy.less) Module build failed (from ./node_modules/postcss-loader/dist/cjs.js): ValidationError: Invalid options object. PostCSS Loader has been initialized using an options object that does not match the API schema. - options has an unknown property 'plugins'. These properties are valid: object { postcssOptions?, execute?, sourceMap?, implementation? } at validate (C:\\Workspace\\harv-Harvest-frontend\\node_modules\\schema-utils\\dist\\validate.js:105:11) at Object.getOptions (C:\\Workspace\\harv-Harvest-frontend\\node_modules\\webpack\\lib\\NormalModule.js:580:19) at Object.loader (C:\\Workspace\\harv-Harvest-frontend\\node_modules\\postcss-loader\\dist\\index.js:40:24) 解决方案 也有这个问题。 似乎因为 less-loader 6 customize-cra “addLessLoader” 被破坏了。 这个PR修复了它，但从未合并。同一个人创建了这个包： customize-cra-less-loader 解决这个问题： 安装custom-cra-less-loader包 “config-overrides.js”应该是这样的： const { override } = require(\"customize-cra\"); const addLessLoader = require(\"customize-cra-less-loader\"); module.exports = override( addLessLoader({ lessLoaderOptions: { lessOptions: { javascriptEnabled: true, modifyVars: { '@primary-color': '#038fde', } } } }) ); 转自https://stackoverflow.com/questions/71035578/postcss-loader-has-been-initialized-using-an-options-object-that-does-not-match 2.antd自定义主题修改失效2022年3月26日16:45:13 less-loader版本低，版本参考 \"less\": \"3.12.2\", \"less-loader\": \"^10.2.0\", 3.Vue1.Vue Router 4版本 不适应3版本2022年4月19日11:13:48 报错 Uncaught TypeError: Object(...) is not a function at eval (webpack-internal:///./node_modules/vue-router/dist/vue-router.esm-bundler.js:2145:97) at Module../node_modules/vue-router/dist/vue-router.esm-bundler.js (chunk-vendors.js:1609:1) at __webpack_require__ (app.js:849:30) at fn (app.js:151:20) at eval (webpack-internal:///./src/router/index.js:3:68) at Module../src/router/index.js (app.js:1129:1) at __webpack_require__ (app.js:849:30) at fn (app.js:151:20) at eval (webpack-internal:///./src/main.js:12:65) at Module../src/main.js (app.js:1117:1) 解决 # 依次执行 yarn remove vue-router yarn add vue-router@3 --save # 即可解决 2.Vuecli@3中适用的less 以及less-loader \"less\": \"^3.13.0\", \"less-loader\": \"^7.1.0\", 版本过高报错 cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/less-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp;:1 Uncaught Error: Module build failed (from ./node_modules/less-loader/dist/cjs.js): TypeError: this.getOptions is not a function at Object.lessLoader (D:\\vscode\\vscode cache02\\19-project\\Vue\\shop-client\\node_modules\\less-loader\\dist\\index.js:19:24) at eval (webpack-internal:///./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/less-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp;:1:7) at Object../node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/less-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp; (http://localhost:8081/js/app.js:1116:1) at __webpack_require__ (http://localhost:8081/js/app.js:849:30) at fn (http://localhost:8081/js/app.js:151:20) at eval (webpack-internal:///./node_modules/vue-style-loader/index.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/less-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp;:4:15) at Object../node_modules/vue-style-loader/index.js?!./node_modules/css-loader/dist/cjs.js?!./node_modules/vue-loader/lib/loaders/stylePostLoader.js!./node_modules/postcss-loader/src/index.js?!./node_modules/less-loader/dist/cjs.js?!./node_modules/cache-loader/dist/cjs.js?!./node_modules/vue-loader/lib/index.js?!./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp; (http://localhost:8081/js/app.js:1138:1) at __webpack_require__ (http://localhost:8081/js/app.js:849:30) at fn (http://localhost:8081/js/app.js:151:20) at eval (webpack-internal:///./src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp;:2:504) at Module../src/components/Footer/index.vue?vue&amp;type=style&amp;index=0&amp;id=30c2788e&amp;lang=less&amp;scoped=true&amp; (http://localhost:8081/js/app.js:1232:1) 3.解决路由重复跳转的错误2022年4月21日14:36:44 报错信息 Uncaught (in promise) NavigationDuplicated: Avoided redundant navigation to current location: \"/search\". 解决方案 在 route.js 文件下添加如下代码 import Router from 'vue-router' // 缓存原本的push方法 const originalPush = Router.prototype.push // 指定新的push方法 Router.prototype.push = function push(location, onResolve, onReject) { // 如果指定了成功或失败的回调 if (onResolve || onReject) // 直接调用原本的push方法 // originalPush(this, location, onResolve, onReject) //this不是router而是undefined return originalPush.call(this, location, onResolve, onReject) // 没有指定成功或失败的回调，必须用catch处理 return originalPush.call(this, location).catch((err) => { // 如果是重复盗汗产生的错误，不再向外传递错误 if (Router.isNavigationFailure(err)) { // resolve err return err // 产生的成功的promise ， 成功promise的value是err } // 如果是其他原因盗汗的错误，将错误向下传递 // rethrow error return Promise.reject(err) }) } Vue 3.1.0版本后 https://github.com/vuejs/vue-router/releases?after=v3.3.1&amp;page=3 https://github.com/vuejs/vue-router/issues/2881 4.npm install –save vue&#x2F;types&#x2F;umd2022-5-9 18:12:46 报错信息 运行后 解决某个文件中引入了 import { xxx } from 'vue/types/umd' 删除即可 5.vuex模块化 modules报错 TypeError: Cannot read property 'cartList' of undefined 解决在 // 在modules中注册 modules:{ home, cart } Vue 运行报错vue项目运行报错：Module build failed (from ./node_modules/babel-loader/lib/index.js): 解决 npm install @babel/core @babel/preset-env Vue3 router报错 Cannot use 'in' operator to search for 'path' in undefined 解决 // 在路由文件里用错了createWebHashHistory()方法，将它用成了变量，只需要将它写成方法即可解决问题。 history:createWebHashHistory => history:createWebHashHistory() Vue3 setup 获取全局对象2022年7月11日00:20:49 import { getCurrentInstance} from \"vue\"; export default { name: \"approve\", setup(){ // Vue3中我们打印 getCurrentInstance 详细见下图 console.log(getCurrentInstance()); // 获取全局对象 const { $api, $message, $store } = getCurrentInstance().appContext.config.globalProperties; } } 总结 app.config.globalProperties.变量名 组件 setup 获取变量 getCurrentInstance().appContext.config.globalProperties.变量名 top await参考博客 https://bobbyhadz.com/blog/javascript-unexpected-reserved-word-await#:~:text=The%20%22unexpected%20reserved%20word%20await,directly%20enclosing%20function%20as%20async%20. https://blog.csdn.net/xgangzai/article/details/114314178 Nodenode服务器 启动 端口占用报错 Error: listen EACCES: permission denied 0.0.0.0:80 at Server.setupListenHandle [as _listen2] (net.js:1314:21) at listenInCluster (net.js:1379:12) at Server.listen (net.js:1465:7) at Application.listen (F:\\Program\\web\\web-app\\elm\\server\\node_modules\\koa\\lib\\application.js:82:19) at Object.&lt;anonymous> (F:\\Program\\web\\web-app\\elm\\server\\index.js:32:5) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1114:10) at Module.load (internal/modules/cjs/loader.js:950:32) at Function.Module._load (internal/modules/cjs/loader.js:790:12) at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:76:12) 6:12) Emitted 'error' event on Server instance at: at emitErrorNT (net.js:1358:8) at processTicksAndRejections (internal/process/task_queues.js:82:21) { code: 'EACCES', errno: -4092, syscall: 'listen', address: '0.0.0.0', port: 80 } 解决 更改端口 app.listen(); // 端口号 Koa1 Koa2报错 AssertionError: app.use() requires a generator function 解决 // 版本不兼容问题 koa-router7.x 不支持koa1 koa-router4.x 不能使用koa2 下载低版本的koa-router 或者更新 koa1 => koa2 搭建接口时报错 \"error\":\"Converting circular structure to JSON\\n --> starting at object with constructor 'NativeTopology'\\n | property 's' -> object with constructor 'Object'\\n | property 'sessionPool' -> object with constructor 'ServerSessionPool'\\n --- property 'topology' closes the circle\" 解决 未添加 async 或者 await DataBaseMongodb 服务启动失败报错 服务异常退出 错误代码1067 解决 删除journal文件 清除mongod.lock和storage.bson 重新启动服务 上面的无法实现 ,可以尝试下面的 删除服务 sc delete mongodb 删除journal文件 清除mongod.lock和storage.bson MongoDB服务删除并重新安装， 再尝试就发现已经可以正常启动了。 最佳解决方案 利用安装包进行修复 打开对应版本的安装包 选中Repair进行修复 解决问题 目前未发现它有什么弊端，数据保留完整。 小程序uniapp未配置 appidVM22 WAService.js:9 TypeError: Cannot read property 'forceUpdate' of undefined 解决 解决 Cannot read property 'forceUpdate' of undefined 的错误 这个错误的原因非常简单，是因为我们没有为项目配置 appID 的原因，所以只需要完成 APPID 配置即可。 语法错误: Unexpected token, expected “,” (1:543)10:47:43.127 Module build failed (from ./node_modules/@dcloudio/vue-cli-plugin-uni/packages/vue-loader/lib/loaders/templateLoader.js): 10:47:43.129 语法错误: Unexpected token, expected \",\" (1:543) 10:47:43.130 at pages\\index\\index.vue:1 错误原因 :class=&quot;active:navIndex === 0&quot; 解决 :class=&quot;&#123;active:navIndex === 0&#125;&quot; JAVAadmin 后台管理项目 | 本地运行 git clone githubaddress 数据库运行 .sql 文件 idea 以maven 导入项目 前端项目 yarn | npm install 运行 前端 yarn serve | npm run start 后端","categories":[{"name":"踩坑","slug":"踩坑","permalink":"https://blog.yyshino.top/categories/%E8%B8%A9%E5%9D%91/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://blog.yyshino.top/tags/webpack/"},{"name":"vue","slug":"vue","permalink":"https://blog.yyshino.top/tags/vue/"},{"name":"react","slug":"react","permalink":"https://blog.yyshino.top/tags/react/"}]},{"title":"Vue总结","slug":"Vue07","date":"2022-05-23T01:32:38.000Z","updated":"2022-09-16T10:33:59.529Z","comments":true,"path":"posts/51479.html","link":"","permalink":"https://blog.yyshino.top/posts/51479.html","excerpt":"","text":"vue插值语法 //vue差值语法 //{{}}中使用的数据必须在data中存在; //{{}} 虽然能够使用表达式， 不能出现js的语句，不能在{{}}中写if for; //{{}} 不能在属性中使用 Vue指令 v-text // 1.向其所在的节点中渲染文本内容。(更新元素的 textContent) //2.与插值语法的区别:v-text会替换掉节点中的内容，{{xx}}则不会。 v-html //向指定节点中渲染包含html结构的内容。(更新元素的 innerHTML) v-on //绑定事件 简写@ v-bind //单向数据绑定 ： v-model //双向数据绑定 //自动收集表单数据 &lt;input type=\"text\"/> //v-model默认收集的其实是你表单元素当中的value值 &lt;input type=\"radio\"/> //name相同时 单选框才会绑定在一组 //v-model默认收集的其实是你表单元素当中的value值,因此需要给radio添加value属性 &lt;input type=\"checkbox\" /> //1.没有配置input的value属性，那么收集的就是checked（勾选or未勾选，是布尔值) //2.配置input的value属性: //(1)v-model的初始值是非数组，那么收集的就是checked（勾选or未勾选，是布尔值) //(2)v-model的初始值是数组，那么收集的的就是value组成的数组 //备注: v-model的三个修饰符: //lazy:失去焦点再收集数据 //number:输入字符串转为有效的数字 v-for //列表渲染 // v-for=\"(item,index) in 遍历对象\" :key=唯一值(一般不用index) v-if //条件渲染 v-else v-show //条件渲染 // 1.如果需要频繁切换 v-show 较好 // 2.当条件不成立时, v-if的所有子节点不会解析(项目中使用) //注意 //v-for优先级高于v-if，当v-for和v-if放在同一标签上时，会先执行v-for，再执行v-if，这样会导致不符合v-if条件的元素也会被v-for ref //为特定的元素添加引用标识，实例的$refs内部可以获取到 v-cloak //防止闪现, 与css配合: [v-cloak] { display: none } 过渡&amp; 动画xxx-enter-active: 指定显示的transitionxxx-leave-active: 指定隐藏的transitionxxx-enter&#x2F;xxx-leave-to: 指定隐藏时的样式 Vue事件处理 v-on //绑定事件 简写@ // vue事件修饰符 prevent //阻止默认事件（常用）; stop //阻止事件冒泡（常用）; once //事件只触发一次（常用）; capture //使用事件的捕获模式; self //只有event.target是当前操作的元素是才触发事件; passive //事件的默认行为立即执行，无需等待事件回调执行完毕; Vue对象的选项el //指定dom标签容器的选择器 //Vue就会管理对应的标签及其子标签 data //对象或函数类型 //指定初始化状态属性数据的对象 //vm也会自动拥有data中所有属性 //页面中可以直接访问使用 //数据代理: 由vm对象来代理对data中所有属性的操作(读/写) //data为什么用函数 //不用function return每个组件的data都在内存的同一个地址，那一个data改变，就会影响其他组件的data //用function return相当于新建了个对象，分配新的内存地址，这样每个组件之间的data都是相互独立 methods //包含多个方法的对象 //供页面中的事件指令来绑定回调 //回调函数默认有event参数, 但也可以指定自己的参数 //所有的方法由vue对象来调用, 访问data中的属性直接使用this.xxx computed和watch computed计算属性 在computed属性对象中定义计算属性的方法 2)在页面中使用来显示计算的结果 3)computed有缓存，值不变不重新计算 4)computed内部只能是同步放回数据，不能异步放回数据 watch 1)通过通过vm对象的$watch()或watch配置来监视指定的属性 2)watch不支持缓存，有数据变化直接触发,当属性变化时, 回调函数自动调用, 在函数内部进行计算 3)watch支持异步获取数据 Vue生命周期 主要生命周期钩子1)mounted(): 发送ajax请求, 启动定时器等异步任务2)beforeDestory(): 做收尾工作, 如: 清除定时器 Vuex注册store import store from './store' new Vue({ store, // 注册vuex的store对象 ==> 所有组件对象都有一个$store属性 }) 核心概念 State state是一个包含多个属性（不是方法）的对象 &#x3D;&gt; 初始化存储数据 mapState辅助函数 mapState 函数返回的是一个对象，我们需要使用一个工具函数将多个对象合并为一个，以使我们可以将最终对象传给 computed 属性。但是自从有了对象展开运算符，我们可以极大地简化写法： computed: { // 使用对象展开运算符将此对象混入到外部对象中 ...mapState({ // ... }) } Mutation mutations也是一个对象，是一个包含了多个方法的对象 &#x3D;&gt; 直接操作数据的 里面的方法不能包含 if for 异步，是直接操作的 (纯函数) Action actions也是一个对象，是一个包含了多个方法的对象 &#x3D;&gt; vue当中用户的操作去关联的 Getter 可以认为是 store 的计算属性 mapGetters辅助函数 mapGetters 辅助函数可以是将 store 中的 getter映射到局部计算属性 computed: { // 使用对象展开运算符将 getter 混入 computed 对象中 ...mapGetters([ // getter当中的 计算属性 ]) } Module Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 Vuex推荐我们的项目结构 ├── index.html ├── main.js ├── api │ └── ... # 抽取出API请求 ├── components │ ├── App.vue │ └── ... └── store ├── index.js # 我们组装模块并导出 store 的地方 ├── actions.js # 根级别的 action ├── mutations.js # 根级别的 mutation └── modules ├── cart.js # 购物车模块 └── products.js # 产品模块 当我们想要访问cart.js中的state数据 shopCartList:state =&gt; state.shopcart.shopCartList vuex核心概念模板// 1、安装 // 2、引入并声明使用vuex插件 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) // 3、向外暴露一个store的实例化对象 const state = { // 代表初始状态数据 是一个包含n个属性（不是方法）的对象 } const mutations = { // 代表直接修改数据的数据 是一个包含n个直接修改状态数据方法的对象 （用来让action的行为调用） // 注意：只能通过mutations的方法去直接修改，也就是说要想写state数据必须通过mutations } const actions = { // 代表用户行为数据 是一个包含n个用户行为回调方法的对象，（用来映射组件用户的行为回调函数） } const getters = { // 代表计算属性数据 是一个包含n个计算属性的方法的对象 } export default new Vuex.Store({ // 包含了6个核心概念， // 现在讲4个 state, mutations, actions, getters }) // 4、将暴露出去的store实例化对象引入到实例化Vue的配置对象(main.js)当中使用 Vue-Router路由API定义配置路由 routes: [ { // 配置当前路由 path: '/current', component: Current, children: [ // 配置嵌套子路由 { path: 'children01', component: Children01 }, { path: 'children02', component: Children02 }, }, { // 自动跳转路由 path: '/', redirect: '/about' } ] 注册路由import Vue from 'vue' import router from './router' // 创建vue配置路由器 new Vue({ el: '#app', router, render: h => h(app) }) 使用路由 &lt;router-link&gt; 路由连接,跳转到to所指定的连接 参数 to:目标路由的链接 replace:导航后不会留下历史记录 active-class :链接激活时，应用于渲染的 &lt;a&gt; 的 class。 &lt;router-view&gt; 路由组件显示区域，就是组件需要在哪显示 声明式导航在浏览器中，点击链接实现导航的方式，叫做声明式导航。 像 &lt;a&gt; &lt;router-link to=&quot;&quot;&gt;都属于声明式导航 编程式路由导航 this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面) this.$router.back(): 请求(返回)上一个记录路由 this.$router.go(-1): 请求(返回)上一个记录路由 this.$router.go(1): 请求下一个记录路由 路由传递数据方法一：路由路径携带参数(param&#x2F;query)最原始的传参 参数：params参数,是属于路径的一部分 /xxx/10 query参数路径后使用?去拼接起来的 /xxx/ ? aa = bb &amp;&amp; xx = yy 方法2: &lt;router-view&gt;属性携带数据//路由链接组件传递数据给命名路由 //路由链接组件中给路由传参可以写成对象形式，前提需要给路由起名字name，也叫命名路由 &lt;router-view name='xxx' :msg=\"msg\">&lt;/router-view> 方法3:使用props简化路由传参给子组件操作（路由当中传参的三种操作） 1）布尔值 路由当中需要配置 props:true,只能接收params参数，它会把路由当中接收的参数，置为子组件的属性 2）对象 很少用，只能给子组件传递默认静态值 3）函数 用的比较多，比较灵活，可以把params和query的参数都映射为子组件的属性 props(route){ //route就是当前我这个路由对象 //把路由对象当中的参数，不管什么参数 //全部拿到作为子组件的属性去使用 return { msgId:route.params.msgId, msgContent:route.query.msgContent } } 路由守卫 全局路由守卫 router.beforeEach((to, from, next)=>{ //全局前置守卫，路由跳转前触发 }) router.beforeResolve((to, from, next)=>{ //全局解析守卫 在所有组件内守卫和异步路由组件被解析之后触发 }) router.afterEach((to, from)=>{ //全局后置守卫，路由跳转完成后触发 }) 路由独享守卫 beforeEnter((to,from,next)=>{ //路由对象单个路由配置 ，单个路由进入前触发 }) 组件路由守卫 beforeRouteEnter((to,from,next)=>{ //在组件生命周期beforeCreate阶段触发 }) beforeRouteUpdadte((to,from,next)=>{ //当前路由改变时触发 }) beforeRouteLeave((to,from,next)=>{ //导航离开该组件的对应路由时触发 }) 参数 to： 即将要进入的目标路由对象 from： 即将要离开的路由对象 next(Function)：是否可以进入某个具体路由，或者是某个具体路由的路径 应用 router.beforeEach：token校验 // 全局前置导航守卫 router.beforeEach // token校验 router.beforeEach(async (to, from,next) => { // 全局前置导航守卫 // to 代表准备驱动地方的路由对象 // from 从哪个地方来的路由对象 // next 是一个函数 // next() 代表无条件放行 // next(false) 代表不放行，停在原地 // next('/') next({path:'/'}) 代表最终让它去哪 // token校验 let token = store.state.user.token if(token){ // 代表登录了或者之前登录过 if(to.path === '/login'){ // 登录鼓励，又想去登录页，直接跳转到首页 next('/') }else{ // !! 转化为bool值 let hasuserInfo = !!store.state.user.userInfo.nickName if(hasuserInfo){ // 此时 代表登录了 ， 去的不是登录页，用户信息存在，直接无条件放行 next() }else{ // 此时代表登录了，去的不是登录页，用户信息不存在 那我们要根据token发请求获取用户真实信息 try { await store.dispatch('getUserInfo') next() } catch (error) { // 出现错误 跳转到login页面，并清楚用户信息 alert('用户的token过期') // 清空用户信息 store.dispatch('resetUserInfo') // 去到之前想去但是没有去成的地方，需要和登录逻辑去配合使用 next('/login?redirect='+to.path) } } } }else{ // 代表用户没登录或者之前也没有登录过 // 后期我们需要判断用户是不是订单相关的页面，如果是娜美就先登录 next() } }) beforeEnter：用于设置放行条件 //路由独享守卫 // 用于设置放行条件 { path:'/addcartsuccess', component:AddCartSuccess, 路由独享守卫 beforeEnter:(to,from,next) => { let skuNum = to.query.skuNum let skuInfo = sessionStorage.getItem('SKUINFO_KEY') // 如果skuNum 与 skuInfo 存在 则放行 if(skuNum &amp;&amp; skuInfo){ next() }else{ alert('必须带够参数') next('/') } } } 路由组件的单独打包import GroupOrder from '@/pages/Center/GroupOrder' // import from 这样的写法 // 一个是同步引入，从上往下依次执行引入 // 它不能动态引入 // 他是把所有的组件全部引入完成才执行下面的代码，webpack打包的时候会把所有的引入组件集体打包，打包成一个大文件 // 效率比较慢 const GroupOrder = () => import('@/pages/Center/GroupOrder') // import 函数可以让路由组件单独打包 还支付动态引入 // 写法很简单，路由组件在注册的时候可以是一个组件也可以是一个函数 // 写成函数时，当路由被访问的时候,对应的函数就会调用,然后对应的import函数才会执行，动态引入并打包成单独的文件 // 浏览器在运行的时候， 加载 解析 渲染 组件间通信1. 组件间多种通信方式: 组件间通信1: props 组件间通信2: vue自定义事件 组件间通信3: 事件总线 组件间通信4: v-model 组件间通信5: .sync 属性修饰符 组件间通信6: $attrs与$listeners 组件间通信7: $children与$parent 组件间通信8: provide与inject 组件间通信9: vuex 组件间通信10: 作用域插槽slot-scope 2. 组件间通信最基本方式: props 用来实现父子之间相互通信的最基本方式, 也是用得最多的方式 父 &#x3D;&#x3D;&gt; 子, 传递的是非函数类型的属性 子 &#x3D;&#x3D;&gt; 父, 传递的是函数类型的属性 问题: 其它关系的组件使用props就会比较麻烦 3. 组件间通信2: vue自定义事件1) 原生DOM事件 绑定原生DOM事件监听的2种情况 在html标签上绑定DOM事件名的监听 在组件标签上绑定DOM事件名的监听, 事件绑定在组件的根标签上 当用户操作对应的界面时, 浏览器就会自动创建并封闭包含相关数据的事件对象, 分发对应的事件, 从而触发事件监听回调函数调用 事件对象event, 本质是 “事件数据对象” event对象内的数据属性: target &#x2F; offsetX &#x2F; offsetY &#x2F; keyCode等 $event就是浏览器创建的event对象, 默认传递给事件监听回调函数的就是它 2) vue自定义事件 绑定vue自定义事件监听 只能在组件标签上绑定 事件名是任意的, 可以与原生DOM事件名相同 只有当执行$emit(‘自定义事件名’, data)时分发自定义事件, 才会触发自定义事件监听函数调用 $event: 就是分发自定义事件时指定的data数据 $event可以是任意类型, 甚至可以没有 用来实现子向父组件通信, 功能相当于函数类型的props 4. 组件间通信3: 事件总线 理解: Vue原型对象上有3个事件处理的方法: $on() &#x2F; $emit() &#x2F; $off() 组件对象的原型对象的原型对象是Vue的原型对象: 组件对象可以直接访问Vue原型对象上的方法 实现任意组件间通信 编码实现: 将入口js中的vm作为全局事件总线对象: beforeCreate() { Vue.prototype.$bus = this } 分发事件&#x2F;传递数据的组件: this.$bus.$emit(‘eventName’, data) 处理事件&#x2F;接收数据的组件: this.$bus.$on(‘eventName’, (data) &#x3D;&gt; {}) 5. 组件间通信4: v-model1) 原生input上的本质:动态的value属性与原生input事件监听 &lt;input type=\"text\" :value=\"name2\" @input=\"name2=$event.target.value\"> 2) 组件标签上的本质:动态的value属性与自定义input事件监听 // 父组件: &lt;CustomInput :value=\"name4\" @input=\"name4=$event\"/> // 子组件 props: ['value'] &lt;input type=\"text\" :value=\"value\" @input=\"$emit('input', $event.target.value)\"> 3) 利用v-model能做什么? v-model不仅能实现原生标签上的双向数据绑定, 也能实现父子组件间数据双向通信(同步) 应用 一般用于封装带表单项的复用性组件 elment-ui中: Input&#x2F;CheckBox&#x2F;Radio&#x2F;Select等表单项组件都封装了v-model 6. 组件间通信5: sync 属性修饰符1) 理解本质:绑定一个自定义事件监听, 用来接收子组件分发事件携带的最新数据来更新父组件的数据 &lt;child :money.sync=\"total\"/> &lt;Child :money=\"total\" @update:money=\"total=$event\"/> 2) 利用sync能做什么呢? 在原有父向子的基础上加上子向父通信 应用 常用于封装可复用组件(需要更新父组件数据) v-model一般用于带表单项的组件 sync一般用于不带表单项标签的组件 element-ui中: Dialog就利用sync来实现组件的隐藏 7. 组件间通信6: $attrs与$listeners1) 理解: $attrs: 排除props声明, class, style的所有组件标签属性组成的对象 $listeners: 级组件标签绑定的所有自定义事件监听的对象 v-bind: 的特别使用 &lt;div v-bind=\"{ id: someProp, 'other-attr': otherProp }\">&lt;/div> v-on: 的特别使用: &lt;button v-on=\"{ mousedown: doThis, mouseup: doThat }\">&lt;/button> 一般: v-bind与$attrs配合使用, v-on与$listeners配合使用 2) 使用它们能做什么呢? 在封装可复用组件时: HintButton 从父组件中接收不定数量&#x2F;名称的属性或事件监听 在组件内部, 传递给它的子组件 element-ui中: Input就使用了v-bind与$attrs来接收不定的属性传递给input 3) 扩展双击监听: @dblclick=&quot;add2&quot;绑定是自定义事件监听, 而el-button内部并没处理(没有绑定对应的原生监听, 没有分发自定义事件)双击时, 不会有响应 @dblclick.native=&quot;add2&quot;绑定的是原生的DOM事件监听, 最终是给组件的根标签a绑定的原生监听当双击a内部的button能响应, 因为事件有冒泡 8. 组件间通信7: $children与$parent1) 理解: $children: 所有直接子组件对象的数组, 利用它可以更新多个子组件的数据 $parent: 父组件对象, 从而可以更新父组件的数据 $refs: 包含所有有ref属性的标签对象或组件对象的容器对象 2) 利用它们能做什么? 能方便的得到子组件&#x2F;后代组件&#x2F;父组件&#x2F;祖辈组件对象, 从而更新其data或调用其方法 官方建议不要大量使用, 优先使用props和event 在一些UI组件库定义高复用组件时会使用$children和$parent, 如Carousel组件 3) 扩展: mixin 多个组件有部分相同的js代码如何复用 ? 答: 利用vue的mixin技术实现 本质: 实现Vue组件的JS代码复用, 简化编码的一种技术 9. 组件间通信8: provide与inject1) 理解用来实现祖孙组件直接通信 在祖组件中通过provide配置向后代组件提供数据 在后代组件中通过inject配置来读取数据 2) 注意:不太建议在应用开发中使用, 一般用来封装vue插件 provide提供的数据本身不是响应式的 ==> 父组件更新了数据, 后代组件不会变化 provide提供的数据对象内部是响应式的 ==> 父组件更新了数据, 后代组件也会变化 3) 应用:element-ui中的Form组件中使用了provide和inject 10. 组件间通信9: vuex 实现任意组件间通信 Vuex 是一个专为 Vue 应用程序设计的管理多组件共享状态数据的 Vue 插件任意组件都可以读取到Vuex中store的state对象中的数据 任意组件都可以通过dispatch()或commit()来触发store去更新state中的数据 一旦state中的数据发生变化, 依赖于这些数据的组件就会自动更新 11. 作用域插槽slot-scope1) 什么情况下使用作用域插槽? 父组件需要向子组件传递标签结构内容 但决定父组件传递怎样标签结构的数据在子组件中 2) 编码&lt;!: 子组件: > &lt;slot :row=\"item\" :$index=\"index\">&lt;/slot> &lt;!: 父组件: > &lt;template slot-scope=\"{row, $index}\"> &lt;span>{{$index+1}}&lt;/span> &amp;nbsp;&amp;nbsp; &lt;span :style=\"{color: $index%2===1 ? 'blue' : 'green'}\" >{{row.text}}&lt;/span> &lt;/template> 3) 应用 对于封装列表之类的组件特别需要 element-ui中: Table组件中就用到了slot-scope 我的微信公众号: https://mp.weixin.qq.com/s?__biz=Mzk0ODI5NjkzMw==&amp;mid=2247483655&amp;idx=1&amp;sn=d4413b68679e3aeab341cdaa3f860bc1&amp;chksm=c3688c8df41f059b39a44ae97a4059847a79d1c777f98f47dd76ba27460892a02b5abff0b3fd#rd","categories":[{"name":"Vue2","slug":"Vue2","permalink":"https://blog.yyshino.top/categories/Vue2/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"https://blog.yyshino.top/tags/Vue2/"}]},{"title":"Vue前台PC项目其三","slug":"Vue06","date":"2022-05-23T00:40:37.000Z","updated":"2022-09-13T08:41:05.486Z","comments":true,"path":"posts/24151.html","link":"","permalink":"https://blog.yyshino.top/posts/24151.html","excerpt":"","text":"优化相关swiper相关swiper轮播图影响多个页面 通过选择器可以指定哪个地方需要，但是不好 通过ref最好 swiper创建的时间应该是在页面列表创建之后才会有效果 静态页面是没问题的 静态页面不需要等待数据，因此monted完全可以去创建swiper 现在我们的数据是动态的，monted内部去创建，数据还没更新到界面上，因此无效 可以使用延迟定时器去创建 但是不好 使用watch + nextTick 去解决比较好 ​ Vue.nextTick 和 vm.$nextTick 效果一样 ​ nextTick是在最近的一次更新dom之后会立即调用传入nextTick的回调函数 /* 在列表数据已经有了,且已经更新显示了 数据变化后 ==> 同步调用监视的回调 => 最后异步更新界面 watch:监视bannerList，就可以知到有数据了 nextTick:界面更新后执行回调 */ watch:{ bannerList(){ //此时只是数据有了, 但界面还没用更新 // swiper对象必须在列表显示之后穿件才有效果 /* Vue.$nextTick(callback) 在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 */ this.$nextTick(() => { //在此次数据变化导致界面更新完成后执行回调 // DOM 更新了 new Swiper (this.$refs.swiper, { // direction: 'horizontal', // 垂直切换选项 loop: true, // 循环模式选项 autoplay:{ //自动轮播 delay:4000, disableOnInteraction:false //用户操作后是佛停止自动播放 }, // 如果需要分页器 pagination: { el: '.swiper-pagination', }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, }) }) } Floor当中的轮播没效果？ ​ 它是根据数据循环创建组件对象的，外部的floor创建的时候 ​ 所以数据肯定是已经获取到了，所以我们在mounted内部去创建swiper 定义可复用的轮播组件 ​ banner是在watch当中去创建swiper 因为组件创建的时候数据不一定更新 ​ floor是在mounted当中去创建swiper，因为内部组件创建的时候，数据已经存在了 Search优化根据分类和关键字进行搜索，解决在search组件内部再进行搜索的bug//真正到了搜索页面我们都要去解析拿到相关的参数 修改我们的搜索参数 //beforeMount 去同步更新data数据 //mounted 去异步发送请求 //在搜索页重新输入关键字或者点击类别不会再发送请求，因为mounted只会执行一次，需要监视路由变化 动态显示和删除选中的搜索条件发送请求 ​ 判断参数内部是否存在categoryName 存在就显示 ​ 判断参数内部是否存在keyword 存在就显示 ​ 点击事件，如果删除就把参数对应的数据清除，顺便发送新的请求 解决删除选中的搜索条件后路径不变的bug ​ 上面删除发送请求我们的请求路径还是不变 ​ 我们需要手动去push跳转到去除对应参数的新路由 // 在 Search组件 中的 removeCategory()和 removeKeyword()方法中添加 // this.$router.push({ //有历史记录 this.$router.replace({ // 无历史记录 name:'search', // params:this.$route.params, query:this.$route.query }) 响应式对象数据属性的添加和删除对象当中的属性数据更改会导致页面更改，响应式数据 添加： 错的：如果对象当中没有对应的属性数据： 直接添加一个属性，这个属性不是响应式的 因为vue只是在开始对对象当中的所有属性添加getter和setter，后期直接添加的没有 对的：我们需要使用Vue.set this.$set方法 这样的添加属性就是响应式的 必须对响应式对象添加属性 删除： 错的： 直接delete删除对象当中的属性，不会导致页面更改 因为响应式属性只是在检测属性值的改变而不是检测属性的删除 对的：我们需要使用Vue.delete this.$delete方法 除了删除，还添加了更新界面的操作","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"https://blog.yyshino.top/tags/Vue2/"}]},{"title":"Vue前台PC项目其二","slug":"Vue05","date":"2022-05-22T04:24:41.000Z","updated":"2022-09-16T10:34:06.692Z","comments":true,"path":"posts/15766.html","link":"","permalink":"https://blog.yyshino.top/posts/15766.html","excerpt":"","text":"Vue前台Pc项目其二获取ajax vuex vue-router数据等在上一篇Vue前台Pc项目其一 Search组件分析Search组件的结构Search组件 点我查看Search组件 Search的头部 (关键字展示区) SearchSelect (关键字选择区) Search的主要部分 (商品详细区) MyPagination (页码区) 初始化获取数据// 首先 在data中初始化数据 data(){ return{ options:{ category1Id: '', // 一级分类ID category2Id: '', // 二级分类ID category3Id: '', // 三级分类ID categoryName: '', // 分类名称 keyword: '', // 搜索关键字 // trademark: '', // 品牌: \"ID:品牌名称\" \"1:苹果\" props: [], // 商品属性的数组: [\"属性ID:属性值:属性名\"] [\"2:6.0～6.24英寸:屏幕尺寸\"] order: '1:desc', // 排序方式 1: 综合,2: 价格 asc: 升序,desc: 降序 \"1:desc\" pageNo: 1, // 页码 pageSize: 10, // 每页数量 } } } // 异步获取 商品数据 /* 异步获取商品列表 */ getShopList(page=1){ // 更新options中的pageNo this.options.pageNo = page // 发送搜索请求 this.$store.dispatch('getProductList',this.options) } // methods和computed中 获取vuex管理的接口数据 getShopList(page=1){ // 更新options中的pageNo this.options.pageNo = page // 发送搜索请求 this.$store.dispatch('getProductList',this.options) } ...mapGetters(['goodsList','total']) // 注意需要引入 mapGetters // 管理我们的关键字 // 利用 v-if 选择展示 关键字 &lt;ul class=\"fl sui-tag\"> &lt;li class=\"with-x\" v-if=\"options.categoryName\">{{options.categoryName}} &lt;i @click=\"removeCategory\">×&lt;/i> &lt;/li> &lt;li class=\"with-x\" v-if=\"options.keyword\">{{options.keyword}} &lt;i @click=\"removeKeyword\">×&lt;/i> &lt;/li> &lt;li class=\"with-x\" v-if=\"options.trademark\">{{options.trademark}} &lt;i @click=\"removeTrademark\">×&lt;/i> &lt;/li> &lt;li class=\"with-x\" v-for=\"prop in options.props\" :key=\"prop\">{{prop}} &lt;i @click=\"removeProp(index)\">×&lt;/i> &lt;/li> &lt;/ul> // 定义 设置和清除关键字的方法 /* 删除一个属性条件 */ removeProp(index){ // 删除props中index的元素 this.options.props.splice(index,1) // 重新请求获取数据列表 this.getShopList() }, /* 添加一个属性条件 */ addProp(prop){ const {props} = this.options // 如果已经存在条件数组中，不添加 if(props.includes(prop)) return // 向props数组添加一个条件字符串 子向父通信==>vue自定义事件 this.options.props.push(prop) // 重新请求获取数据列表 this.getShopList() }, /* 删除品牌条件 */ removeTrademark(){ // 更新options中的trademark为指定的值 // this.options.trademark = '' // delete this.options.trademark // ==> 不会导致界面更新 this.$delete(this.options,'trademark') // 重新请求获取数据列表 this.getShopList() }, /* 设置品牌条件 */ setTrademark(trademark){ // 如果当前品牌已经在条件中了，直接结束 if(trademark===this.options.trademark) return // 更新options中的trademark为指定的值 // this.options.trademark = trademark this.$set(this.options,'trademark',trademark) // 重新请求获取数据列表 this.getShopList() }, /* 删除分类的条件 */ removeCategory(){ // 更新分类相关数据u this.options.category1Id = '' this.options.category2Id = '' this.options.category3Id = '' this.options.categoryName = '' // 重新发起请求 // this.getShopList() // 重新跳转到search，不再携带删除的条件所对应的参数(query) // this.$router.push({ this.$router.replace({ name:'search', // query:this.$route.query, params:this.$route.params }) }, /* 删除关键字的条件 */ removeKeyword(){ // 更新分类相关数据u this.options.keyword = '' // 重新发起请求 // this.getShopList() // 重新跳转到search，不再携带删除的条件所对应的参数(params) // this.$router.push({ this.$router.replace({ name:'search', // params:this.$route.params, query:this.$route.query }) // 3) 在Search中分发事件 this.$bus.$emit('removeKeyword') }, /* 更新options中参数属性 */ updateParams(){ // 取出参数数据 const {keyword} = this.$route.params const {category1Id,category2Id,category3Id,categoryName} = this.$route.query // 保存到options中 this.options = { ...this.options, keyword, category1Id, category2Id, category3Id, categoryName } } // 管理排序相关 //在computed中添加 /* 得到包含当前分类项标识(orderFlag)和排序方式(orderType)的数组 */ orderArr(){ return this.options.order.split(':') } // 在methods中添加 /* 设置新的排序搜索 */ setOrder(orderFlag){ // 得到当前的排序项和排序方式 let [flag,type] = this.orderArr // 点击的是当前排序项：只需要切换orderType if(orderFlag===flag){ type = type ==='desc'?'asc':'desc' // console.log(type); }else{ // 点击的不是当前排序项： 更新orderFlag为指定的值，orderType更新为desc flag = orderFlag type = 'desc' } // 请求获取商品分页列表 this.options.order = flag + ':' + type this.getShopList() } 分页组件// MyPagination 组件 // Search父组件传递数据 同时初始化 页码数据 &lt;MyPagination :currentPage = \"options.pageNo\" :pageSize = \"options.pageSize\" :total = \"total\" :showPageNo = \"5\" @currentChange = \"getShopList\" >&lt;/MyPagination> // 接收数据 props:{ currentPage:{ type:Number, default:1 }, total:{ type:Number, default:0 }, pageSize:{ type:Number, default:10 }, showPageNo:{ type:Number, default:5, // 要求传的值要是奇数 validator:function(value){ return value%2 === 1 } }, }, data(){ return { myCurrentPage:this.currentPage, //初始值由父组件来指定 } } // 设计算法 换页 // computed 计算总页数 totalPages(){ const {total,pageSize} = this return Math.ceil(total/pageSize) } //计算首尾页 startEnd(){ let start,end const {myCurrentPage,showPageNo,totalPages} = this // 计算start /* 举例子 myCurrentPage,showPageNo,totalPages 4 5 8 23[4]56 start = 4-2 */ // start = myCurrentPage - (showPageNo-1)/2 start = myCurrentPage - Math.floor(showPageNo/2) // 如果myCurrentPage比较小，计算的结果可能小于1 start>=1 /* myCurrentPage,showPageNo,totalPages 4 5 8 [1]2345 */ if(start&lt;1){ start = 1 } // 计算end /* myCurrentPage,showPageNo,totalPages 4 5 8 23[4]56 start = 2 end = 2 + 5 - 1 */ end = start + showPageNo - 1 // end的最大值为totalPages /* myCurrentPage,showPageNo,totalPages 8 5 8 45[6]78 start = 6 ==> 4 end = 10 ==> 超过了totalPages 8 */ if(end>totalPages){ // 修改end 为 totalPages end = totalPages // 修正start start = end - showPageNo +1 // 一旦总页数小于最大连续页码数 ==> start&lt;1 /* myCurrentPage,showPageNo,totalPages 5 5 4 12[3]4 end = 4 start = 0 ===> 1 */ if(start&lt;1){ start = 1 } } return {start,end} } /* 包含从start到end的数组 */ startEndArr(){ const arr = [] const {start,end} = this.startEnd for(let page=start;page&lt;=end;page++){ arr.push(page) } return arr } 商品详情//Detail components: { ImageList, Zoom }, data(){ return { skuId:'', skuNum:1 } }, // 我们一般在beforeMount当中去处理数据 beforeMount(){ this.skuId = this.$route.params.skuId }, computed:{ ...mapGetters(['categoryView','skuInfo','spuSaleAttrList']), // categoryView(){ // return this.$store.getters.categoryView // } imgList(){ return this.skuInfo.skuImageList || [] } }, mounted(){ this.getSkuDetailInfo() }, methods:{ getSkuDetailInfo(){ this.$store.dispatch('getSkuDetailInfo',this.skuId) }, // 排它处理用户点击悬着销售属性值 (谁变绿) changeChecked(spuSaleAttr,spuSaleAttrList){ // 第一步：多有的属性值全部变白 spuSaleAttrList.forEach(item => item.isChecked = '0') // 第二步：点击的这个属性值变绿 spuSaleAttr.isChecked = '1' }, // 添加购物车按钮点击之后的逻辑 async addShopCart(){ // 发请求让后台给数据库的购物车数据表中添加一条数据 // 根据添加成功还是失败来决定要不要条状到添加购物车成功页面 let {skuId,skuNum} = this // this.$store.dispatch('addOrUpdateCart',{skuId,skuNum}) // action当中异步函数的返回值，异步函数范沪指一定是promis try { const result = await this.$store.dispatch('addOrUpdateCart',{skuId,skuNum}) alert('添加购物车成功') // 成功需要跳转 编程式导航跳转 // 因为下个页面 添加购物车成功页面需要 商品购物车成功页面需要 商品数量和商品详情信息 // 以后如果碰到的数据是简单数据，那么我们考虑路由传参 // 如果碰到数据是浮渣数据 那么我们考虑存储手段 // localStorage setItem getItem removeItem clear // sessionStorage setItem getItem removeItem clear // 区别：localStorage是永久存储 sessionStorage浏览器关闭就没了 // 序列化 将js数据转化为json数据 sessionStorage.setItem('SKUINFO_KEY',JSON.stringify(this.skuInfo)) this.$router.push('/addcartsuccess?skuNum='+ this.skuNum) } catch (error) { alert(error.message) } //const result = await this.$store.dispath('addOrUpdateCart'{skuId,skuNum}) // if(result === 'ok'){ // }else{ // } } } 放大镜大图与小图 交互 图片列表的点击切换样式 图片列表点击大图要跟着切换 组件通信index下标 放大镜 ​ 鼠标动 ​ 遮罩动 求遮罩的位置 设置遮罩的位置 ​ 大图动 大图反向移动遮罩的位置2倍 //Zoom组件 props:['imgList'], data(){ return { defaultIndex:0 //显示图片的默认下标s } }, mounted(){ this.$bus.$on('syncDefaultIndex',this.syncDefaultIndex) }, computed:{ defaultImg(){ // 1、解决家报错 不能在上面直接写 imgList[defaultIndex].imgUrl return this.imgList[this.defaultIndex] || {} } }, methods:{ syncDefaultIndex(index){ this.defaultIndex = index }, move(event){ // 添加移动事件。代表鼠标移动 // 获取鼠标位置 let mouseX = event.offsetX let mouseY = event.offsetY // 2、计算遮罩的位置让遮罩动 let mask = this.$refs.mask // 蒙版 let maskX = mouseX - mask.offsetWidth/2 let maskY = mouseY - mask.offsetHeight/2 let big = this.$refs.big // 限定临界值 if(maskX &lt; 0){ maskX = 0 }else if(maskX > mask.offsetWidth){ maskX = mask.offsetWidth } if(maskY &lt; 0){ maskY = 0 }else if(maskY > mask.offsetHeight){ maskY = mask.offsetHeight } mask.style.left = maskX +'px' mask.style.top = maskY +'px' // 3、大图动 大图向着鼠标相反方向移动两倍 big.style.left = -maskX * 2 + 'px' big.style.top = -maskY * 2 + 'px' } } //ImageList props:['imgList'], data(){ return{ defaulIndex:0, // 默认有橙色框框的图片下标 swiperOptions:{ // direction: 'horizontal', // 垂直切换选项 // loop: true, // 循环模式选项 // autoplay:{ //自动轮播 // delay:4000, // disableOnInteraction:false //用户操作后是佛停止自动播放 // }, // 如果需要分页器 // pagination: { // el: '.swiper-pagination', // }, slidesPerView: 4, slidesPerGroup:3, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, } } }, methods:{ changeDefaultIndex(index){ this.defaulIndex = index // 通过全局事件总线把选中的index传递给zoom this.$bus.$emit('syncDefaultIndex',index) }, } ShopCart mounted(){ this.getCartList() }, methods:{ // 重新发送请求 getCartList(){ this.$store.dispatch('getCartList') }, // 修改购物车中商品数量 async changeCartNum(shopCart,disNum,flag){ // 正对输入的数据是最终的商品熟练，我们得转化为变化的量 if(!flag){ // 输入正数表示用户 想要的数量 if(disNum > 0){ disNum = disNum - shopCart.skuNum }else{ disNum = 1-shopCart.skuNum } }else{ // 输入负数 //针对点击+-的数据，传递过来的是变化的量 if(disNum + shopCart.skuNum &lt;= 0){ disNum = 1 - shopCart.skuNum } } try { // 吧传递古来的数据全部转化为正确的变化的量之后就可以发起请求 // 修改数据库数据 await this.$store.dispatch('addOrUpdateCart',{skuId:shopCart.skuId,skuNum:disNum}) alert('修改数量成功') // 重新发起请求 this.getCartList() } catch (error) { alert(error.message) } }, // 修改购物车中商品的选中状态 async updateOne(shopCart){ try { await this.$store.dispatch('updateCartChecked',{skuId:shopCart.skuId,isChecked:shopCart.isChecked?0:1}) alert('修改状态成功') this.getCartList() } catch (error) { alert(error.message) } }, // 删除购物车单个 async deleteOne(shopCart){ try { await this.$store.dispatch('deleteCart',shopCart.skuId) alert('删除成功') this.getCartList() } catch (error) { alert(error.message) } }, // 删除购物车多个 deleteAll(){ try { this.$store.dispatch('deleteCartAll') alert('删除多个成功') this.getCartList() } catch (error) { alert(error.message) } } }, computed:{ // mapState使用数组 必须名字相同 数据只能总的state当中的数据才能使用，模块化后不能使用 ...mapState({ // shopCartList:state => state.shopcart.shopCartList[0].cartInfoList /* 出现意外问题 在购物车内刷新出现如下问题 TypeError: Cannot read properties of undefined (reading 'cartInfoList') */ shopCartList:state => state.shopcart.shopCartList }), /* 选择的数量 */ checkedNum(){ return this.shopCartList.reduce((prev,item) => { if(item.isChecked){ prev += 1 } return prev },0) }, /* 总共支付 */ allMoney(){ return this.shopCartList.reduce((prev,item) => { if(item.isChecked){ prev += item.cartPrice * item.skuNum } return prev },0) }, /* 判断全选 可读 可写 */ isAllCheck:{ get(){ return this.shopCartList.every(item => item.isChecked) }, async set(val){ // this.$store.dispatch('updateCartChecked',cal?1:0) 是调用updateCartCheckedAll异步函数 // 它的结果拿的是异步函数的返回值 固定的那个promise，不是函数return后面Promise.all的返回值promise try { const result = await this.$store.dispatch('updateCartCheckedAll',val?1:0) alert('修改所有数据成功') this.getCartList() } catch (error) { alert(error.message) } } }, } 交易订单 Trade data(){ return { message:'', orderNo:'' } }, mounted(){ // 定义函数 this.getTradeInfo() this.getAddress() }, methods:{ getTradeInfo(){ this.$store.dispatch('getTradeInfo') }, getAddress(){ this.$store.dispatch('getAddress') }, // 修改默认收获地址,排它 changeDefault(userAddress,userAddressList){ userAddressList.forEach((item => item.isDefault = '0')) userAddress.isDefault = '1' }, // 提交订单 不使用vuex async submitOrder(){ // 带上交易编号和交易信息发送请求穿件订单 let tradeNo = this.tradeInfo.tradeNo let tradeData = { consignee:this.defaultUserAddress.consignee, consigneeTel:this.defaultUserAddress.phoneNum, deliveryAddress:this.defaultUserAddress.userAddress, paymentWay:\"ONLINE\", orderComment:this.message, // 购物车的详细信息 detailArrayList orderDetailList:this.detailArrayList }; try { const result = await this.$API.reqSubmitOrder(tradeNo,tradeData) if(result.code === 200){ // this.orderNo = result.data // 这里是是存储订单编号，存不存都行。因为订单编号是要带到下个页面的 this.$router.push('/pay?orderNo='+result.data) } } catch (error) { alert('提交失败，错误信息：'+error.message) } } }, /* */ computed:{ // userAddressList 接口损毁 ...mapGetters(['detailArrayList']), ...mapState({ tradeInfo:state => state.trade.tradeInfo || {}, // mock 模拟userAddressList接口 userAddressList:state => state.trade.userAddressList || [] }), // 计算最终确定的用户信息，更具上面点击修改默认而发送变化的 defaultUserAddress(){ return this.userAddressList.find(item => item.isDefault === '1') || {} } } 支付Pay data(){ return { orderNo:'', payInfo:{}, payStatus:0 } }, beforeMount(){ this.orderNo = this.$route.query.orderNo }, mounted(){ this.getPayInfo() }, methods:{ async getPayInfo(){ const result = await this.$API.reqPayInfo(this.orderNo) if(result.code === 200){ this.payInfo = result.data } }, // 1、点击按钮能够弹出消息盒子 // 2、、生成二维码图片（请求回来的支付信息当中包含了一个生成二维码的所有的数据并不是图片url(微信给我们的一个数据)） // 3、轮询 async pay(){ // 1、点击立即支付后，先生成二维码 try { const imgUrl = await QRCode.toDataURL(this.payInfo.codeUrl) // 2、 生成二维码url成功之后，再去弹出消息盒子 this.$alert(`&lt;img src=\"${imgUrl}\"/>`, '请使用微信扫码支付', { dangerouslyUseHTMLString: true, showClose:false, showCancelButton:true, cancelButtonText:'支付遇到问题', confirmButtonText:'我已经成功支付', center:true, beforeClose:(action,instance,done) => { if(action === 'confirm'){ // 点击确认按钮的逻辑 // if(this.payStatus !== 200){ // // success 代表成功 绿色 // // error 代表失败错误 红色 // // warning 代表警告 橙色 // // info 代表提示 灰色 // this.$message.success('请确保支付成功，支付成功会自动跳转') // } // 后门 clearInterval(this.timer) this.timer = null done() this.$router.push('/paysuccess') }else if(action === 'cancel'){ this.$message.error('请联系前台小姐姐') // 点击取消按钮的逻辑 // 清除定时器 clearInterval(this.timer) this.timer = null done() } } }) // .then() //点击了确认按钮后的操作 // .catch(); //点击了取消按钮后的操作 // 无论是点击确认按钮还是点击取消按钮，都会强制的关闭messageBox // 3、设置循环定时器(轮询),发送请求看用户对于这个订单是否支付成功 if(!this.timer){ this.timer = setInterval(async () => { const result = await this.$API.reqPayStatus(this.orderNo) if(result.code === 200){ // 4、如果支付成功 // 1)跳转支付成功页面 // 2)清除定时器 // 3)关闭消息盒子 // 4)存储支付成功的状态 是为了后期用户点击按钮的时候的判断依据 this.payStatus = 200 clearInterval(this.timer) this.timer = null this.$msgbox.close() //关闭消息盒子 this.$router.push('/paysuccess') } },2000) } } catch (err) { // 生成失败，不需要弹出 console.error(err) } } } // 支付成功 &lt;router-link class=\"btn-look\" to=\"/center\">查看订单&lt;/router-link> &lt;router-link class=\"btn-goshop\" to=\"/\">继续购物&lt;/router-link> Login 和 Register//Login data(){ return { phone:'', password:'' } }, methods:{ async login(){ // 获取用户数据 let {phone,password} = this if(phone&amp;&amp;password){ try { // 发请求 /* 13700000000 111111 */ await this.$store.dispatch('userLogin',{phone,password}) alert('登录成功，准备跳转首页') // 下面的需要和导航守卫配合去到想去而没有去到的地方 let redirect = this.$route.query.redirect || '/' this.$router.push(redirect) } catch (error) { alert(error.message) } } } } //Register data(){ return { phone:'', code:'', password:'', password2:'', isCheck:'' } }, methods:{ async register(){ const success = await this.$validator.validateAll() // 对所有表单项进行验证 if(success){ // 获取用户信息 let {phone,code,password,password2} = this // if(phone &amp;&amp; code &amp;&amp; password &amp;&amp; password2 &amp;&amp; password === password2){ try { // 发请求注册用户 await this.$store.dispatch('userRegister',{phone,code,password}) alert('注册成功') this.$route.push('/login') }catch(error) { alert(error.message) } // } } } }","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"https://blog.yyshino.top/tags/Vue2/"}]},{"title":"Vue前台PC项目其一","slug":"Vue04","date":"2022-05-20T07:22:56.000Z","updated":"2022-09-16T10:34:10.168Z","comments":true,"path":"posts/33425.html","link":"","permalink":"https://blog.yyshino.top/posts/33425.html","excerpt":"","text":"Vue前台PC 来源b站尚硅谷点我跳转 项目以实现目标为主 优化留到最后 问题汇总 vue版本 2.6.11,如果没有vue-template-compiler需要安装（用于 模板编译） eslint错误级别禁用 在vue.config.js中 lintOnSave:false , 引入 less预编译器,让vue能够识别less &lt;style lang=\"less\" scoped> &lt;/style> 项目文件夹 publicsrc api &#x2F;&#x2F;发送请求相关 ajax.js &#x2F;&#x2F;axios二次封装 index.js &#x2F;&#x2F;包含应用的所有接口的接口请求函数 mockAjax.js &#x2F;&#x2F;mock模拟接口函数 assets &#x2F;&#x2F;外部资源components &#x2F;&#x2F;普通组件mock &#x2F;&#x2F;mock模拟接口pages &#x2F;&#x2F;路由组件plugins &#x2F;&#x2F;插件 element.js &#x2F;&#x2F;element-ui插件 swiper.js &#x2F;&#x2F;swiper轮播图 vaildate.js &#x2F;&#x2F; 表单验证插件的配置文件 router &#x2F;&#x2F;注册路由相关 index.js &#x2F;&#x2F;路由器对象 routes.js &#x2F;&#x2F;所有路由匹配的数组 store &#x2F;&#x2F;vuex modules &#x2F;&#x2F;各 组件小模块 index.js &#x2F;&#x2F;vuex最核心的管理对象store utils &#x2F;&#x2F;工具包App.js &#x2F;&#x2F;Appmain.js &#x2F;&#x2F;主函数 package.jsonvue.config.js 开始工作观察页面确定页面主体框架 所有的功能页面都是 上中下结构 上和下是不变化的，只有中间在变化Home组件 结构点我查看Home组件结构 第一个大组件 Home 组件 由上往下 HeaderHome TypeNavListContainerTodayContainerRankLikeFloorFloorFloor Footer 拆分组件 拆分静态组件 &#x3D;&#x3D;&gt; 普通组件和路由组件（） 普通组件 &#x3D;&#x3D;&gt; 局部注册 或 全局注册(main.js中注册) 路由组件 &#x3D;&#x3D;&gt; 在routes 当中注册 &lt;a&gt;&gt;标签 替换为 &lt;router-link&gt; router-view选定路由组件展示区域 获取数据 二次封装axios ajax.js /* axios二次封装 1. 配置通用的基础路径和超时 2. 显示请求进度条 3. 成功返回的数据不再是response, 而直接是响应体数据response.data 4. 统一处理请求错误, 具体请求也可以选择处理或不处理 */ import axios from \"axios\"; import NProgress from \"nprogress\"; import 'nprogress/nprogress.css' import store from '@/store' /*1. 配置通用的基础路径和超时 */ // service是一个能任意ajax请求的函数，当然可以作为对象使用 const service = axios.create({ // http://gmall-h5-api.atguigu.cn/api/product/getBaseCategoryList baseURL:'http://gmall-h5-api.atguigu.cn/api', // 基础路径 timeout:20000, //超时事件 }) // 添加请求拦截器 service.interceptors.request.use((config)=>{ /* 2.显示请求进度条 */ // 显示请求进度条: 在请求拦截器中 NProgress.start() let userTempId = store.state.user.userTempId if(userTempId){ config.headers.userTempId = userTempId } // 携带登录后标识token let token = store.state.user.token if(token){ config.headers.token = token } // 必须返回config return config //后面会根据返回的config,使用xhr对象发ajax请求 }) // 添加响应拦截器 service.interceptors.response.use( response => { //请求成功的返回的回调 // 隐藏请求进度条: 在响应拦截器的成功的回调中 NProgress.done() /* 成功返回的数据不再是response，而直接是响应体数据response.data */ return response.data }, error => { //请求失败的返回的回调 // 隐藏请求进度条: 在响应拦截器失败的回调中 NProgress.done() /* 4.统一处理请求错误,具体请求也可以选中处理或不处理 */ alert(error.message || '未知的请求错误') // return new Promise(() => {}) // return error // 不能这么写 // throw error //抛出错误 return Promise.reject(error) //返回一个失败的Promise, 并将错误传递下去 } ) // service.get('./xxx').then((result) => { // // const result = response.data // }).catch(( error ) => { // // 做一些提示之外的特定工作 // }) // 向外暴露 service export default service 阅读接口文档 postman工具测试接口 postman是用来测试API接口的工具 postman也是一个活接口文档 使用步骤(1) 启动 =&#x3D;=&gt; 选择登陆==&gt; cancel ==&#x3D;&gt; 进入主界面(2) 输入url&#x2F;参数进行请求测试(3) 注意post请求体参数需要指定为json格式(4) 保存测试接口 &#x3D;&#x3D;&gt; 后面可以反复使用 接口函数 所有接口的请求函数模块，我们定义一个index.js去写 以后请求什么数据直接导入去调函数就可以示例index.js /* 包含所有接口请求函数的模块 */ import ajax from './ajax' //获取商品的三级分类列表 export const reqBaseCategoryList = ()=>ajax.get('/product/getBaseCategoryList') 发送请求 &#x3D;&#x3D;&gt; 产生跨域 解决跨域vue.config.js//配置代理服务器 devServer: { proxy: { '/api': { // 只对请求路由以/api开头的请求进行代理转发 target: 'http://182.92.128.115', // 转发的目标url changeOrigin: true // 支持跨域 // pathRewrite: {‘^/api’: ‘’} } } 是否用到 vuex管理数据 vuex 以home组件为例 在store中 异步ajax获取数据 store/modules/home.js ( 如下代码) /* vuex管理的home模块 */ import {reqBaseCategoryList} from '@/api' const state = { baseCategoryList: [], // 所有分类的数组 } const mutations = { /* 接收保存分类列表 */ RECEIVE_BASE_CATEGORY_LIST(state, list) { state.baseCategoryList = list } } const actions = { /* 异步获取商品三级分类列表 */ async getBaseCategoryList({ commit }) { const result = await reqBaseCategoryList(); if (result.code === 200) { commit('RECEIVE_BASE_CATEGORY_LIST', result.data) } }, } const getters = { } export default { state, actions, mutations, getters } 在组件中 dispatch mapState 和 mapGetters /* mapState,mapGetters是 vuex提供给我们的辅助函数 mapState 辅助函数帮助我们生成计算属性 mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性： */ // 必须先引入 import {mapState,mapGetters} from 'vuex' //计算属性中 ...mapGetters(['detailArrayList']), ...mapState({ tradeInfo:state => state.trade.tradeInfo || {}, // mock 模拟userAddressList接口 userAddressList:state => state.trade.userAddressList || [] }) 不使用vuex 将状态直接定义在当前组件当中 异步ajax发送获取数据 mock模拟数据接口 安装 npm install mockjs 文档 mock-doc mock-github web前台 后台向前台提供API接口, 只负责数据的提供和计算，而完全不处理展现 前台通过Http(Ajax)请求获取数据, 在浏览器端动态构建界面显示数据 理解JSON数据结构a. 结构: 名称, 数据类型b. valuec. value可以变, 但结构不能变 利用axios 封装mock 接口函数 mockAjax与ajax只在基础baseUrl上有区别 // 只需要将原来的替换 即可 baseURL:'http://gmall-h5-api.atguigu.cn/api' ==> baseURL:'/mock' 在mockSever.js中 书写接口函数（格式如下） /* 利用mockjs提供mock接口 */ import Mock from 'mockjs' import recommends from './recommends.json' import floors from './floors.json' import ranks from './ranks.json' import likes from './likes.json' import banners from './banners.json' import address from './address.json' // 提供今日接口 Mock.mock('/mock/recommends',{code:200,data:recommends}) // 提供楼层接口 Mock.mock('/mock/floors',{code:200,data:floors}) Mock.mock('/mock/ranks',{code:200,data:ranks}) Mock.mock('/mock/likes',{code:200,data:likes}) Mock.mock('/mock/banners',{code:200,data:banners}) Mock.mock('/mock/address',{code:200,data:address}) console.log('MockServer()'); 展示数据 普通数据 v-if v-for :(v-bind) @(click) 需传递数据 //组件通信 //1. props 组件通信的方式 //父 => 子 //父组件中 &lt;Xxx :data= \"data\"/> //子组件接收数据 props:{ data:数据类型 } //2. vue自定义事件 // 子 => 父 // 在当前组件绑定自定义事件 mounted(){ // xxxXxx为分发的事件 this.$xxx.$on('xxxXxx',this.xxxXxx) // 使用 $once只能触发一次 // this.$xxx.$once('xxxXxx',this.xxxXxx) } // 在子组件当中适当的位置去触发事件并传递参数 // $emit(),在子组件当中去触发，子组件对象触发 // xxx 为传递的数据 this.$emit('addComment',xxx) //3. 通信方式 全局事件总线 // 任意情况 // 两个条件 // - 1、所有的组件对象都能找到它 // - 2、可以调用$on和$emit // 在主函数 vue 的对象中 beforeCreate(){ // 1) 创建或指定事件总线对象，保存到Vue的原型上 Vue.prototype.$bus = this } //剩余操作 同 2 //4. 通信方式 slot插槽 // 组件可多次复用时使用 //消息订阅(subscribe)与发布(publish) [一般不用，因为有全局事件总线] 中点站工作流程拆分静态组件 &#x3D;&gt; 通过ajax.js书写接口函数获取数据 &#x3D;&gt; 利用vuex管理数据(数据少时也可以直接在当前组件中) &#x3D;&gt; 自定义事件&#x2F;通过vue指令 &#x3D;&gt; 传递&#x2F;渲染数据到页面 通过上述的工作流程，我们已经可以解决绝大多数问题 由组件的视角我们需要 Footer组件以及Header组件（ajax + vuex + v-for） Home的部分子组件 TypeNav //TypeNav需要在 Home以及Search 下都需要使用 => 在main.js中定义为全局组件 //引入 import TypeNav from '@/components/TypeNav' // 注册全局组件 Vue.component(TypeNav.name,TypeNav) // 当点击TypeNav时我们需要跳转到搜索页面(携带参数),并且隐藏一级列表 //在data中定义标识 数据 currentIndex isShowFirst currentIndex:-2 // 默认为-2 表示当前选中的商品分类 商品分类有0-15 isShowFirst:path === '/' // bool 表示当前是否为 首页 //path为vue-router 指定的当前路径this.$route.path //定义方法改变 /* 隐藏一级列表 */ hideFirst(){ // 标识当前已经离开包含分类div了 this.currentIndex=-2 // 如果当前不是首页，隐藏一级列表 if(this.$route.path !== '/'){ this.isShowFirst = false } }, /* 显示一级列表 */ showFirst(){ // 标识当前已经进入包含分类div了 this.currentIndex = -1 //保证显示一级列表 this.isShowFirst = true } /* 显示指定下标的子分类列表 */ // showSubList:_.throttle((index) => { //不可以，原因在于箭头函数没有自己的this，且不能通过bind来指定特定的this showSubList:throttle(function(index) { //这个事件监听回调函数调用的频率太高 console.log('throttle',index); // 只有当还没有离开整个分类的div是才更新下标 if(this.currentIndex !== -2) this.currentIndex = index; },60,/* { trailing:'false' //最后一次事件不延迟处理 } */) // 定义搜索方法 toSearch(event) { const target = event.target; console.dir(target); const { categoryname, category1id, category2id, category3id } = target.dataset; // if(target.tagName.toUpperCase() === 'A'){ if (categoryname) { //准备query参数 // categoryName=图书、影像、电子书刊&amp;category1Id=1 const query = { categoryName: categoryname, }; if (category1id) { query.category1Id = category1id; } else if (category2id) { query.category2Id = category2id; } else if (category3id) { query.category3Id = category3id; } // 准备一个用跳转的对象 const location = { name:'search', query, params:this.$route.params //需要携带上当前已有params参数 } // 跳转到search /* 从其他到搜索页：push() 从搜索到搜索页：replace() */ if(this.$route.name === \"search\"){ //当前是搜索 this.$router.replace(location) }else{ this.$router.push(location); } // 隐藏一级列表 this.hideFirst() } } ListContainer // banner轮播图数据 由接口获取 // template数据展示 &lt;swiper :options=\"swiperOptions\"> &lt;swiper-slide class=\"swiper-slide\" v-for=\"banner in bannerList\" :key=\"banner.id\"> &lt;img :src=\"banner.imageUrl\" /> &lt;/swiper-slide> &lt;div class=\"swiper-pagination\" slot=\"pagination\">&lt;/div> &lt;div class=\"swiper-button-prev\" slot=\"button-prev\">&lt;/div> &lt;div class=\"swiper-button-next\" slot=\"button-next\">&lt;/div> &lt;/swiper> // 利用 swiper 展示轮播图 // data中定义 swiperOptions:{ // direction: 'horizontal', // 垂直切换选项 loop: true, // 循环模式选项 autoplay:{ //自动轮播 delay:4000, disableOnInteraction:false //用户操作后是佛停止自动播放 }, // 如果需要分页器 pagination: { el: '.swiper-pagination', }, // 如果需要前进后退按钮 navigation: { nextEl: '.swiper-button-next', prevEl: '.swiper-button-prev', }, } 具体可查看swiper官网 TodayRecommend Rand Like Floor 后台获取数据 &#x3D;&gt; 展示(v-for)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"https://blog.yyshino.top/tags/Vue2/"}]},{"title":"Vue源码分析","slug":"Vue03","date":"2022-05-20T05:52:41.000Z","updated":"2022-09-13T08:41:26.009Z","comments":true,"path":"posts/41718.html","link":"","permalink":"https://blog.yyshino.top/posts/41718.html","excerpt":"","text":"Vue源码分析对Vue源码，本人也在学习当中下面是一些github上大佬的解析 关于 Vue.js是一款MVVM框架，上手快速简单易用，通过响应式在修改数据的时候更新视图。- Vue.js的响应式原理依赖于Object.defineProperty，尤大大在Vue.js文档中就已经提到过，这也是Vue.js不支持IE8 以及更低版本浏览器的原因。Vue通过设定对象属性的 setter&#x2F;getter 方法来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。————github 剖析github上某基友仿vue实现的mvvm库地址","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"}],"tags":[{"name":"Vue3","slug":"Vue3","permalink":"https://blog.yyshino.top/tags/Vue3/"}]},{"title":"Vue进阶","slug":"Vue02","date":"2022-05-18T08:31:55.000Z","updated":"2022-09-13T08:41:28.767Z","comments":true,"path":"posts/4795.html","link":"","permalink":"https://blog.yyshino.top/posts/4795.html","excerpt":"","text":"Vue脚手架创建 1) 创建脚手架4/3的vue项目, 并运行 npm install -g @vue/cli 安装脚手架4/3的版本 vue create vue-demo 使用安装的脚手架创建一个新的vue项目 npm run serve 运行创建的项目命令 2) 创建脚手架2的vue项目 npm install -g @vue/cli-init vue init webpack vue-demo npm run dev eslint禁用1、局部禁用 // 局部禁用某个错误提示 /* eslint-disable no-unused-vars */ 2、全局禁用 //package.json当中找到eslintConfig项，全局配置禁用某些错误提示 \"rules\": { \"no-unused-vars\":\"off\" } 3、关闭 //开发阶段直接关闭eslint的提示功能 手动创建vue.config.js module.exports = { // 写自己想要配置的东西去覆盖系统自带的 // 关闭ESLint的规则 lintOnSave: false } vue模板解析 Vue渲染两种方式： ​ 1、render：h => h(App) ​ 2、components注册组件，template解析，但是vue导入需要导入带解析器的版本 模块化与组件化概念模块1)理解: 向外提供特定功能的js程序, 一般就是一个js文件2)为什么: js代码更多更复杂3)作用: 复用js, 简化js的编写, 提高js运行效率 组件1)理解: 用来实现特定(局部)界面功能效果的代码集合(html&#x2F;css&#x2F;js&#x2F;image)2)为什么: 一个界面的功能很复杂3)作用: 复用编码, 简化项目编码, 提高运行效率 模块化当应用的js都以模块来编写的, 这个应用就是一个模块化的应用 组件化当应用是以多组件的方式实现, 这个应用就是一个组件化的应用, 应用的开发方式就是组件化的 组件化开发分两大步：静态页面实现 和 动态交互实现 静态页面实现： 拆分组件 拆分页面 定义组件 最大化重用（html,css,图片） 组装组件 就是把各个组件组装起来放在App.vue里面 渲染组件 就是把组件拼装完后，不考虑数据，先展示出来 动态组件界面： 初始化数据动态显示 初始化数据分析 数据类型 一般我们的数据最终都是放在一个数组内部，数组内部放对象 数据名称 comments:[{},{},{}] 定义组件的原则 数据用到不是说展示就代表用，而是说数据的增删改查都叫用到数据 如果这个数据只是某一个组件用的，那么数据就在这一个组件当中定义 如果这个数据在某些个组件当中用的，那么就找这些个共同的祖先组件去定义 注意：组件标签名和属性名大小写问题： 基本规则：要么原样去写，要么转小写中间用-连接 AddComment &lt;AddComment/> 或者 &lt;add-comment> 用户的交互 对于数据的操作： 数据在哪，操作数据的方法就要在哪定义，而不是随便的在某一个组件当中去操作数据 想要操作数据的组件，可以通过调用操作数据的方法，间接去操作数据 添加和删除： 子组件添加事件和事件回调，事件回调当中去调用外部操作数据的方法 数据所在的组件去添加操作数据的方法 组件化编码的基本规范 子组件里面不要去更新父组件当中的数据1、分析数据在哪个组件2、数据在哪个组件，那么更新数据的行为（方法）就在哪个组件3、父组件的数据传递给子组件，是用来让子组件读取显示使用的，而不是让子组件去修改的（可以但是不该）4、子组件需要更新数据，那么需要调用父组件传递过来的更新数据方法 组件的使用 模板页面 &lt;template> // 页面模板 &lt;/template> // 2)JS模块对象 &lt;script> export default { data() {return {}}, methods: {}, computed: {}, components: {} } &lt;/script> // 3)样式 &lt;style> // 样式定义 &lt;/style> vue组件通信方式 组件关系 父子 兄弟 祖孙 其它 1. props 组件通信的方式： 是组件通信最常用最简单的一种方式,最基础的通信，用的也比较多 父可以给子传递函数数据和非函数数据​ 1. 传递非函数数据，本质就是父亲给儿子传数据​ 2. 传递函数数据，本质是父亲想要儿子的数据，通过函数调用传参的方式把数据传递给父亲 使用场合： 父子最好父向非子后代传递，必须逐层去传递 麻烦不是父子关系的组件，必须借助相同的父组件去通信 麻烦 不足（不是父子就狠麻烦） 兄弟关系，就必须先把一个数据给了父亲，然后通过父亲再给另一个 2. vue自定义事件 a. $on(eventName, listener): 绑定自定义事件监听 b. $emit(eventName, data): 分发自定义事件 c. $off(eventName): 解绑自定义事件监听 d. $once(eventName, listener): 绑定事件监听, 但只能处理一次 - 事件类型 : 无数个 回调函数 ： 谁调用 （自己调用） 调用时候默认的参数 （有可能有也可能没有 如果调用时候传了参数，默认参数就有 如果没有传，那就没有（undefined）） 使用方法 父组件当中去给子组件对象绑定事件监听 @直接在组件标签对象当中去绑定，和绑定系统事件一致 $on，在mounted当中去绑定，但是需要获取到子组件标签对象（通过ref指定，然后获取到） $once()和$on()类似，但是只能触发一次 在子组件当中适当的位置去触发事件并传递参数 $emit(),在子组件当中去触发，子组件对象触发 $off()可以在销毁之前解绑事件 适用场合 子向父传递数据，其余情况都不能用 3. 通信方式 全局事件总线 事件总线(对象)满足的两个条件： 1、所有的组件对象都能找到它 2、可以调用$on和$emit 原理 本身自定义事件可以完成子向父之间的传递，因为父组件中可以看到子组件，可以为子组件绑定事件，子组件中可以触发事件但是如果不是子向父，那么其余的就没办法了，因为两个组件互相是看不到的，没办法再其中一个给另外一个绑定事件此时我们可以借助中间人，也就是他们都可以同时看到的一个人，就是全局事件总线（所有的组件对象都能看到 在接收数据的组件中，获取总线绑定事件在发送数据的组件中，获取总线触发事件 使用 全局事件总线说到底就是个对象，我们通常就是用vm对象作为全局事件总线使用,把vm对象添加到Vue原型对象 就形成全局事件总线（vm） 示例 new Vue ({ beforeCreate() { Vue.prototype.$bus = this //配置总线 就是把vm挂到Vue的原型上，让所有的组件对象都能找到他，进而调用$on和$emit }, el:'#app', render:h => h(App) }) 适用场合： 任何场合 4. 通信方式 slot插槽 简介 一个组件会多次使用，但是又有少部分结构数据会发生变化，（当然可以用不同的子组件）那么就得通过父组件告诉子组件变化的内容是什么，此时就要用到这个插槽 子组件当中其实就是占位用的，让父组件给它填充内容，可以带标签 默认插槽和具名插槽 &lt;template> &lt;div> &lt;!--vue当中内置的组件标签 --> &lt;slot> &lt;!-- 默认插槽 --> &lt;!-- slot内部的东西 是等待着父组件使用的时候给传递过来的 --> &lt;span>嘿嘿&lt;/span> &lt;/slot> ​ &lt;slot name=\"xxx\"> ​ &lt;!-- 具名插槽 --> ​ &lt;/slot> ​ &lt;/div> &lt;/template> 作用域插槽 子组件的slot可以通过 属性传递值给父组件，然后父组件可以根据不同需求改变这个slot内部的显示结构把子组件的值，传给父组件固定的区域进行操作父组件的数据是给子组件展示的子组件展示过程当中，数据的结构由父组件决定的。 &lt;template> &lt;div> &lt;ul> &lt;li v-for=\"(todo,index) in todos\" :key=\"todos.id\"> &lt;slot :todo=\"todo\"> {{todo.content}} &lt;/slot> &lt;/li> &lt;/ul> &lt;/div> &lt;/template> 适用场合 1.当一个组件有不确定的结构时, 就需要使用slot技术了 2.注意: 插槽内容是在父组件中编译后, 再传递给子组件 3.如果决定结构的数据在父组件, 那用默认slot或命名命名slot (1) 当只有一个不确定的结构时, 可以使用默认slot (2) 当有多个不确定的结构时, 可以使用命名slot 4.如果决定结构的数据在子组件, 那需要使用作用域slot 5. 消息订阅(subscribe)与发布(publish) 在线文档 下载: npm install -S pubsub-js vue中解决跨域跨域：跨域是什么 配置代理服务器解决跨域1、本身我们现在就跑在开发服务器 webpack-dev-server 而这个服务器带了一个模块，这个模块可以支持我们使用代理 2、原理：在浏览器发请求的时候，把这个请求发给服务器上的这个代理模块 再由这个代理模块转发给我们真正的服务器 这样的话，我们原来由浏览器直接发送请求到服务器就转化为服务器到服务器之间的请求 3、你要让代理转发，那么得告诉代理你的这个请求什么情况需要转发，配置以固定什么开头的路径需要代理转发，代理看到这个路径是以它开头就会帮你转发 4、代理转发的时候会把路径交给真正的请求服务器，作为请求路径，需要把固定的开头去除 changeOrigin: true, // 支持跨域, 如果协议/主机也不相同, 必须加上 proxy: { \"/api\": { target: \"http://localhost:4000\", pathRewrite: {\"^/api\" : \"\"}, //要看真正的后台接口路径当中有没有包含/api，有就不用去掉，没有就得去掉 changeOrigin:true } } vue-ajaxvue-axios与axios官方库大同小异不过多赘述,想了解的可以 参考axios文档 我的博客ajax-axios vueui组件库1. 移动端UI组件库1)Vant https://youzan.github.io/vant/#/zh-CN/2)Cube UI https://didi.github.io/cube-ui/#/zh-CN3)Mint UI http://mint-ui.github.io/ (经常不能访问) 2. PC端UI组件库4)Element UI https://element.eleme.cn/#/zh-CN5)IView UI https://www.iviewui.com/ vue-router vue-router的理解 vue的一个插件库 专门用来实现一个SPA应用 基于vue的项目基本都会用到此库 中文文档: http://router.vuejs.org/zh-cn/ 下载: npm install vue-router -S SPA的理解 单页Web应用（single page web application，SPA） 整个应用只有一个完整的页面 点击页面中的链接不会刷新页面, 本身也不会向服务器发请求 当点击路由链接时, 只会做页面的局部更新 数据都需要通过ajax请求获取, 并在前端异步展现 VueRouter(): 用于创建路由器的构建函数 new VueRouter({ // 多个配置项 }) 路由配置 routes: [ { // 一般路由 path: '/about', component: About }, { // 自动跳转路由 path: '/', redirect: '/about' } ] 注册路由器 import router from './router' new Vue({ router }) 使用路由组件标签 : 用来生成路由链接 &lt;router-link to=\"/xxx\">Go to XXX&lt;/router-link> : 用来显示当前路由组件界面 &lt;router-view>&lt;/router-view> 配置嵌套路由 path: '/home', component: home, // 嵌套路由 children: [ { path: 'news', component: News }, { path: 'message', component: Message } ] 向路由组件传递参数 配置路由 children: [ { path: 'mdetail/:id', component: MessageDetail } ] 路由路径 &lt;router-link :to=\"'/home/message/mdetail/'+m.id\">{{m.title}}&lt;router-link> 路由组件中读取请求参数this.$route.params.id 编程式路由导航 this.$router.push(path): 相当于点击路由链接(可以返回到当前路由界面) this.$router.replace(path): 用新路由替换当前路由(不可以返回到当前路由界面) this.$router.back(): 请求(返回)上一个记录路由 this.$router.go(-1): 请求(返回)上一个记录路由 this.$router.go(1): 请求下一个记录路由 router 守卫 适用场合校验token // 全局前置导航守卫 router.beforeEach(async (to, from,next) => { // 全局前置导航守卫 // to 代表准备驱动地方的路由对象 // from 从哪个地方来的路由对象 // next 是一个函数 // next() 代表无条件放行 // next(false) 代表不放行，停在原地 // next('/') next({path:'/'}) 代表最终让它去哪 // token校验 let token = store.state.user.token if(token){ // 代表登录了或者之前登录过 if(to.path === '/login'){ // 登录鼓励，又想去登录页，直接跳转到首页 next('/') }else{ // !! 转化为bool值 let hasuserInfo = !!store.state.user.userInfo if(hasuserInfo){ // 此时 代表登录了 ， 去的不是登录页，用户信息存在，直接无条件放行 next() }else{ // 此时代表登录了，去的不是登录页，用户信息不存在 那我们要根据token发请求获取用户真实信息 try { await store.dispatch('getUserInfo') next() } catch (error) { // 出现错误 跳转到login页面，并清楚用户信息 alert('用户的token过期') // 清空用户信息 store.dispatch('resetUserInfo') next('/login') } } } }else{ // 代表用户没登录或者之前也没有登录过 // 后期我们需要判断用户是不是订单相关的页面，如果是娜美就先登录 next() } }) vuex与redux大同小异 github站点 在线文档 简单来说: 对vue应用中多个组件的共享状态进行集中式的管理(读&#x2F;写) 状态管理是什么： Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式，是一个官方插件。它采用集中式存储管理应用的所有组件的状态（数据），并以相应的规则保证状态以一种可预测的方式发生变化。​- 我们也可以认为它也是一种组件间通信的方式，并且适用于任意组件 适用场合 Vuex 可以帮助我们管理共享状态，并附带了更多的概念和框架。这需要对短期和长期效益进行权衡。 也就是说应用简单（组件比较少）就不需要使用（但是可以），如果应用复杂，使用就会带来很大的便捷 Vuex核心：把所有的共享状态数据拿出来放在Vuex中进行集中式管理 vuex简单模板 // 1、安装 // 2、引入并声明使用vuex插件 import Vue from 'vue' import Vuex from 'vuex' Vue.use(Vuex) // 3、向外暴露一个store的实例化对象 // state是一个包含多个属性（不是方法）的对象，其实就是用来存储数据用的 const state = { // 代表初始状态数据 是一个包含n个属性（不是方法）的对象 } // mutations也是一个对象，是一个包含了多个方法的对象，其实就是用这个里面的方法去直接操作数据的 // 这个里面的方法不能包含 if for 异步，是直接操作的 const mutations = { // 代表直接修改数据的数据 是一个包含n个直接修改状态数据方法的对象 （用来让action的行为调用） // 注意：只能通过mutations的方法去直接修改，也就是说要想写state数据必须通过mutations } // actions也是一个对象，是一个包含了多个方法的对象。这个对象内部的方法是用来和vue当中用户的操作去关联的 // 这个里面的方法可以包含 if for 异步。 const actions = { // 代表用户行为数据 是一个包含n个用户行为回调方法的对象，（用来映射组件用户的行为回调函数） } // getters也是一个对象，是一个包含了多个方法的对象。这个对象内部的每个方法对应了一个计算属性的get，就是 // 通过state当中的数据 计算出来的一个新的想要的属性数据 const getters = { // 代表计算属性数据 是一个包含n个计算属性的方法的对象 } export default new Vuex.Store({ // 包含了6个核心概念， // 现在讲4个 state, mutations, actions, getters }) // 4、将暴露出去的store实例化对象引入到实例化Vue的配置对象(main.js)当中使用 注册store import store from &#39;./store&#39; new Vue(&#123; store, // 注册vuex的store对象 ==&gt; 所有组件对象都有一个$store属性 &#125;)","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"https://blog.yyshino.top/tags/Vue2/"}]},{"title":"Vue2","slug":"Vue01","date":"2022-05-17T14:15:31.000Z","updated":"2022-09-16T10:33:53.777Z","comments":true,"path":"posts/43782.html","link":"","permalink":"https://blog.yyshino.top/posts/43782.html","excerpt":"","text":"Vue基础介绍渐进式javaScript框架————Vue 与其他框架的关系 1)借鉴angular的模板和数据绑定技术 2)借鉴react的组件化和虚拟DOM技术 扩展插件 1)vue-cli: vue脚手架 2)vue-resource(axios): ajax请求 3)vue-router: 路由 4)vuex: 状态管理 5)vue-lazyload: 图片懒加载 6)vue-scroller: 页面滑动相关 7)mint-ui: 基于vue的UI组件库(移动端) 8)element-ui: 基于vue的UI组件库(PC端) 前置知识&lt;div id=\"app\"> &lt;!-- 这个挂载点一旦被VM挂载，那么内部就不是我们单纯的html，被称作模板 --> &lt;!-- 模板是由两部分组成 html + js --> &lt;!-- 模块语法 指令和差值 --> &lt;!-- 指令是用来修改模板当中标签（属性 内容 样式） --> &lt;!-- 差值是专门用来修改模板当中标签的内容值 {{}} --> &lt;script> // 1.引入vue.js // 2.在body当中必须写一个挂载点 // 3.实例化一个Vue的实例化对象，和挂载点进行挂载 vm对象 const vm = new Vue({ el:'#app', //被称作挂载点 本质上是一个css的选择器字符串，标识着vm要和谁去绑定挂载 data:{ } }) // vm对象和传递的配置对象是不是同一个 // 不是同一个对象 // 数据代理：使用vm代理了配置对象当中data的数据，vm身上也有和data当中同名的属性模 板当中 访问的都是vm身上的属性 // vm代理了data当中的数据，找vm获取数据其实最终还是拿的data当中的属性值 // 修改vm的数据其实本质是在修改data当中的数据 &lt;/script> ``` #### 01-差值 ```js // 差值 {{}} &lt;p>{{msg}}&lt;/p> &lt;p>{{msg.toUpperCase()}}&lt;/p> 02-数据的绑定指令单向数据绑定 功能: 指定变化的属性值 完整写法: v-bind:xxx=&#39;yyy&#39; &#x2F;&#x2F;yyy会作为表达式解析执行 简洁写法: :xxx=&#39;yyy&#39; 双向数据绑定 v-model 一般情况下只针对表单类才使用双向数据绑定 MVVM 说的就是双向数据绑定模型 M代表model就是我们的数据 V代表的view 就是我们的页面 Vm代表的就是Vue的实例化对象双向数据绑定：数据可以从data流向页面 页面的数据被更新，也会从页面流向data (当data的数据更改后，又会重新流向页面) 2.5自动获取表单示例 &lt;div id=\"app\"> &lt;!-- 数据绑定的两种方法 简单来说就是点击文字可以让 input生效 --> &lt;!-- 第一种 --> &lt;!-- v-model默认收集的其实是你表单元素当中的value值 --> &lt;label for=\"in1\">用户名：&lt;/label> &lt;input type=\"text\" id=\"in1\" v-model=\"userInfo.username\"> &lt;!-- 第二种 --> &lt;label> 密码：&lt;input type=\"text\" v-model=\"userInfo.password\"> &lt;/label> &lt;br> &lt;!-- name相同时 单选框才会绑定在一组 --> &lt;!-- v-model默认收集的其实是你表单元素当中的value值,因此需要给radio添加value属性 --> 性别： &lt;label> 男：&lt;input type=\"radio\" name=\"sex\" value=\"male\" v-model=\"userInfo.gender\"> &lt;/label> &lt;label> 女：&lt;input type=\"radio\" name=\"sex\" value=\"female\" v-model=\"userInfo.gender\"> &lt;/label> &lt;br> 爱好： &lt;label> ☀&lt;input type=\"checkbox\" value=\"sum\" v-model=\"userInfo.favas\"> &lt;/label> &lt;label> 卍&lt;input type=\"checkbox\" value=\"N解\" v-model=\"userInfo.favas\"> &lt;/label> &lt;label> ♬&lt;input type=\"checkbox\" value=\"music\" v-model=\"userInfo.favas\"> &lt;/label> &lt;br> &lt;!-- select 这个标签他的value值是选中的option的value值 --> 城市： &lt;select v-model=\"userInfo.cityId\"> &lt;option :value=\"city.id\" v-for=\"(city,index) in citys\" :key=\"city.id\">{{city.name}}&lt;/option> &lt;/select> &lt;br> &lt;textarea cols=\"30\" rows=\"10\" > &lt;/textarea> &lt;br> &lt;button type=\"\">提交&lt;/button> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script type=\"text/javascript\" > new Vue({ el:'#app', data:{ citys:[ {id:1,name:'北京'}, {id:2,name:'上海'}, {id:3,name:'深圳'}, ], // 代表收集的数据 userInfo:{ username:\"\", password:\"\", gender:'', favas:[], //favas 必须是一个数组 因为它需要收集多个数据 cityId:1, desc:'' } }, methods:{ submit(){ axios({ url:'后台给你的接口地址', method:'post', data:this.userInfo }) } }, }); &lt;/script> 03-计算属性和watch监视 1.计算属性 1)在computed属性对象中定义计算属性的方法 2)在页面中使用来显示计算的结果 2.watch 1)通过通过vm对象的$watch()或watch配置来监视指定的属性 2)当属性变化时, 回调函数自动调用, 在函数内部进行计算 示例 &lt;div id=\"app\"> 姓：&lt;input type=\"text\" v-model=\"firstName\"> 名：&lt;input type=\"text\" v-model=\"lastName\"> &lt;!-- 第一种方法不用 使用js的拼接 数据在模板当中 this全部指向的是vm 只不过模板当中的this可以省略 --> &lt;!-- &lt;p>{{this.firstName + '-' + this.lastName}}&lt;/p> --> &lt;p>{{firstName + '-' + lastName}}&lt;/p> &lt;!-- 第二种方法不用 封装函数去写 --> &lt;p>{{getFullName()}}&lt;/p> &lt;!-- &lt;p>{{getFullName()}}&lt;/p> &lt;p>{{getFullName()}}&lt;/p> --> &lt;!-- 第三种方法重要：计算属性 --> &lt;p>{{fullName}}&lt;/p> &lt;!-- &lt;p>{{fullName}}&lt;/p> &lt;p>{{fullName}}&lt;/p> --> &lt;!-- 第四种方法：watch监视 --> &lt;p>{{fullName2}}&lt;/p> &lt;!-- 使用computed异步放回数据，不行 --> &lt;p>{{fullName3}}&lt;/p> &lt;!-- 使用watch异步更新数据，可行 --> &lt;p>{{fullName4}}&lt;/p> &lt;!-- 计算属性的set方法 --> &lt;input type=\"text\" v-model=\"fullName\"> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script type=\"text/javascript\" > const vm = new Vue({ el:'#app', data(){ return { firstName:'li', lastName:'huazhou', fullName2:'', //监视的时候必须有这个属性,属性值是什么不确定,后面根据监视去给他赋值 fullName4:'' } }, methods:{ getFullName(){ console.log('方法被调用了'); //在vue中所有的函数内部的this都指向vm，因为这些方法或者函数都会被vm代理 return this.firstName + '-' + this.lastName } }, // 当我需要一个数据,但是这个数据我又没有，并且这个数据又目前计算而来的，那就要用计算属性 computed:{ // 计算属性的完整写法 fullName:{ get(){ return this.firstName + '-' + this.lastName }, // 当计算属性的数据能被修改时候使用（表单类元素在双向绑定计算属性值） set(val){ // 目前没用 let arr = val.split('-') this.firstName = arr[0] this.lastName = arr[1] }, }, // 如果计算属性当中只有get方法，那么可以简写为如下方法 // 计算属性的j简写写法 // fullName(){ // console.log('computed被调用了'); // return this.firstName + '-' + this.lastName // }, // computed内部只能是同步放回数据，不能异步放回数据 fullName3(){ let a = null setTimeout(()=>{ //函数体\\ a = '嘿嘿' },1000) return a } }, //使用方法去获取姓名和使用计算属性去计算姓名的区别(贼重要) // 对于方法调用： // 你使用了几次方法调用，那么这个方法被调用了几次 // 对于计算属性： // 你使用了不管多少次计算属性，计算属性的get方法只调用一次 // 计算属性一定存在缓存，这些缓存使用多次的时候效率比使用方法高的多 // 推荐重要 watch:{ firstName:{ // 这个对象是一个配置对象 // 当数据发生改变的时候会自动调用hander回调 handler(newVal,odlVal){ this.fullName2 = newVal + '-' + this.lastName // setTimeout(()=>{ //函数体 this.fullName4 = '嘿嘿' },1000) }, immediate:true //配置这个配置项的作用是无论监视到属性发生不发生变化，都要强制执行一次回调 }, // lastName:{ // } }, }) // 第二种方式使用watch，不推荐 vm.$watch('lastName',function(newVal,oldVal){ //this决定是否可以使用箭头函数 console.log(this); this.fullName2 = this.firstName + '-' + newVal }) // computed是 计算属性,一般是没有这个值但是想要用这个值，那么根据已有的去做计算 // watch 是 监视属性,监视的属性已经后期要更改的属性都没有必须有 // 通常能用computed的场合都可以使用watch去解决，但是能用watch解决的computed不一定能解决 // computed函数当中只能使用同步，而watch当中可以是同步也可以是异步 // 当我们去比较computed和watch的时候起始比较的是计算属性的get方法 // 计算熟悉的set没什么说的，其实仅仅是对计算的属性添加了监视（当计算属性的值修改后会，调用set） &lt;/script> 04-实现动态样式效果 class绑定 1):class='xxx' 2)表达式是字符串: 'classA' 3)表达式是对象: {classA:isA, classB: isB} 4)表达式是数组: ['classA', 'classB'] style绑定 1):style=\"{ color: activeColor, fontSize: fontSize + 'px' }\" 2)其中activeColor/fontSize是data属性 04.5-过渡和动画 xxx-enter-active: 指定显示的transitionxxx-leave-active: 指定隐藏的transitionxxx-enter&#x2F;xxx-leave-to: 指定隐藏时的样式 在进入/离开的过渡中，会有 6 个 class 切换。 v-enter：定义进入过渡的开始状态。在元素被插入之前生效，在元素被插入之后的下一帧移除。 v-enter-active：定义进入过渡生效时的状态。在整个进入过渡的阶段中应用，在元素被插入之前生效，在过渡/动画完成之后移除。这个类可以被用来定义进入过渡的过程时间，延迟和曲线函数。 v-enter-to：2.1.8 版及以上定义进入过渡的结束状态。在元素被插入之后下一帧生效 (与此同时 v-enter 被移除)，在过渡/动画完成之后移除。 v-leave：定义离开过渡的开始状态。在离开过渡被触发时立刻生效，下一帧被移除。 v-leave-active：定义离开过渡生效时的状态。在整个离开过渡的阶段中应用，在离开过渡被触发时立刻生效，在过渡/动画完成之后移除。这个类可以被用来定义离开过渡的过程时间，延迟和曲线函数。 v-leave-to：2.1.8 版及以上定义离开过渡的结束状态。在离开过渡被触发之后下一帧生效 (与此同时 v-leave 被删除)，在过渡/动画完成之后移除。 对于这些在过渡中切换的类名来说，如果你使用一个没有名字的 ，则 v- 是这些类名的默认前缀。如果你使用了 ，那么 v-enter 会替换为 my-transition-enter。 v-enter-active 和 v-leave-active 可以控制进入/离开过渡的不同的缓和曲线 ——————取自Vue官网 05-条件渲染和列表渲染条件渲染指令 v-if与v-else v-show 比较v-if与v-show 3)如果需要频繁切换 v-show 较好 4)当条件不成立时, v-if的所有子节点不会解析(项目中使用) 列表显示 指令 数组: v-for / index 对象: v-for / key 列表的更新显示 删除item 替换item 高级用法(列表的过滤以及排序) &lt;div id=\"app\"> &lt;input type=\"text\" placeholder=\"请输入过滤的条件\" v-model=\"keyword\"> &lt;ul> &lt;li v-for=\"(persons,index) in newPersons\" :key=\"persons.id\"> {{persons.id}} ---- {{persons.name}} ---- {{persons.age}} &lt;/li> &lt;/ul> &lt;!-- &lt;button @click=\"test(1)\">按年龄升序&lt;/button> &lt;button @click=\"test(2)\">按年龄降序&lt;/button> &lt;button @click=\"test(0)\">按原样排序&lt;/button> --> &lt;button @click=\"sortType = 1\">按年龄升序&lt;/button> &lt;button @click=\"sortType = 2\">按年龄降序&lt;/button> &lt;button @click=\"sortType = 0\">按原样排序&lt;/button> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script type=\"text/javascript\" > Vue.config.productionTip = false; //消除启动浏览器的生产提示信息 const vm = new Vue({ el:'#app', data:{ keyword:'', persons:[ {id:1,name:'zhaoliying',age:33}, {id:2,name:'yanmi',age:34}, {id:3,name:'qiwei',age:40}, {id:4,name:'dilireba',age:20} ], // 排序首先要设计这个数据，标致用户点击到底是什么排序类型 // sortType:0 //0 -1 2 0代表原样 1代表升序 2代表降序 }, methods:{ test(num){ // 当函数当中如果只有一行代码，可以省略函数，直接把代码写在上面 this.sortType = num } }, computed:{ newPersons(){ //判断是否简写（数据是否可改）（是否需要set） let {keyword,persons,sortType} = this // 根据获取的两个计算新的数据 //函数和方法最重要的是三要素 //功能 从原数组当中过滤一个新的数组 // 参数 回调函数（同步的回调） // 回调函数的参数：当前项的索引 当前遍历的数组 // 功能：对遍历的每一项执行回调函数 // 返回值：返回的是一个布尔值,(布尔值,条件表达式)，根据这个布尔值的真假来决定当前遍历的这项 // 要不要收集到数组中 // 返回值 返回的是新的数组 // 什么是运算符 什么是表达式 // 参与运算的符号 // 由变量或者常量和运算符组成的是在就是表达式 表达式都是有值的 // 非箭头函数 // let arr = persons.filter(function(item,index){ // return item.name.indexOf(keyword) !== -1 // }) // 箭头函数 let arr = persons.filter(item => (item.name.indexOf(keyword) !== -1)) // 在过滤的基础上排序完成再返回 // if(sortType === 1){ // return a.age - b.age // }else{ // return b.age - a.age // } if(sortType !== 0){ arr.sort((a,b) => sortType === 1 ? a.age - b.age : b.age - a.age) } return arr; } } }); &lt;/script> 06-深入了解Vue的响应式数据 在vue当中 一开始data中的属性数据都是响应式的 数组的数据 说的每个数组当中元素整体 对象的数据 说的对象的属性 Vue 当中处理响应式数据对于数组和对象是不一样的 1、如果修改的是对象的属性，随便改，都是响应式的。因为Vue一开始就为data当中所有的属性通过Object.defineProperty添加了get和set 2、数组修改的时候，必须使用特定的几个方法才能是响应式，如果直接通过下标操作数组的数据，不是响应式式 为什么数组的方法就可以响应式？ 此splice非原生的splice，vue当中给数组部分方法添加了修改页面的功能(重写方法)push() pop() shift() unshift() splice() sort() reverse() 方法的语法以及使用并没有改变，简单的用法.可以参考我这篇文章 js数组总结 总结 面试高频点 总结 vue在对待数组和对象的时候处理响应式是不一样的 对象是通过Object.defineProperty添加了get和set 数组 重写数组的方法 07-Vue事件相关绑定监听1)v-on:xxx=&quot;fun&quot;2)@xxx=&quot;fun&quot;3)@xxx=&quot;fun(参数)&quot;4)默认事件形参: event5)隐含属性对象: $event 事件修饰符1).prevent : 阻止事件的默认行为 event.preventDefault()2).stop : 停止事件冒泡 event.stopPropagation() 按键修饰符1).keycode : 操作的是某个keycode值的键2).keyName : 操作的某个按键名的键(少部分) 示例 &lt;div id=\"app\"> &lt;!-- 事件初始写法 --> &lt;button v-on:click=\"test1\">test1&lt;/button> &lt;!-- 事件写法可以简写 --> &lt;button @click=\"test1\">test1&lt;/button> &lt;!-- 事件回调函数如果我们想要传递自己的参数,那么默认的事件对象的参数会被覆盖 --> &lt;button @click=\"test3('Kanade')\">test3&lt;/button> &lt;!-- 事件回调函数如果我们想要传递自己的参数,而且还想要用到事件对象，此时需要手动传递事件对象--> &lt;button @click=\"test4('Kanade',$event)\">test4&lt;/button> &lt;!-- 事件的阻止冒泡 --> &lt;div style=\"width:200px;height:200px;background:red\" @click=\"outer\"> &lt;div style=\"width:100px;height:100px;background:blue\" @click.stop=\"inner\">&lt;/div> &lt;/div> &lt;!-- 事件当中取消浏览器默认行为 --> &lt;a href=\"http://www.bilibili.com\" @click.prevent=\"cancelDefault\">点我去学习&lt;/a> &lt;!-- 键盘事件都用在表单元素或者document身上 --> &lt;input type=\"text\" @keyup.enter=\"keyEnter\"> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script type=\"text/javascript\" > Vue.config.productionTip = false //配置不用提示开发帮本的信息 let vm = new Vue({ el:'#app', data(){ return{ } }, methods:{ test1(event){ console.log(event.target.innerText); }, test3(name,event){ console.log(name,event); }, test4(name,event){ console.log(name,event); }, outer(){ console.log('outer'); }, inner(){ console.log('inner'); // event.stopPropagation(); }, cancelDefault(event){ // event.preventDefault(); }, keyEnter(event){ // // if(event.keyCode === 13 ){ // console.log('回车了'); // } console.log('回车了'); } } }); &lt;/script> 08-Vue生命周期 1)初始化显示 beforeCreate() created() beforeMount() mounted() 2)更新状态: this.xxx = value beforeUpdate() updated() 3)销毁vue实例: vm.$destory() beforeDestory() destoryed() 常用钩子1)mounted(): 发送ajax请求, 启动定时器等异步任务2)beforeDestory(): 做收尾工作, 如: 清除定时器 示例 &lt;div id=\"app\"> &lt;p ref=\"pp\" v-show=\"isShow\">我爱你{{isShow?'刘亦菲':'杨幂'}}&lt;/p> &lt;button @click=\"destory\">点我卸载组件&lt;/button> &lt;/div> &lt;script src=\"./js/vue.js\">&lt;/script> &lt;script type=\"text/javascript\"> new Vue({ el:'#app', // template:'&lt;p>{{isShow}}&lt;/p>', data(){ return { isShow:true, } }, methods:{ destory(){ this.$destroy() //必须在某个特定的场合下 自己手动调用vm.$destroy()方法 才能进入销毁的阶段 } }, // 初始化阶段有两个钩子 beforeCreate created beforeCreate(){ // 初始化之前最大的特点是数据还没有代理好，打印不到 console.log(this,this.isShow); }, created(){ // 初始化之后数据就可以被访问了 console.log(this.isShow); }, // 挂载阶段,挂在前和挂载后 beforeMount(){ console.log(this.$refs.pp); }, mounted(){ // 这个钩子用的是最多的 // 一般用于发送ajax请求获取数据 // 还用于开启定时器 // 添加一些事件 console.log(this.$refs.pp); this.timer = setInterval(()=>{ //函数体 this.isShow = !this.isShow },2000) }, // 前两个阶段完成 代表初始化展示页面就完成了 // 页面数据更新前和页面数据更新后 不是vm的数据 beforeUpdate(){ // 页面更新前 vm 的数据已经做了更新了，但此时数据还没有更新过来 console.log(this.isShow,this.$refs.pp.innerHTML); }, updated(){ // 页面更新前 vm 的数据已经做了更新了，页面的数据也更新过来了 console.log(this.isShow,this.$refs.pp.innerHTML); }, // 销毁阶段 beforeDestroy(){ // 销毁之前 // 一般这个钩子用的也是比较频繁,通常是在销毁前解绑事件监听 取消定时器等操作 clearInterval(this.timer) //定时器管理模块会把这个定时器给停止，但是并没有把这个编号从timer当中销毁 this.timer = null }, // 销毁之后 destroyed(){ // 没什么用 console.log('vm销毁了'); }, }) &lt;/script> 09-Vue可复用性和组合Vue的内置指令以及自定义指令常用内置指令v-text : 更新元素的 textContentv-html : 更新元素的 innerHTMLv-if : 如果为true, 当前标签才会输出到页面v-else: 如果为false, 当前标签才会输出到页面v-show : 通过控制display样式来控制显示&#x2F;隐藏v-for : 遍历数组&#x2F;对象v-on : 绑定事件监听, 一般简写为@v-bind : 强制绑定解析表达式, 可以省略v-bindv-model : 双向数据绑定ref : 指定唯一标识, vue对象通过$els属性访问这个元素对象v-cloak : 防止闪现, 与css配合: [v-cloak] { display: none } 过滤器可以用全局方法 Vue.filter() 注册一个自定义过滤器，它接收两个参数：过滤器 ID 和过滤器函数。过滤器函数以值为参数，返回转换后的值 自定义指令全局注册 // 注册一个全局自定义指令 `v-focus` Vue.directive('focus', { // 当被绑定的元素插入到 DOM 中时…… inserted: function (el) { // 聚焦元素 el.focus() } }) 局部注册 directives: { focus: { // 指令的定义 inserted: function (el) { el.focus() } } } 10-Vue Cli引言定义非单文件组件 // 全局注册 // 1、定义组件 (定义的组件之后都是全局组件) 本质上是根据一个配置对象定义返回一个函数，后期是当构造函数使用 // 麻烦写法 const VueComponent = Vue.extend({ // 组件配置对象和Vue配置对象很相似，除了el data(){ // 组件的配置对象当中data只能写函数 return{ count:0 } }, data:{ // 组件当中不能写对象 count:0 }, template:'&lt;div>&lt;h2>I love you &lt;/h2>&lt;button @click=\"count++\">你爱了{{count}}次&lt;/button>&lt;/div>' }) // 3.使用 // 定义组件的简单写法（定义带注册） // 1、定义带注册 // 本质上 内部还是使用extend生成一个函数，然后再去和mybutton绑定 Vue.component('mybutton',{ // 组件配置对象和Vue配置对象很相似，除了el data(){ // 组件的配置对象当中data只能写函数 return{ count:0 } }, // data:{ // // 组件当中不能写对象 // count:0 // }, template:'&lt;div>&lt;h2>I love you &lt;/h2>&lt;button @click=\"count++\">你爱了{{count}}次&lt;/button>&lt;/div>' }) // 2、使用 // 一般情况下 我们定义的都是全局组件 因为这个组件只在一个地方用到 // 但是当一个组件被多个组件都使用的时候，我们定义为全局组件比较方便 // 局部注册 // 在vm组件中注册 →→→→→Vue脚手架","categories":[{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"}],"tags":[{"name":"Vue2","slug":"Vue2","permalink":"https://blog.yyshino.top/tags/Vue2/"}]},{"title":"React高级","slug":"React3","date":"2022-05-16T09:31:32.000Z","updated":"2022-09-16T10:33:45.287Z","comments":true,"path":"posts/4944.html","link":"","permalink":"https://blog.yyshino.top/posts/4944.html","excerpt":"","text":"react-router三、路由的基本使用 1.明确好界面中的导航区、展示区 2.导航区的a标签改为Link标签 &lt;Link to=\"/xxxxx\">Demo&lt;/Link> 3.展示区写Route标签进行路径的匹配 &lt;Route path='/xxxx' component={Demo}/> 4.&lt;App>的最外侧包裹了一个&lt;BrowserRouter>或&lt;HashRouter> 四、路由与一般组件 1.写法不同： 一般组件：&lt;Demo/> 路由组件：&lt;Route path=\"/demo\" component={Demo}/> 2.存放位置不同： 一般组件：components 路由组件：pages 3.接收到的props不同： 一般组件：写组件标签时传递了什么，就能收到什么 路由组件：接收到三个固定的属性 history: go: ƒ go(n) goBack: ƒ goBack() goForward: ƒ goForward() push: ƒ push(path, state) replace: ƒ replace(pastate) location: pathname: \"/about\" search: \"\" state: undefined match: params: {} path: \"/about\" url: \"/about\" 五、NavLink与封装NavLink 1.NavLink可以实现路由链接的高亮，通过activeClassName指定样式名 六、Switch的使用 1.通常情况下，path和component是一一对应的关系。 2.Switch可以提高路由匹配效率(单一匹配)。 七、解决多级路 径刷新页面样式丢失的问题 1.public/index.html 中 引入样式时不写 ./ 写 / （常用） 2.public/index.html 中 引入样式时不写 ./ 写 %PUBLIC_URL% （常用） 3.使用HashRouter 八、路由的严格匹配与模糊匹配 1.默认使用的是模糊匹配（简单记：【输入的路径】必须包含要【匹配的路径】，且顺序要一致） 2.开启严格匹配：&lt;Route exact={true} path=\"/about\" component={About}/> 3.严格匹配不要随便开启，需要再开，有些时候开启会导致无法继续匹配二级路由 九、Redirect的使用 1.一般写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到Redirect指定的路由 2.具体编码： &lt;Switch> &lt;Route path=\"/about\" component={About}/> &lt;Route path=\"/home\" component={Home}/> &lt;Redirect to=\"/about\"/> &lt;/Switch> 十、嵌套路由 1.注册子路由时要写上父路由的path值 2.路由的匹配是按照注册路由的顺序进行的 十一、向路由组件传递参数 1.params参数 路由链接(携带参数)：&lt;Link to='/demo/test/tom/18'}>详情&lt;/Link> 注册路由(声明接收)：&lt;Route path=\"/demo/test/:name/:age\" component={Test}/> 接收参数：this.props.match.params 2.search参数 路由链接(携带参数)：&lt;Link to='/demo/test?name=tom&amp;age=18'}>详情&lt;/Link> 注册路由(无需声明，正常注册即可)：&lt;Route path=\"/demo/test\" component={Test}/> 接收参数：this.props.location.search 备注：获取到的search是urlencoded编码字符串，需要借助querystring解析 3.state参数 路由链接(携带参数)：&lt;Link to={{pathname:'/demo/test',state:{name:'tom',age:18}}}>详情&lt;/Link> 注册路由(无需声明，正常注册即可)：&lt;Route path=\"/demo/test\" component={Test}/> 接收参数：this.props.location.state 备注：刷新也可以保留住参数 十二、编程式路由导航 借助this.prosp.history对象上的API对操作路由跳转、前进、后退 -this.prosp.history.push() -this.prosp.history.replace() -this.prosp.history.goBack() -this.prosp.history.goForward() -this.prosp.history.go() 十三、BrowserRouter与HashRouter的区别 1.底层原理不一样： BrowserRouter使用的是H5的history API，不兼容IE9及以下版本。 HashRouter使用的是URL的哈希值。 2.path表现形式不一样 BrowserRouter的路径中没有#,例如：localhost:3000/demo/test HashRouter的路径包含#,例如：localhost:3000/#/demo/test 3.刷新后对路由state参数的影响 (1).BrowserRouter没有任何影响，因为state保存在history对象中。 (2).HashRouter刷新后会导致路由state参数的丢失！！！ 4.备注：HashRouter可以用于解决一些路径错误相关的问题。 十四、antd的按需引入+自定主题 1.安装依赖：yarn add react-app-rewired customize-cra babel-plugin-import less less-loader 2.修改package.json .... \"scripts\": { \"start\": \"react-app-rewired start\", \"build\": \"react-app-rewired build\", \"test\": \"react-app-rewired test\", \"eject\": \"react-scripts eject\" }, .... 3.根目录下创建config-overrides.js //配置具体的修改规则 const { override, fixBabelImports,addLessLoader} = require('customize-cra'); module.exports = override( fixBabelImports('import', { libraryName: 'antd', libraryDirectory: 'es', style: true, }), addLessLoader({ lessOptions:{ javascriptEnabled: true, modifyVars: { '@primary-color': 'green' }, } }), ); 4.备注：不用在组件里亲自引入样式了，即：import 'antd/dist/antd.css'应该删掉 react-redux简介 1.redux是一个独立专门用于做状态管理的JS库(不react插件库) 2.它可以用在react、angular、vue等项目中，但本与react配合使用 3.作用：集中式管理react应用中多个组件共享的态 什么时候需要使用 1.某个组件的状态，需要让其他组件可以随时拿到（共享）。 2.一个组件需要改变另一个组件的状态（通信）。 3.总体原则：能不用就不用, 如果不用比较吃力才考虑使用。 原理图 redux的三个核心概念action1.动作的对象2.包含2个属性 type：标识属性, 值为字符串, 唯一, 必要属性 data：数据属性, 值类型任意, 可选属性 3.例子： { type: 'ADD_STUDENT',data:{name: 'tom',age:18} } reducer1.用于初始化状态、加工状态。2.加工时，根据旧的state和action， 产生新的state的纯函数。 store1.将state、action、reducer联系在一起的对象2.如何得到此对象? 1)import {createStore} from 'redux' 2)import reducer from './reducers' 3)const store = createStore(reducer) 3.此对象的功能? 1)getState(): 得到state 2)dispatch(action): 分发action, 触发reducer调用, 产生新的state 3)subscribe(listener): 注册监听, 当产生了新的state时, 自动调用 redux的核心APIcreatestore()作用：创建包含指定reducer的store对象 store对象1.作用: redux库最核心的管理对象2.它内部维护着: 1)state ​ 2)reducer 3.核心方法: 1)getState() ​ 2)dispatch(action) ​ 3)subscribe(listener) 4.具体编码: 1)store.getState() ​ 2)store.dispatch({type:'INCREMENT', number}) ​ 3)store.subscribe(render) applyMiddleware()作用：应用上基于redux的中间件(插件库) combineReducers()作用：合并多个reducer函数 总结1. setStatesetState更新状态的2种写法 (1). setState(stateChange, [callback])------对象式的setState 1.stateChange为状态改变对象(该对象可以体现出状态的更改) 2.callback是可选的回调函数, 它在状态更新完毕、界面也更新后(render调用后)才被调用 (2). setState(updater, [callback])------函数式的setState 1.updater为返回stateChange对象的函数。 2.updater可以接收到state和props。 4.callback是可选的回调函数, 它在状态更新、界面也更新后(render调用后)才被调用。 总结: 1.对象式的setState是函数式的setState的简写方式(语法糖) 2.使用原则： (1).如果新状态不依赖于原状态 ===> 使用对象方式 (2).如果新状态依赖于原状态 ===> 使用函数方式 (3).如果需要在setState()执行后获取最新的状态数据, 要在第二个callback函数中读取 2. lazyLoad路由组件的lazyLoad //1.通过React的lazy函数配合import()函数动态加载路由组件 ===> 路由组件代码会被分开打包 const Login = lazy(()=>import('@/pages/Login')) //2.通过&lt;Suspense>指定在加载得到路由打包文件前显示一个自定义loading界面 &lt;Suspense fallback={&lt;h1>loading.....&lt;/h1>}> &lt;Switch> &lt;Route path=\"/xxx\" component={Xxxx}/> &lt;Redirect to=\"/login\"/> &lt;/Switch> &lt;/Suspense> 3. Hooks1. React Hook&#x2F;Hooks是什么?(1). Hook是React 16.8.0版本增加的新特性/新语法 (2). 可以让你在函数组件中使用 state 以及其他的 React 特性 2. 三个常用的Hook(1). State Hook: React.useState() (2). Effect Hook: React.useEffect() (3). Ref Hook: React.useRef() 3. State Hook(1). State Hook让函数组件也可以有state状态, 并进行状态数据的读写操作 (2). 语法: const [xxx, setXxx] = React.useState(initValue) (3). useState()说明: 参数: 第一次初始化指定的值在内部作缓存 返回值: 包含2个元素的数组, 第1个为内部当前状态值, 第2个为更新状态值的函数 (4). setXxx()2种写法: setXxx(newValue): 参数为非函数值, 直接指定新的状态值, 内部用其覆盖原来的状态值 setXxx(value => newValue): 参数为函数, 接收原本的状态值, 返回新的状态值, 内部用其覆盖原来的状态值 4. Effect Hook(1). Effect Hook 可以让你在函数组件中执行副作用操作(用于模拟类组件中的生命周期钩子) (2). React中的副作用操作: 发ajax请求数据获取 设置订阅 / 启动定时器 手动更改真实DOM (3). 语法和说明: useEffect(() => { // 在此可以执行任何带副作用操作 return () => { // 在组件卸载前执行 // 在此做一些收尾工作, 比如清除定时器/取消订阅等 } }, [stateValue]) // 如果指定的是[], 回调函数只会在第一次render()后执行 (4). 可以把 useEffect Hook 看做如下三个函数的组合 componentDidMount() componentDidUpdate() componentWillUnmount() 5. Ref Hook(1). Ref Hook可以在函数组件中存储/查找组件内的标签或任意其它数据 (2). 语法: const refContainer = useRef() (3). 作用:保存标签对象,功能与React.createRef()一样 4. Fragment使用 &lt;Fragment>&lt;Fragment> &lt;>&lt;/> 作用 可以不用必须有一个真实的DOM根标签了 5. Context理解 一种组件间通信方式, 常用于【祖组件】与【后代组件】间通信 使用1) 创建Context容器对象： const XxxContext = React.createContext() 2) 渲染子组时，外面包裹xxxContext.Provider, 通过value属性给后代组件传递数据： &lt;xxxContext.Provider value={数据}> 子组件 &lt;/xxxContext.Provider> 3) 后代组件读取数据： //第一种方式:仅适用于类组件 static contextType = xxxContext // 声明接收context this.context // 读取context中的value数据 //第二种方式: 函数组件与类组件都可以 &lt;xxxContext.Consumer> { value => ( // value就是context中的value数据 要显示的内容 ) } &lt;/xxxContext.Consumer> 注意 在应用开发中一般不用context, 一般都它的封装react插件 6. 组件优化Component的2个问题 只要执行setState(),即使不改变状态数据, 组件也会重新render() 只当前组件重新render(), 就会自动重新render子组件 &#x3D;&#x3D;&gt; 效率低 效率高的做法 只有当组件的state或props数据发生改变时才重新render() 原因 Component中的shouldComponentUpdate()总是返回true 解决 办法1: 重写shouldComponentUpdate()方法 比较新旧state或props数据, 如果有变化才返回true, 如果没有返回false 办法2: 使用PureComponent PureComponent重写了shouldComponentUpdate(), 只有state或props数据有变化才返回true 注意: 只是进行state和props数据的浅比较, 如果只是数据对象内部数据变了, 返回false 不要直接修改state数据, 而是要产生新数据 项目中一般使用PureComponent来优化 7. render props如何向组件内部动态传入带内容的结构(标签)? Vue中: 使用slot技术, 也就是通过组件标签体传入结构 &lt;AA>&lt;BB/>&lt;/AA> React中: 使用children props: 通过组件标签体传入结构 使用render props: 通过组件标签属性传入结构, 一般用render函数属性 children props &lt;A> &lt;B>xxxx&lt;/B> &lt;/A> {this.props.children} 问题: 如果B组件需要A组件内的数据, ==> 做不到 render props &lt;A render={(data) => &lt;C data={data}>&lt;/C>}>&lt;/A> A组件: {this.props.render(内部state数据)} C组件: 读取A组件传入的数据显示 {this.props.data} 8. 错误边界理解：错误边界：用来捕获后代组件错误，渲染出备用页面 特点：只能捕获后代组件生命周期产生的错误，不能捕获自己组件产生的错误和其他组件在合成事件、定时器中产生的错误 使用方式：getDerivedStateFromError配合componentDidCatch // 生命周期函数，一旦后台组件报错，就会触发 static getDerivedStateFromError(error) { console.log(error); // 在render之前触发 // 返回新的state return { hasError: true, }; } componentDidCatch(error, info) { // 统计页面的错误。发送请求发送到后台去 console.log(error, info); } 9. 组件通信方式总结方式： props： (1).children props (2).render props 消息订阅-发布： pubs-sub、event等等 集中式管理： redux、dva等等 conText: 生产者-消费者模式 组件间的关系 父子组件：props 兄弟组件(非嵌套组件)：消息订阅-发布、集中式管理 祖孙组件(跨级组件)：消息订阅-发布、集中式管理、conText(用的少)","categories":[{"name":"React","slug":"React","permalink":"https://blog.yyshino.top/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.yyshino.top/tags/React/"}]},{"title":"Diffing算法原理","slug":"Diffing","date":"2022-05-16T04:43:06.000Z","updated":"2022-09-13T08:43:54.068Z","comments":true,"path":"posts/62098.html","link":"","permalink":"https://blog.yyshino.top/posts/62098.html","excerpt":"","text":"Diffing算法简介 - 当对比两棵树时，React 首先比较两棵树的根节点。不同类型的根节点元素会有不同的形态。 对比不同类型的元素 - 当根节点为不同类型的元素时，React 会拆卸原有的树并且建立起新的树。举个例子，当一个 元素从 &lt;a> 变成 &lt;img>，从 &lt;Article> 变成 &lt;Comment>，或从 &lt;Button> 变成 &lt;div> 都会触发一个完整的重建流程。 - 当卸载一棵树时，对应的 DOM 节点也会被销毁。组件实例将执行 componentWillUnmoun() 方法。当建立一棵新的树时，对应的 DOM 节点会被创建以及插入到 DOM 中。组件实例将执行 UNSAFE_componentWillMount() 方法，紧接着 componentDidMount() 方法。所有与之前的 树相关联的 state 也会被销毁。 ———— react文档 理解 1: diffing 算法最小颗粒度是标签 (只可以精确到标签的位置) diffing 算法最小颗粒度是标签 (会一直递归循环遍历下去) 2：只要状态改变就会触发 render 函数 (实时修改状态) (状态修改就会触发render函数);在React&#x2F;Vue 中 key属性有什么作用？ (index 的内部原理是什么？) 渲染中key的选择 3.开发中如何选择key?: ​ 1.最好使用每条数据的唯一标识作为key,比如id、手机号、身份证号、学号等唯一值。 ​ 2.如果确定只是简单的展示数据,用index也是可以的。 经典面试题: 1). react/vue中的key有什么作用? (key的内部原理是什么?) 2). 为什么遍历列表时, key最好不要用index? 1.虚拟DOM中key的作用 1).简单的说:key是虚拟DOM对象的标识,在更新显示时key起着极其重要的作用。 2).详细的说:当状态中的数据发生变化时, react会根据【新数据】生成【新的虚拟DOM】, 随后React进行【新虚拟DOM】与【旧虚拟DOM】的diff比较,比较规则如下: a.I旧虚拟DOM中找到了与新虚拟DOM相同的key: (1).若虚拟DOM中内容没变,直接使用之前的真实DOM (2).若虚拟DOM中内容变了,则生成新的真实DOM,随后替换掉页面中之前的真实DOM b.旧虚拟DOM中未找到与新虚拟DOM相同的key 根据数据创建新的真实DOM,随后渲染到到页面 2.用index作为key可能会引发的问题: 1.若对数据进行:逆序添加、逆序删除等破坏顺序操作: 会产生没有必要的真实DOM更新==>界面效果没问题,但效率低。 2.如果结构中还包含输入类的DOM: 会产生错误DOM更新==>界面有问题。 3,注意!如果不存在对数据的逆序添加、逆序删除等破坏顺序操作, 仅用于渲染列表用于展示,使用index作为key是没有问题的。","categories":[{"name":"源码","slug":"源码","permalink":"https://blog.yyshino.top/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"Diffing","slug":"Diffing","permalink":"https://blog.yyshino.top/tags/Diffing/"}]},{"title":"React基础","slug":"React","date":"2022-05-15T14:32:04.000Z","updated":"2022-09-16T10:33:38.763Z","comments":true,"path":"posts/35233.html","link":"","permalink":"https://blog.yyshino.top/posts/35233.html","excerpt":"","text":"React简介React 是一个用于构建用户界面的 JavaScript 库。 声明式： React 让创建交互式 UI 变得轻松。为应用程序中的每个状态设计简单的视图，当你的数据发生变化时，React 将有效地更新和呈现正确的组件。声明式视图使您的代码更可预测、更易于理解和更易于调试。 基于组件：构建管理其状态的封装组件，然后将它们组合成复杂的 UI。由于组件逻辑是用 JavaScript 而不是模板编写的，因此您可以轻松地通过应用程序传递丰富的数据并将状态保持在 DOM 之外。 一次学习，随处编写：我们不对您的技术堆栈的其余部分做出假设，因此您可以在 React 中开发新功能而无需重写现有代码。React 还可以使用 Node 在服务器上呈现，并使用React Native为移动应用程序提供动力。 jsx语法规则: 1.创建虚拟DOM时，不要用引号 2.标签中想混入js表达式，需要用{}包裹 3.根标签只能有一个 4.标签必须闭合 5.样式的类名，不要用class，必须用className 6.内联的样式要用下列形式 ( 双括号会报错所以采取图片的形式展现 ) 7.标签可以随意的编写: (1).若标签首字母是【小写】的,则react会尝试将当前的jsx标签对应成一个html标签 ​ 若对应成了,直接渲染,展示 ​ 若无法对应,直接报错 (1).若标签首字母是【大写】的,react会查找Haha组件的定义的位置 若找见了,直接渲染Haha组件 若未找见,报错(Haha is not defined) 组件函数式组件 &lt;script type=\"text/babel\"> //1.定义组件(函数式组件) function MyComponent(){ console.log(this); //此处的this是undefined，因为经过babel的编译后，开启了严格模式。 return &lt;h2>我是用函数定义的组件（适用于【简单组件】的定义）&lt;/h2> } function MyComponent2(){ console.log(this); //此处的this是undefined，因为经过babel的编译后，开启了严格模式。 return &lt;h2>我是用函数定义的组件（适用于【简单组件】的定义2）&lt;/h2> } //2.渲染组件到页面 ReactDOM.render(&lt;MyComponent/>,document.getElementById('test')) ReactDOM.render(&lt;MyComponent2/>,document.getElementById('test2')) /* 执行了ReactDOM.render后，发生了什么？ 1.React发现了&lt;MyComponent/>标签，去寻找MyComponent组件定义的位置，发现MyComponent是用函数定义的。 2.React调用MyComponent并获取MyComponent返回的虚拟DOM，随后转为真实DOM，随后渲染到页面。 */ &lt;/script> 类式组件 &lt;script type=\"text/babel\"> //定义组件 class MyComponent extends React.Component{ //render是放在哪里的？ —————— MyComponent的原型对象上，是给MyComponent的 实例对象用的。 render(){ console.log(this); //MyComponent的实例对象 &lt;==> MyComponent组件实例对象 return &lt;h2>我是用类定义的组件（适用于【复杂组件】的定义）&lt;/h2> } } //渲染组件到页面 ReactDOM.render(&lt;MyComponent/>,document.getElementById('test')) /* 执行了ReactDOM.render后，发生了什么？ 1.React发现了&lt;MyComponent/>标签，去寻找MyComponent组件定义的位置，发现MyComponent是用类定义的。 2.React new了一个MyComponent实例对象--m 3.通过m调用到了MyComponent原型上的render方法，并获取到了返回的虚拟DOM，随后转为真实DOM，放在页面。 */ &lt;/script> 生命周期相关旧(react16.4之前) 初始化阶段: 由ReactDOM.render()触发—初次渲染 1. constructor() 2. componentWillMount() 3. render() 4. &#x3D;&#x3D;componentDidMount() ====&gt; 常用 一般在这个钩子中做一些初始化的事，例如：开启定时器、发送网络请求、订阅消息&#x3D;&#x3D; 更新阶段: 由组件内部this.setSate()或父组件render触发this.forceUpdate()1. shouldComponentUpdate() 注意：强制更新不走“阀门” 2. componentWillUpdate() 3. &#x3D;&#x3D;render()&#x3D;&#x3D; componentDidUpdate() 卸载组件: 由ReactDOM.unmountComponentAtNode()触发 &#x3D;&#x3D;componentWillUnmount() ====&gt; 常用&#x3D;&#x3D; &#x3D;&#x3D;一般在这个钩子中做一些收尾的事，例如：关闭定时器、取消订阅消息&#x3D;&#x3D; 新(react16.4之后) 组件总结 最重要的三组件 componentDidMount() render() componentWillUnmount() 组件的三大属性 state 用来存储状态 严重注意:状态(state)中值是不能直接修改的！！！下面这一行就是直接修改 this.state.isHot = true; 需要通过this.setState()方法来修改 props 用于接收标签中传递的数据 refs 简介：对标签的一种标识，用于获取数据。类式标签中的id 三种形式 字符串形式: &lt;input ref=\"input1\" type=\"text\" placeholder=\"点击按钮提示输入\"/> 回调形式(推荐): &lt;input ref={c => {this.input1 = c}} type=\"text\" placeholder=\"点击按钮提示输入\"/> createRef形式: container1 = React.createRef() //创建一个createRef() ，只能存储一个ref render(){ return( &lt;div> &lt;input ref={this.container1} type=\"text\" placeholder=\"点击按钮提示输入\"/> &lt;button onClick={this.showData}>点我提示数据&lt;/button> &lt;input ref={this.container2} onBlur={this.showData2} type=\"text\" placeholder=\"点击焦点提示输入\"/> &lt;/div> ) } React中的事件处理 通过onXxx属性指定事件处理函数(注意大小写) ​ 1)React使用的是自定义(合成)事件, 而不是使用的原生DOM事件 ———————— 为了更好的兼容性 ​ 2)React中的事件是通过事件委托方式处理的(委托给组件最外层的元素) ———————— 为了提高效率 通过event.target得到发生事件的DOM元素对象 受控组件和非受控组件 非受控的概念：现用现取 受控的概念：组件中输入类的DOM，随着用户的输入，将输入的值维护到state中 高阶函数_函数的柯里化 高阶函数：如果一个函数符合下面2个规范中的任何一个，那该函数就是高阶函数 ​ 1.若A函数，接收的参数是一个函数，那么A就可以称之为高阶函数。 ​ 2.若A函数，调用的返回值依然是一个函数，那么A就可以称之为高阶函数。 ​ 常见的有：Promise、setTimeout、arr.forEach()….. 函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后 统一处理 的函数编码形式 React脚手架react脚手架包含内容 xxx脚手架: 用来帮助程序员快速创建一个基于xxx库的模板项目 包含了所有需要的配置（语法检查、jsx编译、devServer…） 下载好了所有相关的依赖 可以直接运行一个简单效果 react提供了一个用于创建react项目的脚手架库: create-react-app 项目的整体技术架构为: react + webpack + es6 + eslint 使用脚手架开发的项目的特点: 模块化, 组件化, 工程化 使用方法创建项目并启动 第一步，全局安装： npm i -g create-react-app 第二步，切换到想创项目的目录，使用命令： create-react-app hello-react 第三步，进入项目文件夹： cd hello-react 第四步，启动项目： npm start 项目结构 public ---- 静态资源文件夹 favicon.icon ------ 网站页签图标 index.html -------- 主页面 logo192.png ------- logo图 logo512.png ------- logo图 manifest.json ----- 应用加壳的配置文件 robots.txt -------- 爬虫协议文件 src ---- 源码文件夹 App.css -------- App组件的样式 App.js --------- App组件 App.test.js ---- 用于给App做测试 index.css ------ 样式 index.js ------- 入口文件 logo.svg ------- logo图 reportWebVitals.js --- 页面性能分析文件(需要web-vitals库的支持) setupTests.js ---- 组件单元测试的文件(需要jest-dom库的支持)","categories":[{"name":"React","slug":"React","permalink":"https://blog.yyshino.top/categories/React/"}],"tags":[{"name":"React","slug":"React","permalink":"https://blog.yyshino.top/tags/React/"}]},{"title":"webpack","slug":"webpack","date":"2022-05-15T04:21:18.000Z","updated":"2022-08-26T09:44:07.212Z","comments":true,"path":"posts/15317.html","link":"","permalink":"https://blog.yyshino.top/posts/15317.html","excerpt":"","text":"webpack简介 webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。————webpack文档 简单的配置文件 /* 1. 该文件是webpack的配置文件，所有的webpack的任务、用到的loader、plugins都要配置在这里 2. 该文件要符合CJS模块化规范 */ // 引入Node中一个内置的path模块，专门用于解决路劲问题 const {resolve} = require('path'); // 引入html-webpack-plugin ，用于加工html文件 const HtmlWebpackPlugin = require('html-webpack-plugin'); // 引入 // const Webpack = require('webpack'); // const WebpackDevServer = require('webpack-dev-server'); //css 相关loader配置 const baseCssLoader = ['style-loader','css-loader'] // 使用CJS的模块化规范，暴露一个对象，该对象就是webpack的详细配置对象（规则） module.exports = { mode: 'development', //工作模式 entry: './src/js/app.js', //入口 output: { //出口（输出） path: resolve(__dirname, 'build'), //输出文件的路径 filename: 'js/app.js', //输出文件名字 }, // module.rules中配置的一个一个的loader module: { rules: [ // 配置解析css { test:/\\.css$/, use:[...baseCssLoader] }, // 配置解析less { test:/\\.less$/, use:[ ...baseCssLoader,// creates style nodes from JS strings and translates CSS into CommonJS 'less-loader' // compiles Less to CSS ] }, // 配置解析样式中的图片 { test: /\\.(png|jpg|gif|bmp)$/, use: [{ loader:'url-loader', options:{ outputPath:'imgs', //配置图片加工后，，存放的位置 // publicPath:'/build/imgs' //配置图片引入时前缀的路径 name:'[hash:5].[ext]', //配置生成图片的名字+后缀 limit:8 * 1024 //图片大小，小于8kb时，将图片转为base64编码 } } ], }, // 配置解析html中的图片 { test:/\\.(html)$/, use:['html-loader'] }, // 配置解析字体文件 { exclude: /\\.(html|less|css|js|json|png|jpg|bmp|gif)$/, use: [{ loader:'file-loader', options:{ outputPath:'media', //配置图片加工后，，存放的位置 // publicPath:'/build/imgs' //配置图片引入时前缀的路径 name:'[hash:5].[ext]', //配置生成图片的名字+后缀 } } ], }, ], }, // plugins中专门用于配置插件，插件必须经过实例化这一环节 plugins:[ new HtmlWebpackPlugin({ template:'./src/index.html' //模板的位置 }) ], // 配置devServer devServer:{ // static:'./build', port:5500, //开启服务器的端口号 open:true, //自动打开浏览器 hot:true //模块热更新(热膜替换) } };","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://blog.yyshino.top/tags/webpack/"}]},{"title":"ES6","slug":"ES6","date":"2022-05-15T03:17:07.000Z","updated":"2022-08-26T09:39:51.448Z","comments":true,"path":"posts/13229.html","link":"","permalink":"https://blog.yyshino.top/posts/13229.html","excerpt":"","text":"箭头函数 定义：箭头函数表达式的语法比函数表达式更简洁，并且没有自己的this，arguments，super或new.target。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。 特点： 1.this 的值是静态的 (等于 外层作用域下this的值) let getName2 =() =>{ console.log(this); } getName2.call({}) 2.不能作为构造函数使用 const Person = () =>{} let me = new Person(); 3.不能使用 arguments function fn(){ console.log(arguments); //arguments是一个伪数组 } fn(1,2,3,4,5,6); fn = () =>{ console.log(arguments); } fn(1,2,3,4,5,6); 4.箭头函数简写 一 不写小括号，当新参有且只有一个的时候 二 不写花括号, 当代码体只有一条语句的时候, 并且语句的执行结果为函数返回值的 (如果不 let pow = num =>{ return num * num; } console.log(pow); …运算符 // ...运算符 是扩展运算符 // 打包和拆包 要么是数组要么是对象 // 对于打包只有一种情况是打包并且打包只能打包数组 // 数组的打包和拆包 let arr = [1,2,3,4] // 拆包 数组可以直接拆包 console.log(...arr); console.log(1,2,3,4,...arr); // 数组打包 function add(a,b,...arr){ console.log(arr); console.log(arr instanceof Array); } add(1,2,3,4,5,6,7,8,9,10) // 对象只能拆包 不能直接拆包 let obj = { name:'zly', age:33 } console.log({...obj}); 模块化暴露模块的方式 //使用【分别暴露】 export const teacher1 = {name:'强哥',age:15} export const teacher2 = {name:'歌神',age:17} //使用【统一暴露】 const stu1 = {name:'王宇',age:18} const stu2 = {name:'宇航',age:19} export {stu1,stu2} //使用【默认暴露】 export default { school:'尚硅谷', address:'宏福科技园', subjects:['前端','java','大数据'] } 引入暴露模块方式 //引入【分别暴露】的模块 import {data,showData,showMsg} from './module1' //引入【分别暴露】的模块+重命名 import {data as data2} from './module2' //引入【分别暴露】+ 打包引入 import * as module1 from './module1' //引入【统一暴露】支持上面三种引入方式 import {school as d,getLaoliu,person,} from './module3' //引入【默认暴露】 import module4 from './module4' //引入多种暴露方式的模块 import module5,{teacher1,teacher2,stu1,stu2} from './module5'","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ES6","slug":"ES6","permalink":"https://blog.yyshino.top/tags/ES6/"}]},{"title":"AJAX_AXIOS","slug":"AJAX-AXIOS","date":"2022-05-14T12:00:35.000Z","updated":"2022-08-26T09:38:14.471Z","comments":true,"path":"posts/20614.html","link":"","permalink":"https://blog.yyshino.top/posts/20614.html","excerpt":"","text":"Ajax简介 Asynchronous JavaScript + XML（异步JavaScript和XML）, 其本身不是一种新技术，而是一个在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML 或 XHTML, CSS, JavaScript, DOM, XML, XSLT, 以及最重要的 XMLHttpRequest。当使用结合了这些技术的AJAX模型以后， 网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。这使得程序能够更快地回应用户的操作。尽管X在Ajax中代表XML, 但由于JSON的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。JSON和XML都被用于在Ajax模型中打包信息。————MDN文档 实现界面无刷新获取数据 利用Ajax发送请求get请求 // 发送 ajax请求 //1.创建Xhr实例对象 const xhr = new XMLHttpRequest(); // 绑定监听 xhr.onreadystatechange = () => { // 函数体 if (xhr.readyState == 4) { if (xhr.status >= 200 &amp;&amp; xhr.status &lt;= 300) { console.log(xhr.response); content.innerHTML = `&lt;h3>${xhr.response}&lt;/h3>` } } } // 2.指定发送请求的: method、url、参数 /* 1.形如：key=value&amp;key=value 就是query参数是surlencoded编码 2.形如：/xx/xxx/老刘/18 就是params参数 */ // xhr.open('GET', 'http:///127.0.0.1:8080/test_get?name=老刘&amp;age=18'); // 携带query参数 xhr.open('GET', 'http:///127.0.0.1:8080/test_get2/老刘/18'); //携带 // 3.发送请求 xhr.send(); post请求 // 发送 ajax请求 //1.创建Xhr实例对象 const xhr = new XMLHttpRequest(); // 绑定监听 xhr.onreadystatechange = () => { // 函数体 if (xhr.readyState == 4) { if (xhr.status >= 200 &amp;&amp; xhr.status &lt;= 300) { console.log(xhr.response); content.innerHTML = `&lt;h3>${xhr.response}&lt;/h3>` } } } // 2.指定发送请求的: method、url、参数 /* 1.形如：key=value&amp;key=value 就是query参数是surlencoded编码 2.形如：/xx/xxx/老刘/18 就是params参数 */ // xhr.open('GET', 'http:///127.0.0.1:8080/test_get?name=老刘&amp;age=18'); //携带query参数 xhr.open('POST', 'http:///127.0.0.1:8080/test_post'); //携带 //追加响应头用于标识携带参数的编码形式---urlencoded // xhr.setRequestHeader('Content-type','application/x-www-form-urlencoded') //追加响应头用于标识携带参数的编码形式---json xhr.setRequestHeader('Content-type','application/json') // 3.发送请求 const person = {name:'老刘',age:18} // xhr.send('name=老刘&amp;age=18'); //携带urlencoded编码形式的请求体参数 //send中的参数 为请求体参数 //send中 参数的 编码格式为 urlencoded xhr.send(JSON.stringify(person)) //携带json编码形式的请求参数 Axios简介 Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。特性 从浏览器创建 XMLHttpRequests 从 node.js 创建 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防御XSRF————Axios官网 三种参数 params 参数是路径的一部分，并且这个参数只能在url路径当中出现 query 查询参数 这个参数可以出现在url当中也可以 出现在配置项当中配置url当中是 ? 后面的 key &#x3D; value &amp;key &#x3D;value在配置项当中 配置项的名称叫做params body 请求体参数 通常用在post和put当中，只能在配置对象当中配置; data这个配置项就是你的body请求体参数,这个数据必须是一个对象 注意： 携带query参数时，编写的配置项叫做params 携带params参数时，就需要自己手动拼在url中利用Axios发送请求 get请求const axios = require('axios'); // 向给定ID的用户发起请求 axios.get('/user?ID=12345') .then(function (response) { // 处理成功情况 console.log(response); }) .catch(function (error) { // 处理错误情况 console.log(error); }) .then(function () { // 总是会执行 }); // 上述请求也可以按以下方式完成（可选） axios.get('/user', { params: { ID: 12345 } }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }) .then(function () { // 总是会执行 }); // 支持async/await用法 async function getUser() { try { const response = await axios.get('/user?ID=12345'); console.log(response); } catch (error) { console.error(error); } } post请求axios.post('/user', { firstName: 'Fred', lastName: 'Flintstone' }) .then(function (response) { console.log(response); }) .catch(function (error) { console.log(error); }); 发起多个并发请求 function getUserAccount() { return axios.get('/user/12345'); } function getUserPermissions() { return axios.get('/user/12345/permissions'); } Promise.all([getUserAccount(), getUserPermissions()]) .then(function (results) { const acct = results[0]; const perm = results[1]; }); 拦截器请求拦截器 axios.interceptors.request.use(): 添加请求拦截器 1.是什么？ 在真正发请求前执行的一个回调函数 2.作用： 对所有的请求做统一的处理：追加请求头、追加参数、界面loading提示等等 响应拦截器 axios.interceptors.response.use(): 添加响应拦截器 1.是什么？ 得到响应之后执行的一组回调函数 2.作用： ​- 若请求成功，对成功的数据进行处理 ​- 若请求失败，对失败进行统一的操作 async和await简介 async awiat 是使用同步代码实现异步效果 返回值 async 函数返回的是promise async 函数返回值不看 return 必然返回promise async 函数返回的promise是成功还是失败 看return return的结果代表promise是成功还是失败 1、如果return是一个非promise的值 代表async函数返回的promise是成功 - 成功的结果是return的结果 2、如果返回的是成功的promise 代表async函数返回的promise函数返- mise也是成功的（他们不是一个promise） 成功的结果是return的promise的成功结果 3、如果返回的是失败的promise 代表async函数返回的promise是失败的 失败的原因是return的promise失败的原因 4、如果throw出错误，代表async函数返回的promise是失败的 失败的原因是抛出的错误的原因 解决跨域1、配置代理服务器 devServer:{ //只用与开发环境 proxy:{ 'api':{ //支队请求路由以/api开头的其你去进行代理转发 target:'http://gmall-h5-api.atguigu.cn', //转发的目标url changeOrigin:true, //支持跨域 // pathRewrite:{'^/api':''} // 后台接口都有/api } } } 2、jsonp解决跨域跨域1、是什么​ 浏览器上的同源策略 特点：​ 1、跨域只存在于浏览器​ 2、不在浏览器发请求是不会存在跨域问题的​ 3、http请求分为两大类： 普通http请求和ajax请求（跨域是出现在ajax请求） 1、普通请求和ajax请求区别​ 普通请求 一般只有get（a标签和地址栏输入回车）和 post(form表单) 页面会刷新 不会跨域​ ajax请求 一般 get post delete put 一般都是异步发送的 页面不刷新 局部更新 2、在什么地方会出现跨域 浏览器给服务器发ajax请求会跨域 因为跨域（同源策略）只存在于浏览器 服务器给服务器发ajax请求不会 3、什么条件会跨域 同源（协议 ip 端口一致）不跨域 不同源就跨域（三个中间有一个不一样就跨域） http://localhost:8080/ ——- 》 github 4、解决跨域：前端可以解决、后端解决。一般后端解决比前端解决容易 // 1.创建script节点 const scriptNode = document.createElement('script') // 2.给节点指定src属性（请求地址） scriptNode.src = 'http://localhost:8080/test_jsonp?callback=peiqi'; // 3.将节点放入界面 document.body.appendChild(scriptNode) window.peiqi = (a) =>{ console.log(a); } //5.移除已经使用过的script节点 document.body.removeChild(scriptNode) //总结：Jsonp解决跨域，本质上是避开了 xhr 不受同源策略的限制 利用 //script 标签发起请求，拿到数据 3、cors解决跨域（后端） node.js //在后端服务器 添加特殊响应头 response.setHeader('Access-Control-Allow-Origin','*') response.setHeader('Access-Control-Expose-Origin','*') response.setHeader('Access-Control-Allow-Methods','*') //引入cors包 use(cors()) //可以直接为所有请求添加特殊响应头","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"ajax/axios","slug":"ajax-axios","permalink":"https://blog.yyshino.top/tags/ajax-axios/"}]},{"title":"HTTP","slug":"HTTP","date":"2022-05-14T08:50:27.000Z","updated":"2022-08-26T09:40:02.250Z","comments":true,"path":"posts/35944.html","link":"","permalink":"https://blog.yyshino.top/posts/35944.html","excerpt":"","text":"HTTP定义 超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使开发和部署非常地直截了当。 ————百度 实战利用http模块创建一个简单的服务器 // 1.引入 http 模块 const http = require('http'); // 2.调用方法 创建服务器对象 /* * request 请求报文的封装对象 * response 响应报文的封装对象 */ const server = http.createServer(function(request,response){ response.end('Hello HTTP server'); }); // 3.监听端口 启动服务 /* 端口号 计算的服务端口窗口 总共65536个 8000 3000 9000 8080 默认端口 80 ctrl + c 停止服务 */ server.listen(8000,function(){ console.log('服务器已经启动，端口 8000 坚挺中......'); }) 将服务器拆分为 不同组件 主函数 app.js const server = require('./server'); server(8000); 回调函数 callback.js module.exports = (request,response) =>{ response.end('Hello NPM'); }; 服务对象 server.js module.exports = function (port) { const http = require('http'); // 2.调用方法 创建服务器对象 /* * request 请求报文的封装对象 * response 响应报文的封装对象 */ const callback = require('./callback'); const serverCb = require('./serverOkCallback') const server = http.createServer(callback); // 3.监听端口 启动服务 server.listen(port, serverCb); } 监听端口 serverOkCallback.js module.exports = () =>{ console.log('服务器已经启动，端口坚挺中......'); } 在server.js中我们可以做很多事情 // 获取请求报文 GET /s?wd=关键字 (URL) HTTP/1.1 // 1.请求的类型 // console.log(request.method); // console.log(request.method); // 2.请求的URL // console.log(request.url); // 3.HTTP协议版本 // console.log(request.httpVersion); // 4.获取URL中的路径部分 // 二 调用方法获取参数 // console.log(url.parse(request.url).pathname); // 5.获取查询字符串 // console.log(url.parse(request.url,true).query); // 6.请求头信息 // console.log(request.headers); 也可以添加事件 // 提取请求体数据 POST请求 // 1.声明一个字符串变量 let body = ''; // 2.绑定data事件 request.on('data',chunk =>{ // 拼接 body += chunk.toString(); }); // 3.绑定end事件 request.on('end',()=>{ console.log(body); // 调用 qs 对象的方法 console.log(qs.parse(body)); response.end('body recevie'); })","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://blog.yyshino.top/tags/HTTP/"}]},{"title":"正则表达式","slug":"zhengze","date":"2022-05-14T06:44:57.000Z","updated":"2022-09-16T10:34:24.909Z","comments":true,"path":"posts/46563.html","link":"","permalink":"https://blog.yyshino.top/posts/46563.html","excerpt":"","text":"","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.yyshino.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"}]},{"title":"Javascript","slug":"Javascript","date":"2022-05-13T01:10:55.000Z","updated":"2022-08-14T14:36:47.180Z","comments":true,"path":"posts/9809.html","link":"","permalink":"https://blog.yyshino.top/posts/9809.html","excerpt":"","text":"JavaScript遍历相关 - for 最基本的循环 用来专门遍历数组的 可以使用break和continue - for in 专门用来遍历对象的属性的，这个属性能遍历到还是遍历不到要看这个属性是不是 ​ // for in 效率最低，因为除了遍历自身以外还要遍历原型 - for of - ​ // 专门遍历可迭代的数据 ... (能用可迭代，就用三点) - ​ // 数组有迭代器 - ​ // 对象没有 - forEach 是一个数组的方法，效率极高 但是不可以使用break和continue 数组方法everyparseInt() 描述 parseInt(string, radix) 解析一个字符串并返回指定基数的十进制整数， radix 是2-36之间的整数，表示被解析字符串的基数。 语法参数 parseInt(string, radix); 参数 string 要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用 ToString 抽象操作)。字符串开头的空白符将会被忽略。 radix 可选 从 2 到 36，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！文章后面的描述解释了当参数 radix 不传时该函数的具体行为。 返回值 从给定的字符串中解析出的一个整数。 或者 NaN，当 radix 小于 2 或大于 36 ，或 第一个非空格字符不能转换为数字。 parseInt('123', 5) // 将'123'看作5进制数，返回十进制数38 => 1*5^2 + 2*5^1 + 3*5^0 = 38 includes() 描述 方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`。 语法以及参数 arr.includes(valueToFind[, fromIndex]) valueToFind 需要查找的元素值。 备注：使用 includes()比较字符串和字符时是区分大小写的。 fromIndex 可选 从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。 返回值 返回一个布尔值 Boolean 。 ]如果在数组中（或 fromIndex 指定的范围中）找到了 valueToFind，则返回 true，否则返回 false。 0 的值将全部视为相等，与符号无关（即 -0 与 0 和 +0 相等）， 但 false 不被认为与 0 相等。 备注： 技术上来讲，includes() 使用 零值相等 算法来确定是否找到给定的元素。 示例 [1, 2, 3].includes(2); // true [1, 2, 3].includes(4); // false [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true [1, 2, NaN].includes(NaN); // true 注意 fromIndex 大于等于数组长度 如果 fromIndex 大于等于数组的长度，则将直接返回 false，且不搜索该数组。 计算出的索引小于 0 如果 fromIndex 为负值，计算出的索引将作为开始搜索searchElement的位置。如果计算出的索引小于 0，则整个数组都会被搜索。 作为通用方法的 includes() includes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。下面的例子展示了 在函数的 arguments 对象上调用的 includes() 方法。 find() 描述 find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。 语法以及参数 arr.find(callback[, thisArg]) 参数 callback 在数组每一项上执行的函数，接收 3 个参数： element 当前遍历到的元素。 index可选 当前遍历到的索引。 array可选 数组本身。 thisArg可选 执行回调时用作this 的对象。 返回值 数组中第一个满足所提供测试函数的元素的值，否则返回 undefined。 MDN sort() 描述 sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的 语法及参数 arr.sort([compareFunction]) 参数 compareFunction 可选 用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。 firstEl 第一个用于比较的元素。 secondEl 第二个用于比较的元素。 返回值 排序后的数组。请注意，数组已原地排序，并且不进行复制。 注意 也会影响原数组，默认会按照Unicode编码进行排序 带有compareFunction 参数时, 如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前； 如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）； 如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。 、、、通俗理解 比较函数应该具有两个参数 a 和 b，其返回值如下： 若 a 小于 b，即 a - b 小于零，则返回一个小于零的值，数组将按照升序排列。 若 a 等于 b，则返回 0。 若 a 大于 b, 即 a - b 大于零，则返回一个大于零的值，数组将按照降序排列。 MDN 简单使用 filter() 描述 filter() 方法创建一个新的数组，新数组中的元素是通过==检查指定数组中符合条件==的所有元素。 语法以及参数 array.filter(function(currentValue,index,arr), thisValue) function(currentValue, index,arr) 必须。函数，数组中的每个元素都会执行这个函数 函数参数: currentValue 必须。当前元素的值 index 可选。当前元素的索引值 arr 可选。当前元素属于的数组对象 thisValue 可选。对象作为该执行回调时使用，传递给函数，用作 \"this\" 的值。 如果省略了 thisValue ，\"this\" 的值为 \"undefined\" 返回值 一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。 总结 //用作过滤器 array.filter((currentValue,index,arr) => { return (过滤条件) }, thisValue) 注意： filter() 不会对空数组进行检测。 注意： filter() 不会改变原始数组。 reduce 语法: - arr.reduce((preValue, current, index, arr)=>f),initialValue) // 箭头函数 reduce((previousValue, currentValue) => { /* ... */ } ) reduce((previousValue, currentValue, currentIndex) => { /* ... */ } ) reduce((previousValue, currentValue, currentIndex, array) => { /* ... */ } ) reduce((previousValue, currentValue, currentIndex, array) => { /* ... */ }, initialValue) // 回调函数 reduce(callbackFn) reduce(callbackFn, initialValue) // 内联回调函数 reduce(function(previousValue, currentValue) { /* ... */ }) reduce(function(previousValue, currentValue, currentIndex) { /* ... */ }) reduce(function(previousValue, currentValue, currentIndex, array) { /* ... */ }) reduce(function(previousValue, currentValue, currentIndex, array) { /* ... */ }, initialValue) arr:当前操作的数组 ==**preValue**:**第一次**执行回调时为给定的**初始值initialValue**,**以后是上一次执行回调时的返回值**。== ​ ==备注:若**没有传入initialValue**,则第一次的preValue值是数组中**第一个元素的值**。== **current 表示当前正在处理的元素;** index 表示当前正在处理的数组元素的索引,若传入了initialValue值,则为0,否则为1; array 当前操作的数组(就是arr) **initialValue 表示初始值。一般做数学时设置为0,若为筛选最值可以不传。 用于数据分析 let arr = [1,2,3,4,5,6,7,8,9,10,9] // 数组求和 /* const x = arr.reduce((preValue,current)=>{ console.log(preValue,current); return preValue+current }) console.log(x); */ // 数组中偶数的和----(条件求和) // const x = arr.reduce((preValue,current)=>preValue+(current % 2 === 0 ? current:0),0) // console.log(x); //数组中偶数有几个---(条件统计) // const x = arr.reduce((preValue,current)=>preValue+(current%2===0 ? 1:0),0) // console.log(x); // 数组中所有偶数的积 // const x = arr.reduce((preValue,current)=>preValue*(current%2===0 ? current:1),1) // console.log(x); // 数组中最小值----(筛选最值) /* const x = arr.reduce((preValue,current)=> { console.log(preValue,current); return Math.max(preValue,current) },1) console.log(x); map 描述 map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。 语法 var new_array = arr.map(function callback(currentValue[, index[, array]]) { //为new_array返回元素 }[, thisArg]) 参数 `callback` 生成新数组元素的函数，使用三个参数： `currentValue` `callback` 数组中正在处理的当前元素。 `index`可选 `callback` 数组中正在处理的当前元素的索引。 `array`可选 `map` 方法调用的数组。 `thisArg`可选 执行 `callback` 函数时值被用作`this`。 返回值 一个由原数组每个元素执行回调函数的结果组成的新数组。 例 简单用法 const array1 = [1, 4, 9, 16]; // pass a function to map const map1 = array1.map(x => x * 2); console.log(map1); // expected output: Array [2, 8, 18, 32] 注意： map() 不会对空数组进行检测。 map() 不会改变原始数组。 官方文档 push() 该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度 可以将要添加的元素作为方法的参数传递， 这样这些元素将会自动添加到数组的末尾 该方法会将数组新的长度作为返回值返回 pop() 该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回 unshift() 向数组开头添加一个或多个元素，并返回新的数组长度 向前边插入元素以后，其他的元素索引会依次调整 shift() 可以删除数组的第一个元素，并将被删除的元素作为返回值返回 slice()可以用来从数组提取指定元素 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回 参数：1.截取开始的位置的索引, 包含 开始索引2.截取结束的位置的索引, 不包含 结束索引 第二个参数可以省略不写,此时会截取从开始索引往后的所有元素 索引可以传递一个负值，如果传递一个负值，则从后往前计算-1 倒数第一个-2 倒数第二个 splice() 描述（增删改一体化） 可以用于删除数组中的指定元素 - 参数： 第一个，表示开始位置的索引 第二个，表示删除的数量 第三个 及以后。。 可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边 注意 使用splice()会影响到原数组，会将指定元素从原数组中删除，被删除的元素作为返回值返回 ​ concat() 可以连接两个或多个数组，并将新的数组返回 该方法不会对原数组产生影响 join()该方法可以将数组转换为一个字符串 该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回 在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符 如果不指定连接符，则默认使用,作为连接符 reverse() 该方法用来反转数组（前边的去后边，后边的去前边） - 该方法会直接修改原数组 字符串方法indexOf() 描述 indexOf()方法返回调用它的 String 对象中**第一次出现的指定值的索引**，从 **fromIndex** 处进行搜索。如果未找到该值，则返回 -1。 语法 str.indexOf(searchValue [, fromIndex]) 参数 searchValue 要被查找的字符串值。如果没有提供确切地提供字符串，searchValue 会被强制设置为 \"undefined\"， 然后在当前字符串中查找这个值。举个例子：'undefined'.indexOf() 将会返回0，因为 undefined 在位置0处被找到，但是 'undefine'.indexOf() 将会返回 -1 ，因为字符串 'undefined' 未被找到。 fromIndex 可选 数字表示开始查找的位置。可以是任意整数，默认值为 0。如果 fromIndex 的值小于 0，或者大于 str.length ，那么查找分别从 0 和str.length 开始。（译者注： fromIndex 的值小于 0，等同于为空情况； fromIndex 的值大于或等于 str.length ，那么结果会直接返回 -1 。）举个例子，'hello world'.indexOf('o', -5) 返回 4 ，因为它是从位置0处开始查找，然后 o 在位置4处被找到。另一方面，'hello world'.indexOf('o', 11) （或 fromIndex 填入任何大于11的值）将会返回 -1 ，因为开始查找的位置11处，已经是这个字符串的结尾了。 返回值 查找的字符串 searchValue 的第一次出现的索引，如果没有找到，则返回 -1。 若被查找的字符串 searchValue 是一个空字符串，将会产生“奇怪”的结果。如果 fromIndex 值为空，或者 fromIndex 值小于被查找的字符串的长度，返回值和以下的 fromIndex 值一样： 'hello world'.indexOf('') // 返回 0 'hello world'.indexOf('', 0) // 返回 0 'hello world'.indexOf('', 3) // 返回 3 'hello world'.indexOf('', 8) // 返回 8 另外，如果 fromIndex 值大于等于字符串的长度，将会直接返回字符串的长度（str.length）： 'hello world'.indexOf('', 11) // 返回 11 'hello world'.indexOf('', 13) // 返回 11 'hello world'.indexOf('', 22) // 返回 11 从前面一个例子可以看出，被查找的值是空值时，Javascript将直接返回指定的索引值。从后面一个例子可以看出，被查找的值是空值时，Javascript将直接返回字符串的长度。 注意 字符串中的字符被从左向右索引。第一个字符的索引（index）是 0，变量名为 stringName 的字符串的最后一个字符的索引是 stringName.length - 1 indexOf 方法是区分大小写的 注意 0 并不会被当成 true ，-1 不会被当成 false 。所以当检测某个字符串是否存在于另一个字符串中时，可使用下面的方法： 'Blue Whale'.indexOf('Blue') !== -1 // true 'Blue Whale'.indexOf('Bloe') !== -1 // false ~('Blue Whale'.indexOf('Bloe')) // 0, 这是一种错误用法 MDN文档 trim 描述 `trim()`方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR等）。 `trim()` 方法返回一个从两头去掉空白字符的字符串，并不影响原字符串本身。 语法 str.trim() 返回值 一个代表调用字符串两端去掉空白的新字符串。 兼容久环境、 if (!String.prototype.trim) { String.prototype.trim = function () { return this.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, ''); }; } DOM操作//常用DOM操作 getElementById() //返回带有指定ID 的元素。 getElementsByTagName() //返回包含带有指定标签名称的所有元素的节 // 点列表(集合/节点数组)。 getElementsByClassName() //返回包含带有指定类名的所有元素的节 // 点列表。 getElementsByName('a') //通过name属性获取一组元素节点对象 document.querySelector('#a') //通过CSS选择器来获取一个元素节点对象 document.querySelectorAll('span') //通过CSS选择器来获取一组元素节点对象 appendChild() //把新的子节点添加到指定节点。 removeChild() //删除子节点。 replaceChild() //替换子节点。 insertBefore() //在指定的子节点前面插入新的子节点。 createAttribute() //创建属性节点。 createElement() //创建元素节点。 createTextNode() //创建文本节点。 getAttribute() //返回指定的属性值。 setAttribute() //把指定属性设置或修改为指定的值。 当前节点.paretNode //表示当前节点的父节点 当前节点.previousSibling //表示当前节点的前一个兄弟节点 当前节点.nextSibling //表示当前节点的后一个兄弟节点 父节点.firstchild //可以获取第一个子节点(包括空白文本节点) 父节点.firstElementchild //可以获取第一个子元素(不包括空白文本节点) 父节点.childNodes //表示当前节点的所有子节点 BOM操作 浏览器对象模型 BOM可以使我们通过JS来操作浏览器 在BOM中为我们提供了一组对象，用来完成对浏览器的操作 BOM对象 Window 代表的是整个浏览器的窗口，同时window也是网页中的全局对象 Navigator 代表的当前浏览器的信息，通过该对象可以来识别不同的浏览器 Location- 代表当前浏览器的地址栏信息，通过Location可以获取地址栏信息，或者操作浏览器跳转页面 History 代表浏览器的历史记录，可以通过该对象来操作浏览器的历史记录 由于隐私原因，该对象不能获取到具体的历史记录，只能操作浏览器向前或向后翻页而且该操作只在当次访问时有效 Screen 代表用户的屏幕的信息，通过该对象可以获取到用户的显示器的相关的信息 Screen获取元素的大小和位置PC client系列 页可见区域宽： document.body.clientWidth; 网页可见区域高： document.body.clientHeight; offset系列 网页可见区域宽： document.body.offsetWidth (包括边线的宽); 网页可见区域高： document.body.offsetHeight (包括边线的宽); scroll系列 网页正文全文宽： document.body.scrollWidth; 网页正文全文高： document.body.scrollHeight; 网页被卷去的高： document.body.scrollTop; 网页被卷去的左： document.body.scrollLeft; 移动端 网页正文部分上： window.screenTop; 网页正文部分左： window.screenLeft; 屏幕分辨率的高： window.screen.height; 屏幕分辨率的宽： window.screen.width; 屏幕可用工作区高度： window.screen.availHeight; React打基础js &#x3D;&gt; jsx map - 参数 - `callback` - 生成新数组元素的函数，使用三个参数： - `currentValue` - `callback` 数组中正在处理的当前元素。 - `index`可选 - `callback` 数组中正在处理的当前元素的索引。 - `array`可选 - `map` 方法调用的数组。 - `thisArg`可选 - 执行 `callback` 函数时值被用作`this`。 Vue打基础js &#x3D;&gt; vue object.keys(obj) //返回的是参数对象的属性组成的数组，可以用数组的方法forEach去遍历对象 //例如 Object.keys(obj).forEach(item => console.log(item,obj[item])) // Object.defineProperty // 这个方法在为对象添加或者修改 属性为响应式属性 /* 语法 Object.defineProperty(obj, prop, descriptor) 参数 obj 要定义属性的对象。 prop 要定义或修改的属性的名称或 Symbol 。 descriptor 要定义或修改的属性描述符。 返回值 被传递给函数的对象。 */","categories":[{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"js","slug":"js","permalink":"https://blog.yyshino.top/tags/js/"}]}],"categories":[{"name":"模板引擎","slug":"模板引擎","permalink":"https://blog.yyshino.top/categories/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"},{"name":"工具","slug":"工具","permalink":"https://blog.yyshino.top/categories/%E5%B7%A5%E5%85%B7/"},{"name":"实战","slug":"实战","permalink":"https://blog.yyshino.top/categories/%E5%AE%9E%E6%88%98/"},{"name":"大前端","slug":"大前端","permalink":"https://blog.yyshino.top/categories/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"整合","slug":"整合","permalink":"https://blog.yyshino.top/categories/%E6%95%B4%E5%90%88/"},{"name":"我","slug":"我","permalink":"https://blog.yyshino.top/categories/%E6%88%91/"},{"name":"Markdown","slug":"Markdown","permalink":"https://blog.yyshino.top/categories/Markdown/"},{"name":"根基","slug":"根基","permalink":"https://blog.yyshino.top/categories/%E6%A0%B9%E5%9F%BA/"},{"name":"Vue","slug":"Vue","permalink":"https://blog.yyshino.top/categories/Vue/"},{"name":"部署","slug":"部署","permalink":"https://blog.yyshino.top/categories/%E9%83%A8%E7%BD%B2/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://blog.yyshino.top/categories/WebSocket/"},{"name":"web基础","slug":"web基础","permalink":"https://blog.yyshino.top/categories/web%E5%9F%BA%E7%A1%80/"},{"name":"计算机基础知识","slug":"计算机基础知识","permalink":"https://blog.yyshino.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"name":"node后端","slug":"node后端","permalink":"https://blog.yyshino.top/categories/node%E5%90%8E%E7%AB%AF/"},{"name":"数据可视化","slug":"数据可视化","permalink":"https://blog.yyshino.top/categories/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"name":"web进阶","slug":"web进阶","permalink":"https://blog.yyshino.top/categories/web%E8%BF%9B%E9%98%B6/"},{"name":"踩坑","slug":"踩坑","permalink":"https://blog.yyshino.top/categories/%E8%B8%A9%E5%9D%91/"},{"name":"Vue2","slug":"Vue2","permalink":"https://blog.yyshino.top/categories/Vue2/"},{"name":"React","slug":"React","permalink":"https://blog.yyshino.top/categories/React/"},{"name":"源码","slug":"源码","permalink":"https://blog.yyshino.top/categories/%E6%BA%90%E7%A0%81/"}],"tags":[{"name":"ejs","slug":"ejs","permalink":"https://blog.yyshino.top/tags/ejs/"},{"name":"图床","slug":"图床","permalink":"https://blog.yyshino.top/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"vue","slug":"vue","permalink":"https://blog.yyshino.top/tags/vue/"},{"name":"react","slug":"react","permalink":"https://blog.yyshino.top/tags/react/"},{"name":"大前端","slug":"大前端","permalink":"https://blog.yyshino.top/tags/%E5%A4%A7%E5%89%8D%E7%AB%AF/"},{"name":"整合","slug":"整合","permalink":"https://blog.yyshino.top/tags/%E6%95%B4%E5%90%88/"},{"name":"日常","slug":"日常","permalink":"https://blog.yyshino.top/tags/%E6%97%A5%E5%B8%B8/"},{"name":"Markdown","slug":"Markdown","permalink":"https://blog.yyshino.top/tags/Markdown/"},{"name":"根基","slug":"根基","permalink":"https://blog.yyshino.top/tags/%E6%A0%B9%E5%9F%BA/"},{"name":"Vue3","slug":"Vue3","permalink":"https://blog.yyshino.top/tags/Vue3/"},{"name":"网页部署","slug":"网页部署","permalink":"https://blog.yyshino.top/tags/%E7%BD%91%E9%A1%B5%E9%83%A8%E7%BD%B2/"},{"name":"WebSocket","slug":"WebSocket","permalink":"https://blog.yyshino.top/tags/WebSocket/"},{"name":"git命令","slug":"git命令","permalink":"https://blog.yyshino.top/tags/git%E5%91%BD%E4%BB%A4/"},{"name":"计算机科学","slug":"计算机科学","permalink":"https://blog.yyshino.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6/"},{"name":"Koa/Koa2","slug":"Koa-Koa2","permalink":"https://blog.yyshino.top/tags/Koa-Koa2/"},{"name":"echarts","slug":"echarts","permalink":"https://blog.yyshino.top/tags/echarts/"},{"name":"HTML","slug":"HTML","permalink":"https://blog.yyshino.top/tags/HTML/"},{"name":"CSS","slug":"CSS","permalink":"https://blog.yyshino.top/tags/CSS/"},{"name":"java","slug":"java","permalink":"https://blog.yyshino.top/tags/java/"},{"name":"兴趣","slug":"兴趣","permalink":"https://blog.yyshino.top/tags/%E5%85%B4%E8%B6%A3/"},{"name":"TypeScript","slug":"TypeScript","permalink":"https://blog.yyshino.top/tags/TypeScript/"},{"name":"Vue3实战","slug":"Vue3实战","permalink":"https://blog.yyshino.top/tags/Vue3%E5%AE%9E%E6%88%98/"},{"name":"小程序","slug":"小程序","permalink":"https://blog.yyshino.top/tags/%E5%B0%8F%E7%A8%8B%E5%BA%8F/"},{"name":"踩坑","slug":"踩坑","permalink":"https://blog.yyshino.top/tags/%E8%B8%A9%E5%9D%91/"},{"name":"nodejs","slug":"nodejs","permalink":"https://blog.yyshino.top/tags/nodejs/"},{"name":"Vue实战","slug":"Vue实战","permalink":"https://blog.yyshino.top/tags/Vue%E5%AE%9E%E6%88%98/"},{"name":"webpack","slug":"webpack","permalink":"https://blog.yyshino.top/tags/webpack/"},{"name":"Vue2","slug":"Vue2","permalink":"https://blog.yyshino.top/tags/Vue2/"},{"name":"React","slug":"React","permalink":"https://blog.yyshino.top/tags/React/"},{"name":"Diffing","slug":"Diffing","permalink":"https://blog.yyshino.top/tags/Diffing/"},{"name":"ES6","slug":"ES6","permalink":"https://blog.yyshino.top/tags/ES6/"},{"name":"ajax/axios","slug":"ajax-axios","permalink":"https://blog.yyshino.top/tags/ajax-axios/"},{"name":"HTTP","slug":"HTTP","permalink":"https://blog.yyshino.top/tags/HTTP/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://blog.yyshino.top/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"js","slug":"js","permalink":"https://blog.yyshino.top/tags/js/"}]}