<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>webpack</title>
      <link href="/2022/05/15/webpack/"/>
      <url>/2022/05/15/webpack/</url>
      
        <content type="html"><![CDATA[<h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>webpack 是一个用于现代 JavaScript 应用程序的 静态模块打包工具。当 webpack 处理应用程序时，它会在内部从一个或多个入口点构建一个 依赖图(dependency graph)，然后将你项目中所需的每一个模块组合成一个或多个 bundles，它们均为静态资源，用于展示你的内容。————<a href="https://webpack.docschina.org/concepts/">webpack文档</a></li></ul><h4 id="简单的配置文件"><a href="#简单的配置文件" class="headerlink" title="简单的配置文件"></a>简单的配置文件</h4><pre><code>    /*     1. 该文件是webpack的配置文件，所有的webpack的任务、用到的loader、plugins都要配置在这里    2. 该文件要符合CJS模块化规范     */    // 引入Node中一个内置的path模块，专门用于解决路劲问题    const &#123;resolve&#125; = require(&#39;path&#39;);    // 引入html-webpack-plugin ，用于加工html文件    const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;);    // 引入    // const Webpack = require(&#39;webpack&#39;);    // const WebpackDevServer = require(&#39;webpack-dev-server&#39;);    //css  相关loader配置    const baseCssLoader = [&#39;style-loader&#39;,&#39;css-loader&#39;]    // 使用CJS的模块化规范，暴露一个对象，该对象就是webpack的详细配置对象（规则）    module.exports = &#123;    mode: &#39;development&#39;, //工作模式    entry: &#39;./src/js/app.js&#39;,  //入口    output: &#123;  //出口（输出）        path: resolve(__dirname, &#39;build&#39;),  //输出文件的路径        filename: &#39;js/app.js&#39;,  //输出文件名字    &#125;,    // module.rules中配置的一个一个的loader    module: &#123;        rules: [        // 配置解析css        &#123;            test:/\.css$/,            use:[...baseCssLoader]        &#125;,        // 配置解析less        &#123;            test:/\.less$/,            use:[            ...baseCssLoader,// creates style nodes from JS strings and translates CSS into CommonJS            &#39;less-loader&#39;  // compiles Less to CSS        ]        &#125;,        // 配置解析样式中的图片        &#123;            test: /\.(png|jpg|gif|bmp)$/,            use: [&#123;            loader:&#39;url-loader&#39;,            options:&#123;                outputPath:&#39;imgs&#39;,  //配置图片加工后，，存放的位置                // publicPath:&#39;/build/imgs&#39;  //配置图片引入时前缀的路径                name:&#39;[hash:5].[ext]&#39;, //配置生成图片的名字+后缀                limit:8 * 1024    //图片大小，小于8kb时，将图片转为base64编码             &#125;            &#125;            ],        &#125;,        // 配置解析html中的图片        &#123;            test:/\.(html)$/,            use:[&#39;html-loader&#39;]        &#125;,        // 配置解析字体文件        &#123;        exclude: /\.(html|less|css|js|json|png|jpg|bmp|gif)$/,            use: [&#123;            loader:&#39;file-loader&#39;,            options:&#123;                outputPath:&#39;media&#39;,  //配置图片加工后，，存放的位置                // publicPath:&#39;/build/imgs&#39;  //配置图片引入时前缀的路径                name:&#39;[hash:5].[ext]&#39;, //配置生成图片的名字+后缀                            &#125;            &#125;            ],        &#125;,        ],    &#125;,    // plugins中专门用于配置插件，插件必须经过实例化这一环节    plugins:[        new HtmlWebpackPlugin(&#123;        template:&#39;./src/index.html&#39;  //模板的位置        &#125;)    ],    // 配置devServer    devServer:&#123;        // static:&#39;./build&#39;,        port:5500,  //开启服务器的端口号        open:true,  //自动打开浏览器        hot:true    //模块热更新(热膜替换)    &#125;    &#125;;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6</title>
      <link href="/2022/05/15/es6/"/>
      <url>/2022/05/15/es6/</url>
      
        <content type="html"><![CDATA[<h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><ul><li><p>定义：<strong>箭头函数表达式</strong>的语法比<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/function">函数表达式</a>更简洁，并且没有自己的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">this</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/arguments">arguments</a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/super">super</a>或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/new.target">new.target</a>。箭头函数表达式更适用于那些本来需要匿名函数的地方，并且它不能用作构造函数。</p></li><li><p>特点：</p><pre><code>  1.this 的值是静态的 (等于 外层作用域下this的值)  let getName2 =() =&gt;&#123;      console.log(this);  &#125;  getName2.call(&#123;&#125;)    2.不能作为构造函数使用  const Person = () =&gt;&#123;&#125;  let me = new Person();    3.不能使用 arguments  function fn()&#123;      console.log(arguments);      //arguments是一个伪数组  &#125;  fn(1,2,3,4,5,6);  fn = () =&gt;&#123;      console.log(arguments);  &#125;  fn(1,2,3,4,5,6);    4.箭头函数简写  一 不写小括号，当新参有且只有一个的时候  二 不写花括号, 当代码体只有一条语句的时候, 并且语句的执行结果为函数返回值的 (如果不  let pow = num =&gt;&#123;      return num * num;  &#125;  console.log(pow);</code></pre></li></ul><h5 id="…运算符"><a href="#…运算符" class="headerlink" title="…运算符"></a>…运算符</h5><pre><code>      // ...运算符    是扩展运算符         //  打包和拆包    要么是数组要么是对象         // 对于打包只有一种情况是打包并且打包只能打包数组</code></pre><pre><code>    // 数组的打包和拆包    let arr = [1,2,3,4]    // 拆包     数组可以直接拆包    console.log(...arr);    console.log(1,2,3,4,...arr);    // 数组打包    function add(a,b,...arr)&#123;        console.log(arr);        console.log(arr instanceof Array);    &#125;    add(1,2,3,4,5,6,7,8,9,10)        // 对象只能拆包     不能直接拆包      let obj = &#123;          name:&#39;zly&#39;,          age:33      &#125;      console.log(&#123;...obj&#125;);</code></pre><h4 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h4><h5 id="暴露模块的方式"><a href="#暴露模块的方式" class="headerlink" title="暴露模块的方式"></a>暴露模块的方式</h5><pre><code>  //使用【分别暴露】  export const teacher1 = &#123;name:&#39;强哥&#39;,age:15&#125;  export const teacher2 = &#123;name:&#39;歌神&#39;,age:17&#125;    //使用【统一暴露】  const stu1 = &#123;name:&#39;王宇&#39;,age:18&#125;  const stu2 = &#123;name:&#39;宇航&#39;,age:19&#125;  export &#123;stu1,stu2&#125;    //使用【默认暴露】  export default &#123;      school:&#39;尚硅谷&#39;,      address:&#39;宏福科技园&#39;,      subjects:[&#39;前端&#39;,&#39;java&#39;,&#39;大数据&#39;]  &#125;</code></pre><h5 id="引入暴露模块方式"><a href="#引入暴露模块方式" class="headerlink" title="引入暴露模块方式"></a>引入暴露模块方式</h5><pre><code>  //引入【分别暴露】的模块  import &#123;data,showData,showMsg&#125; from &#39;./module1&#39;    //引入【分别暴露】的模块+重命名  import &#123;data as data2&#125; from &#39;./module2&#39;    //引入【分别暴露】+ 打包引入  import * as module1 from &#39;./module1&#39;    //引入【统一暴露】支持上面三种引入方式  import &#123;school as d,getLaoliu,person,&#125; from &#39;./module3&#39;    //引入【默认暴露】  import module4 from &#39;./module4&#39;    //引入多种暴露方式的模块  import module5,&#123;teacher1,teacher2,stu1,stu2&#125; from &#39;./module5&#39;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX_AXIOS</title>
      <link href="/2022/05/14/ajax-axios/"/>
      <url>/2022/05/14/ajax-axios/</url>
      
        <content type="html"><![CDATA[<h3 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>Asynchronous JavaScript + XML（异步JavaScript和XML）, 其本身不是一种新技术，而是一个在 2005年被Jesse James Garrett提出的新术语，用来描述一种使用现有技术集合的‘新’方法，包括: HTML 或 XHTML,  CSS, JavaScript, DOM, XML, XSLT, 以及最重要的 XMLHttpRequest。当使用结合了这些技术的AJAX模型以后， 网页应用能够快速地将增量更新呈现在用户界面上，而不需要重载（刷新）整个页面。这使得程序能够更快地回应用户的操作。<br>尽管X在Ajax中代表XML, 但由于JSON的许多优势，比如更加轻量以及作为Javascript的一部分，目前JSON的使用比XML更加普遍。JSON和XML都被用于在Ajax模型中打包信息。<br>————<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/AJAX">MDN文档</a></li><li><strong>实现界面无刷新获取数据</strong></li></ul><h4 id="利用Ajax发送请求"><a href="#利用Ajax发送请求" class="headerlink" title="利用Ajax发送请求"></a>利用Ajax发送请求</h4><h5 id="get请求"><a href="#get请求" class="headerlink" title="get请求"></a>get请求</h5><pre><code>    // 发送 ajax请求        //1.创建Xhr实例对象        const xhr = new XMLHttpRequest();        // 绑定监听        xhr.onreadystatechange = () =&gt; &#123;            //  函数体            if (xhr.readyState == 4) &#123;                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300) &#123;                    console.log(xhr.response);                    content.innerHTML = `&lt;h3&gt;$&#123;xhr.response&#125;&lt;/h3&gt;`                &#125;            &#125;        &#125;                // 2.指定发送请求的: method、url、参数        /*            1.形如：key=value&amp;key=value 就是query参数是surlencoded编码            2.形如：/xx/xxx/老刘/18 就是params参数        */        // xhr.open(&#39;GET&#39;, &#39;http:///127.0.0.1:8080/test_get?name=老刘&amp;age=18&#39;);   // 携带query参数        xhr.open(&#39;GET&#39;, &#39;http:///127.0.0.1:8080/test_get2/老刘/18&#39;); //携带                // 3.发送请求        xhr.send();</code></pre><h5 id="post请求"><a href="#post请求" class="headerlink" title="post请求"></a>post请求</h5><pre><code>    // 发送 ajax请求        //1.创建Xhr实例对象        const xhr = new XMLHttpRequest();        // 绑定监听        xhr.onreadystatechange = () =&gt; &#123;            //  函数体            if (xhr.readyState == 4) &#123;                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300) &#123;                    console.log(xhr.response);                    content.innerHTML = `&lt;h3&gt;$&#123;xhr.response&#125;&lt;/h3&gt;`                &#125;            &#125;        &#125;                // 2.指定发送请求的: method、url、参数        /*            1.形如：key=value&amp;key=value 就是query参数是surlencoded编码            2.形如：/xx/xxx/老刘/18 就是params参数        */        // xhr.open(&#39;GET&#39;, &#39;http:///127.0.0.1:8080/test_get?name=老刘&amp;age=18&#39;); //携带query参数        xhr.open(&#39;POST&#39;, &#39;http:///127.0.0.1:8080/test_post&#39;); //携带                //追加响应头用于标识携带参数的编码形式---urlencoded        // xhr.setRequestHeader(&#39;Content-type&#39;,&#39;application/x-www-form-urlencoded&#39;)        //追加响应头用于标识携带参数的编码形式---json        xhr.setRequestHeader(&#39;Content-type&#39;,&#39;application/json&#39;)        // 3.发送请求        const person = &#123;name:&#39;老刘&#39;,age:18&#125;        // xhr.send(&#39;name=老刘&amp;age=18&#39;); //携带urlencoded编码形式的请求体参数        //send中的参数 为请求体参数        //send中 参数的 编码格式为 urlencoded        xhr.send(JSON.stringify(person)) //携带json编码形式的请求参数</code></pre><h3 id="Axios"><a href="#Axios" class="headerlink" title="Axios"></a>Axios</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><ul><li>Axios 是一个基于 promise 网络请求库，作用于node.js 和浏览器中。 它是 isomorphic 的(即同一套代码可以运行在浏览器和node.js中)。在服务端它使用原生 node.js http 模块, 而在客户端 (浏览端) 则使用 XMLHttpRequests。<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a><strong>特性</strong></h4><ul><li>从浏览器创建 XMLHttpRequests</li><li>从 node.js 创建 http 请求</li><li>支持 Promise API</li><li>拦截请求和响应</li><li>转换请求和响应数据</li><li>取消请求</li><li>自动转换JSON数据</li><li>客户端支持防御XSRF<br>————<a href="https://axios-http.com/zh/docs/intro">Axios官网</a></li></ul></li></ul><h4 id="三种参数"><a href="#三种参数" class="headerlink" title="三种参数"></a>三种参数</h4><ul><li><code>params</code><br>  参数是路径的一部分，并且这个参数只能在url路径当中出现</li><li><code>query</code><br> 查询参数<br> 这个参数可以出现在url当中也可以 出现在配置项当中配置url当中是 ? 后面的 key &#x3D; value &amp;key &#x3D;value在配置项当中 配置项的名称叫做params</li><li><code>body</code><br>  请求体参数<br>  通常用在post和put当中，只能在配置对象当中配置;<br>  data这个配置项就是你的body请求体参数,这个数据必须是一个对象</li></ul><p>注意：</p><ul><li>携带query参数时，编写的配置项叫做params</li><li>携带params参数时，就需要自己手动拼在url中<h4 id="利用Axios发送请求"><a href="#利用Axios发送请求" class="headerlink" title="利用Axios发送请求"></a>利用Axios发送请求</h4></li></ul><h5 id="get请求-1"><a href="#get请求-1" class="headerlink" title="get请求"></a>get请求</h5><pre><code>const axios = require(&#39;axios&#39;);// 向给定ID的用户发起请求axios.get(&#39;/user?ID=12345&#39;)  .then(function (response) &#123;    // 处理成功情况    console.log(response);  &#125;)  .catch(function (error) &#123;    // 处理错误情况    console.log(error);  &#125;)  .then(function () &#123;    // 总是会执行  &#125;);// 上述请求也可以按以下方式完成（可选）axios.get(&#39;/user&#39;, &#123;    params: &#123;      ID: 12345    &#125;  &#125;)  .then(function (response) &#123;    console.log(response);  &#125;)  .catch(function (error) &#123;    console.log(error);  &#125;)  .then(function () &#123;    // 总是会执行  &#125;);  // 支持async/await用法async function getUser() &#123;  try &#123;    const response = await axios.get(&#39;/user?ID=12345&#39;);    console.log(response);  &#125; catch (error) &#123;    console.error(error);  &#125;&#125;</code></pre><h5 id="post请求-1"><a href="#post请求-1" class="headerlink" title="post请求"></a>post请求</h5><pre><code>axios.post(&#39;/user&#39;, &#123;    firstName: &#39;Fred&#39;,    lastName: &#39;Flintstone&#39;  &#125;)  .then(function (response) &#123;    console.log(response);  &#125;)  .catch(function (error) &#123;    console.log(error);  &#125;);发起多个并发请求function getUserAccount() &#123;  return axios.get(&#39;/user/12345&#39;);&#125;function getUserPermissions() &#123;  return axios.get(&#39;/user/12345/permissions&#39;);&#125;Promise.all([getUserAccount(), getUserPermissions()])  .then(function (results) &#123;    const acct = results[0];    const perm = results[1];  &#125;);</code></pre><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><h4 id="请求拦截器"><a href="#请求拦截器" class="headerlink" title="请求拦截器"></a>请求拦截器</h4><pre><code>    axios.interceptors.request.use(): 添加请求拦截器</code></pre><p>1.是什么？</p><ul><li>在真正<strong>发请求前</strong>执行的一个回调函数</li></ul><p>2.作用：</p><ul><li>对所有的请求做统一的处理：追加请求头、追加参数、界面loading提示等等</li></ul><h4 id="响应拦截器"><a href="#响应拦截器" class="headerlink" title="响应拦截器"></a>响应拦截器</h4><pre><code>    axios.interceptors.response.use(): 添加响应拦截器</code></pre><p>1.是什么？</p><ul><li>得到响应之后执行的一组回调函数</li></ul><p>2.作用：</p><p>​- <strong>若请求成功，对成功的数据进行处理</strong></p><p>​- <strong>若请求失败，对失败进行统一的操作</strong></p><h3 id="async和await"><a href="#async和await" class="headerlink" title="async和await"></a>async和await</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><ul><li>async awiat  是使用<strong>同步代码实现异步效果</strong></li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><ul><li>async 函数返回的是promise</li><li>async 函数返回值不看 return <strong>必然返回promise</strong></li><li>async  函数返回的promise是成功还是失败   看return</li><li>return的结果代表promise是成功还是失败</li></ul><p>1、如果return是一个非promise的值   代表async函数返回的promise是成功<br>    - 成功的结果是return的结果</p><p>2、如果返回的是成功的promise   代表async函数返回的promise函数返- mise也是成功的（他们不是一个promise）</p><ul><li>成功的结果是return的promise的成功结果</li></ul><p>3、如果返回的是失败的promise   代表async函数返回的promise是失败的</p><ul><li>失败的原因是return的promise失败的原因</li></ul><p>4、如果throw出错误，代表async函数返回的promise是失败的</p><ul><li>失败的原因是抛出的错误的原因</li></ul><h4 id="解决跨域"><a href="#解决跨域" class="headerlink" title="解决跨域"></a>解决跨域</h4><h5 id="1、配置代理服务器"><a href="#1、配置代理服务器" class="headerlink" title="1、配置代理服务器"></a>1、配置代理服务器</h5><pre><code>    devServer:&#123;   //只用与开发环境      proxy:&#123;        &#39;api&#39;:&#123;       //支队请求路由以/api开头的其你去进行代理转发          target:&#39;http://gmall-h5-api.atguigu.cn&#39;,    //转发的目标url          changeOrigin:true,       //支持跨域          // pathRewrite:&#123;&#39;^/api&#39;:&#39;&#39;&#125;     // 后台接口都有/api        &#125;      &#125;    &#125;</code></pre><h5 id="2、jsonp解决跨域"><a href="#2、jsonp解决跨域" class="headerlink" title="2、jsonp解决跨域"></a>2、jsonp解决跨域</h5><pre class=" language-js"><code class="language-js">    <span class="token comment" spellcheck="true">// 1.创建script节点</span>         <span class="token keyword">const</span> scriptNode <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span>         <span class="token comment" spellcheck="true">// 2.给节点指定src属性（请求地址）</span>         scriptNode<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://localhost:8080/test_jsonp?callback=peiqi'</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 3.将节点放入界面</span>         document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>scriptNode<span class="token punctuation">)</span>         window<span class="token punctuation">.</span>peiqi <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>             console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//5.移除已经使用过的script节点</span>         document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>scriptNode<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//总结：Jsonp解决跨域，本质上是避开了 xhr 不受同源策略的限制 利用</span>    <span class="token comment" spellcheck="true">//script 标签发起请求，拿到数据</span></code></pre><h5 id="3、cors解决跨域（后端）"><a href="#3、cors解决跨域（后端）" class="headerlink" title="3、cors解决跨域（后端）"></a>3、cors解决跨域（后端）</h5><pre class=" language-node.js"><code class="language-node.js">    //在后端服务器 添加特殊响应头    response.setHeader('Access-Control-Allow-Origin','*')    response.setHeader('Access-Control-Expose-Origin','*')    response.setHeader('Access-Control-Allow-Methods','*')        //引入cors包    use(cors())    //可以直接为所有请求添加特殊响应头</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2022/05/14/http/"/>
      <url>/2022/05/14/http/</url>
      
        <content type="html"><![CDATA[<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li>超文本传输协议（Hyper Text Transfer Protocol，HTTP）是一个简单的请求-响应协议，它通常运行在TCP之上。它指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应。请求和响应消息的头以ASCII形式给出；而消息内容则具有一个类似MIME的格式。这个简单模型是早期Web成功的有功之臣，因为它使开发和部署非常地直截了当。                    ————百度</li></ul><h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><h5 id="利用http模块创建一个简单的服务器"><a href="#利用http模块创建一个简单的服务器" class="headerlink" title="利用http模块创建一个简单的服务器"></a>利用http模块创建一个简单的服务器</h5><pre class=" language-js"><code class="language-js">  <span class="token comment" spellcheck="true">// 1.引入 http 模块</span>  <span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 2.调用方法 创建服务器对象</span>  <span class="token comment" spellcheck="true">/*       * request 请求报文的封装对象      * response 响应报文的封装对象  */</span>  <span class="token keyword">const</span> server <span class="token operator">=</span> http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>request<span class="token punctuation">,</span>response<span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>        response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'Hello HTTP server'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3.监听端口  启动服务</span>  <span class="token comment" spellcheck="true">/*       端口号    计算的服务端口窗口  总共65536个  8000 3000 9000 8080      默认端口 80       ctrl + c 停止服务  */</span>  server<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8000</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'服务器已经启动，端口 8000 坚挺中......'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">)</span>  </code></pre><h5 id="将服务器拆分为-不同组件"><a href="#将服务器拆分为-不同组件" class="headerlink" title="将服务器拆分为 不同组件"></a>将服务器拆分为 不同组件</h5><p>  主函数 <strong><code>app.js</code></strong></p><pre><code>const server = require(&#39;./server&#39;);server(8000);</code></pre><p> 回调函数 <strong><code>callback.js</code></strong></p><pre><code>    module.exports = (request,response) =&gt;&#123;        response.end(&#39;Hello NPM&#39;);    &#125;;</code></pre><p> 服务对象 <strong><code>server.js</code></strong></p><pre><code>    module.exports = function (port) &#123;        const http = require(&#39;http&#39;);        // 2.调用方法 创建服务器对象        /*         * request 请求报文的封装对象        * response 响应报文的封装对象        */        const callback = require(&#39;./callback&#39;);        const serverCb = require(&#39;./serverOkCallback&#39;)        const server = http.createServer(callback);        // 3.监听端口  启动服务        server.listen(port, serverCb);    &#125;</code></pre><p>  监听端口 <strong><code>serverOkCallback.js</code></strong></p><pre><code>    module.exports = () =&gt;&#123;        console.log(&#39;服务器已经启动，端口坚挺中......&#39;);    &#125;</code></pre><p>  在<code>server.js</code>中我们可以做很多事情</p><pre><code>    // 获取请求报文  GET    /s?wd=关键字 (URL)   HTTP/1.1    // 1.请求的类型    // console.log(request.method);    // console.log(request.method);    // 2.请求的URL    // console.log(request.url);    // 3.HTTP协议版本    // console.log(request.httpVersion);    // 4.获取URL中的路径部分    // 二 调用方法获取参数    // console.log(url.parse(request.url).pathname);     // 5.获取查询字符串    // console.log(url.parse(request.url,true).query);    // 6.请求头信息    // console.log(request.headers);</code></pre><p>  也可以添加事件</p><pre><code>    // 提取请求体数据 POST请求    // 1.声明一个字符串变量    let body = &#39;&#39;;    // 2.绑定data事件    request.on(&#39;data&#39;,chunk =&gt;&#123;        // 拼接        body += chunk.toString();    &#125;);    // 3.绑定end事件    request.on(&#39;end&#39;,()=&gt;&#123;        console.log(body);        // 调用 qs 对象的方法        console.log(qs.parse(body));        response.end(&#39;body recevie&#39;);    &#125;)</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/05/14/zheng-ze-biao-da-shi/"/>
      <url>/2022/05/14/zheng-ze-biao-da-shi/</url>
      
        <content type="html"><![CDATA[<p><img src="/.io//zheng-ze-biao-da-shi%5Czhengze.png" alt="正则表达式"></p>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript</title>
      <link href="/2022/05/13/javascript/"/>
      <url>/2022/05/13/javascript/</url>
      
        <content type="html"><![CDATA[<h3 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h3><p>简介：对常用的JavaScript数组方法和字符串方法以及遍历相关的 <code>for</code> <code>for in</code> <code>for of</code> <code>forEach</code>进行总结,为React和Vue的学习打基础,同时自己方便复习。</p><h4 id="遍历相关"><a href="#遍历相关" class="headerlink" title="遍历相关"></a>遍历相关</h4><pre><code>        - for          最基本的循环    用来专门遍历数组的      可以使用break和continue        - for in       专门用来遍历对象的属性的，这个属性能遍历到还是遍历不到要看这个属性是不是          ​     // for in 效率最低，因为除了遍历自身以外还要遍历原型        - for of                 - ​     // 专门遍历可迭代的数据  ...  (能用可迭代，就用三点)           - ​     // 数组有迭代器          - ​     // 对象没有        - forEach      是一个数组的方法，效率极高  但是不可以使用break和continue</code></pre><h5 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h5><h5 id="every"><a href="#every" class="headerlink" title="every"></a>every</h5><h5 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h5><ul><li><p>描述</p><pre><code>  parseInt(string, radix)   解析一个字符串并返回指定基数的十进制整数， radix 是2-36之间的整数，表示被解析字符串的基数。</code></pre></li><li><p>语法参数</p><pre><code>    parseInt(string, radix);    参数        string    要被解析的值。如果参数不是一个字符串，则将其转换为字符串(使用  ToString 抽象操作)。字符串开头的空白符将会被忽略。    radix 可选    从 2 到 36，表示字符串的基数。例如指定 16 表示被解析值是十六进制数。请注意，10不是默认值！文章后面的描述解释了当参数 radix 不传时该函数的具体行为。</code></pre></li><li><p>返回值</p><pre><code>    从给定的字符串中解析出的一个整数。        或者 NaN，当        radix 小于 2 或大于 36 ，或        第一个非空格字符不能转换为数字。        parseInt(&#39;123&#39;, 5) // 将&#39;123&#39;看作5进制数，返回十进制数38 =&gt; 1*5^2 + 2*5^1 + 3*5^0 = 38</code></pre></li></ul><h5 id="includes"><a href="#includes" class="headerlink" title="includes()"></a>includes()</h5><ul><li><p>描述</p><pre><code>  方法用来判断一个数组是否包含一个指定的值，根据情况，如果包含则返回 `true`，否则返回 `false`。</code></pre><ul><li>语法以及参数</li></ul><pre><code>  arr.includes(valueToFind[, fromIndex])  valueToFind      需要查找的元素值。            备注：使用 includes()比较字符串和字符时是区分大小写的。        fromIndex 可选      从fromIndex 索引处开始查找 valueToFind。如果为负值，则按升序从 array.length + fromIndex 的索引开始搜 （即使从末尾开始往前跳 fromIndex 的绝对值个索引，然后往后搜寻）。默认为 0。</code></pre><ul><li>返回值</li></ul><pre><code>  返回一个布尔值 Boolean 。  ]如果在数组中（或 fromIndex 指定的范围中）找到了 valueToFind，则返回 true，否则返回 false。  0 的值将全部视为相等，与符号无关（即 -0 与 0 和 +0 相等），  但 false 不被认为与 0 相等。  备注： 技术上来讲，includes() 使用 零值相等 算法来确定是否找到给定的元素。</code></pre><ul><li>示例</li></ul><pre><code>  [1, 2, 3].includes(2);     // true  [1, 2, 3].includes(4);     // false  [1, 2, 3].includes(3, 3);  // false  [1, 2, 3].includes(3, -1); // true  [1, 2, NaN].includes(NaN); // true</code></pre></li><li><p>注意</p></li></ul><pre><code>  fromIndex 大于等于数组长度  如果 fromIndex 大于等于数组的长度，则将直接返回 false，且不搜索该数组。  计算出的索引小于 0  如果 fromIndex 为负值，计算出的索引将作为开始搜索searchElement的位置。如果计算出的索引小于 0，则整个数组都会被搜索。  作为通用方法的 includes()  includes() 方法有意设计为通用方法。它不要求this值是数组对象，所以它可以被用于其他类型的对象 (比如类数组对象)。下面的例子展示了 在函数的 arguments 对象上调用的 includes() 方法。</code></pre><h5 id="find"><a href="#find" class="headerlink" title="find()"></a>find()</h5><ul><li><p>描述</p><pre><code>   find() 方法返回数组中满足提供的测试函数的第一个元素的值。否则返回 undefined。</code></pre></li><li><p>语法以及参数</p><pre><code>  arr.find(callback[, thisArg])    参数    callback      在数组每一项上执行的函数，接收 3 个参数：        element          当前遍历到的元素。      index可选          当前遍历到的索引。      array可选          数组本身。    thisArg可选      执行回调时用作this 的对象。 </code></pre></li><li><p>返回值</p><pre><code>  数组中第一个满足所提供测试函数的元素的值，否则返回 undefined。</code></pre></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/find">MDN</a></p></li></ul><h5 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h5><ul><li><p><strong>描述</strong></p><pre><code>  sort() 方法用原地算法对数组的元素进行排序，并返回数组。默认排序顺序是在将元素转换为字符串，然后比较它们的UTF-16代码单元值序列时构建的</code></pre></li><li><p><strong>语法及参数</strong></p><pre><code>  arr.sort([compareFunction])    参数  compareFunction 可选      用来指定按某种顺序进行排列的函数。如果省略，元素按照转换为的字符串的各个字符的Unicode位点进行排序。        firstEl          第一个用于比较的元素。      secondEl          第二个用于比较的元素。    返回值  排序后的数组。请注意，数组已原地排序，并且不进行复制。</code></pre></li><li><p><strong>注意</strong></p><pre><code>  也会影响原数组，默认会按照Unicode编码进行排序    带有compareFunction 参数时,      如果 compareFunction(a, b) 小于 0 ，那么 a 会被排列到 b 之前；      如果 compareFunction(a, b) 等于 0 ， a 和 b 的相对位置不变。备注： ECMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守（例如 Mozilla 在 2003 年之前的版本）；      如果 compareFunction(a, b) 大于 0 ， b 会被排列到 a 之前。      compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的。            、、、通俗理解      比较函数应该具有两个参数 a 和 b，其返回值如下：  若 a 小于 b，即 a - b 小于零，则返回一个小于零的值，数组将按照升序排列。  若 a 等于 b，则返回 0。  若 a 大于 b, 即 a - b 大于零，则返回一个大于零的值，数组将按照降序排列。</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/sort">MDN</a></p><p><a href="https://www.cnblogs.com/saifei/p/9043821.html">简单使用</a></p></li></ul><h5 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h5><ul><li><p><strong>描述</strong></p><pre><code>  filter() 方法创建一个新的数组，新数组中的元素是通过==检查指定数组中符合条件==的所有元素。</code></pre></li><li><p><strong>语法以及参数</strong></p><pre><code>  array.filter(function(currentValue,index,arr), thisValue)    function(currentValue, index,arr)   必须。函数，数组中的每个元素都会执行这个函数  函数参数:      currentValue 必须。当前元素的值      index 可选。当前元素的索引值      arr 可选。当前元素属于的数组对象  thisValue 可选。对象作为该执行回调时使用，传递给函数，用作 &quot;this&quot; 的值。      如果省略了 thisValue ，&quot;this&quot; 的值为 &quot;undefined&quot;    返回值  一个新的、由通过测试的元素组成的数组，如果没有任何数组元素通过测试，则返回空数组。</code></pre></li><li><p><strong>总结</strong></p><pre><code>  //用作过滤器  array.filter((currentValue,index,arr) =&gt; &#123;          return (过滤条件)  &#125;, thisValue)</code></pre></li><li><p><strong>注意：</strong> filter() 不会对空数组进行检测。</p></li><li><p><strong>注意：</strong> filter() 不会改变原始数组。</p></li></ul><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><ul><li><p>语法:</p><pre><code>  - arr.reduce((preValue, current, index, arr)=&gt;f),initialValue)      // 箭头函数    reduce((previousValue, currentValue) =&gt; &#123; /* ... */ &#125; )    reduce((previousValue, currentValue, currentIndex) =&gt; &#123; /* ... */ &#125; )    reduce((previousValue, currentValue, currentIndex, array) =&gt; &#123; /* ... */ &#125; )    reduce((previousValue, currentValue, currentIndex, array) =&gt; &#123; /* ... */ &#125;, initialValue)      // 回调函数    reduce(callbackFn)    reduce(callbackFn, initialValue)      // 内联回调函数    reduce(function(previousValue, currentValue) &#123; /* ... */ &#125;)    reduce(function(previousValue, currentValue, currentIndex) &#123; /* ... */ &#125;)    reduce(function(previousValue, currentValue, currentIndex, array) &#123; /* ... */ &#125;)    reduce(function(previousValue, currentValue, currentIndex, array) &#123; /* ... */ &#125;, initialValue)    arr:当前操作的数组    ==**preValue**:**第一次**执行回调时为给定的**初始值initialValue**,**以后是上一次执行回调时的返回值**。==    ​==备注:若**没有传入initialValue**,则第一次的preValue值是数组中**第一个元素的值**。==     **current 表示当前正在处理的元素;**    index 表示当前正在处理的数组元素的索引,若传入了initialValue值,则为0,否则为1;    array  当前操作的数组(就是arr)    **initialValue 表示初始值。一般做数学时设置为0,若为筛选最值可以不传。</code></pre></li><li><p><strong>用于数据分析</strong></p><pre><code>    let arr = [1,2,3,4,5,6,7,8,9,10,9]            // 数组求和             /* const x = arr.reduce((preValue,current)=&gt;&#123;              console.log(preValue,current);              return preValue+current            &#125;)            console.log(x); */            // 数组中偶数的和----(条件求和)            // const x = arr.reduce((preValue,current)=&gt;preValue+(current % 2 === 0 ? current:0),0)            // console.log(x);            //数组中偶数有几个---(条件统计)            // const x = arr.reduce((preValue,current)=&gt;preValue+(current%2===0 ? 1:0),0)            // console.log(x);            // 数组中所有偶数的积            // const x = arr.reduce((preValue,current)=&gt;preValue*(current%2===0 ? current:1),1)            // console.log(x);            // 数组中最小值----(筛选最值)            /* const x = arr.reduce((preValue,current)=&gt;            &#123;                console.log(preValue,current);                return Math.max(preValue,current)            &#125;,1)            console.log(x);</code></pre></li><li><p><strong>map</strong></p><ul><li><p><strong>描述</strong></p><pre><code>  map() 方法创建一个新数组，这个新数组由原数组中的每个元素都调用一次提供的函数后的返回值组成。</code></pre></li><li><p><strong>语法</strong></p><pre class=" language-js"><code class="language-js">  <span class="token keyword">var</span> new_array <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">callback</span><span class="token punctuation">(</span>currentValue<span class="token punctuation">[</span><span class="token punctuation">,</span> index<span class="token punctuation">[</span><span class="token punctuation">,</span> array<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//为new_array返回元素</span>        <span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token punctuation">,</span> thisArg<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p><strong>参数</strong></p><pre><code>  `callback`  生成新数组元素的函数，使用三个参数：       `currentValue`        `callback` 数组中正在处理的当前元素。         `index`可选          `callback` 数组中正在处理的当前元素的索引。      `array`可选          `map` 方法调用的数组。      `thisArg`可选    执行 `callback` 函数时值被用作`this`。</code></pre></li><li><p><strong>返回值</strong></p><pre><code>  一个由原数组每个元素执行回调函数的结果组成的新数组。</code></pre></li><li><p>例</p><pre><code>  简单用法  const array1 = [1, 4, 9, 16];    // pass a function to map  const map1 = array1.map(x =&gt; x * 2);    console.log(map1);  // expected output: Array [2, 8, 18, 32]</code></pre></li><li><p><strong>注意：</strong> </p><pre><code>  map() 不会对空数组进行检测。  map() 不会改变原始数组。</code></pre><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/map">官方文档</a></p></li></ul></li></ul><h5 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h5><ul><li><p>该方法可以向数组的末尾添加一个或多个元素，并返回数组的新的长度</p></li><li><p>可以将要添加的元素作为方法的参数传递，</p></li><li><p>这样这些元素将会自动添加到数组的末尾 </p></li><li><p>该方法会将数组新的长度作为返回值返回</p></li></ul><h5 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h5><ul><li>该方法可以删除数组的最后一个元素,并将被删除的元素作为返回值返回</li></ul><h5 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h5><ul><li><p>向数组开头添加一个或多个元素，并返回新的数组长度</p></li><li><p>向前边插入元素以后，其他的元素索引会依次调整</p></li></ul><h5 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h5><p> 可以删除数组的第一个元素，并将被删除的元素作为返回值返回</p><h5 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h5><p> 可以用来从数组提取指定元素<br>      - 该方法不会改变元素数组，而是将截取到的元素封装到一个新数组中返回<br>      - 参数：<br>            1.截取开始的位置的索引,  包含  开始索引<br>            2.截取结束的位置的索引,  不包含  结束索引<br>                - 第二个参数可以省略不写,此时会截取从开始索引往后的所有元素<br>              - 索引可以传递一个负值，如果传递一个负值，则从后往前计算<br>                    -1 倒数第一个<br>                    -2 倒数第二个</p><h5 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h5><ul><li><p>描述（增删改一体化）</p><pre><code>可以用于删除数组中的指定元素- 参数：          第一个，表示开始位置的索引          第二个，表示删除的数量          第三个  及以后。。              可以传递一些新的元素，这些元素将会自动插入到开始位置索引前边</code></pre><ul><li><p>注意</p><pre><code>  使用splice()会影响到原数组，会将指定元素从原数组中删除，被删除的元素作为返回值返回</code></pre></li></ul></li></ul><h5 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h5><ul><li><p>可以连接两个或多个数组，并将新的数组返回</p><ul><li>该方法不会对原数组产生影响</li></ul></li></ul><h5 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h5><p> 该方法可以将数组转换为一个字符串</p><ul><li>该方法不会对原数组产生影响，而是将转换后的字符串作为结果返回</li><li>在join()中可以指定一个字符串作为参数，这个字符串将会成为数组中元素的连接符</li></ul><pre><code>        如果不指定连接符，则默认使用,作为连接符</code></pre><h5 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h5><p> 该方法用来反转数组（前边的去后边，后边的去前边）<br>      - 该方法会直接修改原数组</p><h4 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h4><h5 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h5><ul><li><p>描述</p><pre><code>  indexOf()方法返回调用它的 String 对象中**第一次出现的指定值的索引**，从 **fromIndex** 处进行搜索。如果未找到该值，则返回 -1。</code></pre></li><li><p><strong>语法</strong></p><pre><code>  str.indexOf(searchValue [, fromIndex])</code></pre></li><li><p><strong>参数</strong></p><pre><code>  searchValue      要被查找的字符串值。如果没有提供确切地提供字符串，searchValue 会被强制设置为 &quot;undefined&quot;， 然后在当前字符串中查找这个值。举个例子：&#39;undefined&#39;.indexOf() 将会返回0，因为 undefined 在位置0处被找到，但是 &#39;undefine&#39;.indexOf() 将会返回 -1 ，因为字符串 &#39;undefined&#39; 未被找到。        fromIndex 可选      数字表示开始查找的位置。可以是任意整数，默认值为 0。如果 fromIndex 的值小于 0，或者大于 str.length ，那么查找分别从 0 和str.length 开始。（译者注：  fromIndex 的值小于 0，等同于为空情况； fromIndex 的值大于或等于 str.length ，那么结果会直接返回 -1 。）举个例子，&#39;hello world&#39;.indexOf(&#39;o&#39;, -5) 返回 4 ，因为它是从位置0处开始查找，然后 o 在位置4处被找到。另一方面，&#39;hello world&#39;.indexOf(&#39;o&#39;, 11) （或 fromIndex 填入任何大于11的值）将会返回 -1 ，因为开始查找的位置11处，已经是这个字符串的结尾了。 </code></pre></li><li><p><strong>返回值</strong></p><pre><code>  查找的字符串 searchValue 的第一次出现的索引，如果没有找到，则返回 -1。    若被查找的字符串 searchValue 是一个空字符串，将会产生“奇怪”的结果。如果 fromIndex 值为空，或者 fromIndex 值小于被查找的字符串的长度，返回值和以下的 fromIndex 值一样：              &#39;hello world&#39;.indexOf(&#39;&#39;) // 返回 0              &#39;hello world&#39;.indexOf(&#39;&#39;, 0) // 返回 0              &#39;hello world&#39;.indexOf(&#39;&#39;, 3) // 返回 3              &#39;hello world&#39;.indexOf(&#39;&#39;, 8) // 返回 8                另外，如果 fromIndex 值大于等于字符串的长度，将会直接返回字符串的长度（str.length）：              &#39;hello world&#39;.indexOf(&#39;&#39;, 11) // 返回 11              &#39;hello world&#39;.indexOf(&#39;&#39;, 13) // 返回 11              &#39;hello world&#39;.indexOf(&#39;&#39;, 22) // 返回 11                从前面一个例子可以看出，被查找的值是空值时，Javascript将直接返回指定的索引值。从后面一个例子可以看出，被查找的值是空值时，Javascript将直接返回字符串的长度。</code></pre></li><li><p><strong>注意</strong></p><pre><code>  字符串中的字符被从左向右索引。第一个字符的索引（index）是 0，变量名为 stringName 的字符串的最后一个字符的索引是 stringName.length - 1    indexOf 方法是区分大小写的    注意 0 并不会被当成 true ，-1 不会被当成 false 。所以当检测某个字符串是否存在于另一个字符串中时，可使用下面的方法：          &#39;Blue Whale&#39;.indexOf(&#39;Blue&#39;) !== -1    // true          &#39;Blue Whale&#39;.indexOf(&#39;Bloe&#39;) !== -1    // false          ~(&#39;Blue Whale&#39;.indexOf(&#39;Bloe&#39;))        // 0, 这是一种错误用法</code></pre></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf">MDN文档</a></p></li></ul><h5 id="trim"><a href="#trim" class="headerlink" title="trim"></a>trim</h5><ul><li><p>描述</p><pre><code>  `trim()`方法会从一个字符串的两端删除空白字符。在这个上下文中的空白字符是所有的空白字符 (space, tab, no-break space 等) 以及所有行终止符字符（如 LF，CR等）。</code></pre><pre><code>  `trim()` 方法返回一个从两头去掉空白字符的字符串，并不影响原字符串本身。</code></pre></li><li><p>语法</p><pre><code>  str.trim()</code></pre></li><li><p>返回值</p><pre><code>  一个代表调用字符串两端去掉空白的新字符串。</code></pre></li><li><p>兼容久环境、</p><pre><code>  if (!String.prototype.trim) &#123;    String.prototype.trim = function () &#123;      return this.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, &#39;&#39;);    &#125;;  &#125;</code></pre></li></ul><h4 id="React打基础"><a href="#React打基础" class="headerlink" title="React打基础"></a>React打基础</h4><pre><code>map- 参数- `callback`  - 生成新数组元素的函数，使用三个参数：     - `currentValue`    -   `callback` 数组中正在处理的当前元素。   - `index`可选      - `callback` 数组中正在处理的当前元素的索引。    - `array`可选      - `map` 方法调用的数组。  - `thisArg`可选  - 执行 `callback` 函数时值被用作`this`。  </code></pre><h4 id="Vue打基础"><a href="#Vue打基础" class="headerlink" title="Vue打基础"></a>Vue打基础</h4><pre class=" language-js"><code class="language-js">object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">//返回的是参数对象的属性组成的数组，可以用数组的方法forEach去遍历对象</span><span class="token comment" spellcheck="true">//例如</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>item <span class="token operator">=</span><span class="token operator">></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span>obj<span class="token punctuation">[</span>item<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// Object.defineProperty</span>        <span class="token comment" spellcheck="true">// 这个方法在为对象添加或者修改     属性为响应式属性</span>        <span class="token comment" spellcheck="true">/*         语法            Object.defineProperty(obj, prop, descriptor)              参数                obj                    要定义属性的对象。                prop                    要定义或修改的属性的名称或 Symbol 。                descriptor                    要定义或修改的属性描述符。               返回值                    被传递给函数的对象。        */</span></code></pre><h4 id="元素的大小和位置"><a href="#元素的大小和位置" class="headerlink" title="元素的大小和位置"></a>元素的大小和位置</h4><h5 id="PC"><a href="#PC" class="headerlink" title="PC"></a>PC</h5><ul><li><p><strong>client</strong>系列</p><pre><code>    页可见区域宽： document.body.clientWidth;    网页可见区域高： document.body.clientHeight;</code></pre></li><li><p><strong>offset</strong>系列</p><pre><code>    网页可见区域宽： document.body.offsetWidth   (包括边线的宽);    网页可见区域高： document.body.offsetHeight (包括边线的宽);</code></pre></li><li><p><strong>scroll</strong>系列</p><pre><code>    网页正文全文宽： document.body.scrollWidth;    网页正文全文高： document.body.scrollHeight;    网页被卷去的高： document.body.scrollTop;    网页被卷去的左： document.body.scrollLeft;</code></pre></li></ul><h5 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h5><pre><code>    网页正文部分上： window.screenTop;    网页正文部分左： window.screenLeft;    屏幕分辨率的高： window.screen.height;    屏幕分辨率的宽： window.screen.width;    屏幕可用工作区高度： window.screen.availHeight;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
